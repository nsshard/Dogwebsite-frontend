{"ast":null,"code":"'use strict';\n\nconst MongoError = require('../core/error').MongoError;\n\nconst Aspect = require('./operation').Aspect;\n\nconst OperationBase = require('./operation').OperationBase;\n\nconst ReadPreference = require('../core/topologies/read_preference');\n\nconst isRetryableError = require('../core/error').isRetryableError;\n\nconst maxWireVersion = require('../core/utils').maxWireVersion;\n\nconst isUnifiedTopology = require('../core/utils').isUnifiedTopology;\n/**\n * Executes the given operation with provided arguments.\n *\n * This method reduces large amounts of duplication in the entire codebase by providing\n * a single point for determining whether callbacks or promises should be used. Additionally\n * it allows for a single point of entry to provide features such as implicit sessions, which\n * are required by the Driver Sessions specification in the event that a ClientSession is\n * not provided\n *\n * @param {object} topology The topology to execute this operation on\n * @param {Operation} operation The operation to execute\n * @param {function} callback The command result callback\n */\n\n\nfunction executeOperation(topology, operation, callback) {\n  if (topology == null) {\n    throw new TypeError('This method requires a valid topology instance');\n  }\n\n  if (!(operation instanceof OperationBase)) {\n    throw new TypeError('This method requires a valid operation instance');\n  }\n\n  if (isUnifiedTopology(topology) && topology.shouldCheckForSessionSupport()) {\n    return selectServerForSessionSupport(topology, operation, callback);\n  }\n\n  const Promise = topology.s.promiseLibrary; // The driver sessions spec mandates that we implicitly create sessions for operations\n  // that are not explicitly provided with a session.\n\n  let session, owner;\n\n  if (topology.hasSessionSupport()) {\n    if (operation.session == null) {\n      owner = Symbol();\n      session = topology.startSession({\n        owner\n      });\n      operation.session = session;\n    } else if (operation.session.hasEnded) {\n      throw new MongoError('Use of expired sessions is not permitted');\n    }\n  }\n\n  let result;\n\n  if (typeof callback !== 'function') {\n    result = new Promise((resolve, reject) => {\n      callback = (err, res) => {\n        if (err) return reject(err);\n        resolve(res);\n      };\n    });\n  }\n\n  function executeCallback(err, result) {\n    if (session && session.owner === owner) {\n      session.endSession();\n\n      if (operation.session === session) {\n        operation.clearSession();\n      }\n    }\n\n    callback(err, result);\n  }\n\n  try {\n    if (operation.hasAspect(Aspect.EXECUTE_WITH_SELECTION)) {\n      executeWithServerSelection(topology, operation, executeCallback);\n    } else {\n      operation.execute(executeCallback);\n    }\n  } catch (e) {\n    if (session && session.owner === owner) {\n      session.endSession();\n\n      if (operation.session === session) {\n        operation.clearSession();\n      }\n    }\n\n    throw e;\n  }\n\n  return result;\n}\n\nfunction supportsRetryableReads(server) {\n  return maxWireVersion(server) >= 6;\n}\n\nfunction executeWithServerSelection(topology, operation, callback) {\n  const readPreference = operation.readPreference || ReadPreference.primary;\n  const inTransaction = operation.session && operation.session.inTransaction();\n\n  if (inTransaction && !readPreference.equals(ReadPreference.primary)) {\n    callback(new MongoError(`Read preference in a transaction must be primary, not: ${readPreference.mode}`));\n    return;\n  }\n\n  const serverSelectionOptions = {\n    readPreference,\n    session: operation.session\n  };\n\n  function callbackWithRetry(err, result) {\n    if (err == null) {\n      return callback(null, result);\n    }\n\n    if (!isRetryableError(err)) {\n      return callback(err);\n    } // select a new server, and attempt to retry the operation\n\n\n    topology.selectServer(serverSelectionOptions, (err, server) => {\n      if (err || !supportsRetryableReads(server)) {\n        callback(err, null);\n        return;\n      }\n\n      operation.execute(server, callback);\n    });\n  } // select a server, and execute the operation against it\n\n\n  topology.selectServer(serverSelectionOptions, (err, server) => {\n    if (err) {\n      callback(err, null);\n      return;\n    }\n\n    const shouldRetryReads = topology.s.options.retryReads !== false && operation.session && !inTransaction && supportsRetryableReads(server) && operation.canRetryRead;\n\n    if (operation.hasAspect(Aspect.RETRYABLE) && shouldRetryReads) {\n      operation.execute(server, callbackWithRetry);\n      return;\n    }\n\n    operation.execute(server, callback);\n  });\n} // TODO: This is only supported for unified topology, it should go away once\n//       we remove support for legacy topology types.\n\n\nfunction selectServerForSessionSupport(topology, operation, callback) {\n  const Promise = topology.s.promiseLibrary;\n  let result;\n\n  if (typeof callback !== 'function') {\n    result = new Promise((resolve, reject) => {\n      callback = (err, result) => {\n        if (err) return reject(err);\n        resolve(result);\n      };\n    });\n  }\n\n  topology.selectServer(ReadPreference.primaryPreferred, err => {\n    if (err) {\n      callback(err);\n      return;\n    }\n\n    executeOperation(topology, operation, callback);\n  });\n  return result;\n}\n\nmodule.exports = executeOperation;","map":{"version":3,"names":["MongoError","require","Aspect","OperationBase","ReadPreference","isRetryableError","maxWireVersion","isUnifiedTopology","executeOperation","topology","operation","callback","TypeError","shouldCheckForSessionSupport","selectServerForSessionSupport","Promise","s","promiseLibrary","session","owner","hasSessionSupport","Symbol","startSession","hasEnded","result","resolve","reject","err","res","executeCallback","endSession","clearSession","hasAspect","EXECUTE_WITH_SELECTION","executeWithServerSelection","execute","e","supportsRetryableReads","server","readPreference","primary","inTransaction","equals","mode","serverSelectionOptions","callbackWithRetry","selectServer","shouldRetryReads","options","retryReads","canRetryRead","RETRYABLE","primaryPreferred","module","exports"],"sources":["C:/Users/Administrator/Desktop/webAPI work/web/dog-website/node_modules/koa-mongo/node_modules/mongodb/lib/operations/execute_operation.js"],"sourcesContent":["'use strict';\n\nconst MongoError = require('../core/error').MongoError;\nconst Aspect = require('./operation').Aspect;\nconst OperationBase = require('./operation').OperationBase;\nconst ReadPreference = require('../core/topologies/read_preference');\nconst isRetryableError = require('../core/error').isRetryableError;\nconst maxWireVersion = require('../core/utils').maxWireVersion;\nconst isUnifiedTopology = require('../core/utils').isUnifiedTopology;\n\n/**\n * Executes the given operation with provided arguments.\n *\n * This method reduces large amounts of duplication in the entire codebase by providing\n * a single point for determining whether callbacks or promises should be used. Additionally\n * it allows for a single point of entry to provide features such as implicit sessions, which\n * are required by the Driver Sessions specification in the event that a ClientSession is\n * not provided\n *\n * @param {object} topology The topology to execute this operation on\n * @param {Operation} operation The operation to execute\n * @param {function} callback The command result callback\n */\nfunction executeOperation(topology, operation, callback) {\n  if (topology == null) {\n    throw new TypeError('This method requires a valid topology instance');\n  }\n\n  if (!(operation instanceof OperationBase)) {\n    throw new TypeError('This method requires a valid operation instance');\n  }\n\n  if (isUnifiedTopology(topology) && topology.shouldCheckForSessionSupport()) {\n    return selectServerForSessionSupport(topology, operation, callback);\n  }\n\n  const Promise = topology.s.promiseLibrary;\n\n  // The driver sessions spec mandates that we implicitly create sessions for operations\n  // that are not explicitly provided with a session.\n  let session, owner;\n  if (topology.hasSessionSupport()) {\n    if (operation.session == null) {\n      owner = Symbol();\n      session = topology.startSession({ owner });\n      operation.session = session;\n    } else if (operation.session.hasEnded) {\n      throw new MongoError('Use of expired sessions is not permitted');\n    }\n  }\n\n  let result;\n  if (typeof callback !== 'function') {\n    result = new Promise((resolve, reject) => {\n      callback = (err, res) => {\n        if (err) return reject(err);\n        resolve(res);\n      };\n    });\n  }\n\n  function executeCallback(err, result) {\n    if (session && session.owner === owner) {\n      session.endSession();\n      if (operation.session === session) {\n        operation.clearSession();\n      }\n    }\n\n    callback(err, result);\n  }\n\n  try {\n    if (operation.hasAspect(Aspect.EXECUTE_WITH_SELECTION)) {\n      executeWithServerSelection(topology, operation, executeCallback);\n    } else {\n      operation.execute(executeCallback);\n    }\n  } catch (e) {\n    if (session && session.owner === owner) {\n      session.endSession();\n      if (operation.session === session) {\n        operation.clearSession();\n      }\n    }\n\n    throw e;\n  }\n\n  return result;\n}\n\nfunction supportsRetryableReads(server) {\n  return maxWireVersion(server) >= 6;\n}\n\nfunction executeWithServerSelection(topology, operation, callback) {\n  const readPreference = operation.readPreference || ReadPreference.primary;\n  const inTransaction = operation.session && operation.session.inTransaction();\n\n  if (inTransaction && !readPreference.equals(ReadPreference.primary)) {\n    callback(\n      new MongoError(\n        `Read preference in a transaction must be primary, not: ${readPreference.mode}`\n      )\n    );\n\n    return;\n  }\n\n  const serverSelectionOptions = {\n    readPreference,\n    session: operation.session\n  };\n\n  function callbackWithRetry(err, result) {\n    if (err == null) {\n      return callback(null, result);\n    }\n\n    if (!isRetryableError(err)) {\n      return callback(err);\n    }\n\n    // select a new server, and attempt to retry the operation\n    topology.selectServer(serverSelectionOptions, (err, server) => {\n      if (err || !supportsRetryableReads(server)) {\n        callback(err, null);\n        return;\n      }\n\n      operation.execute(server, callback);\n    });\n  }\n\n  // select a server, and execute the operation against it\n  topology.selectServer(serverSelectionOptions, (err, server) => {\n    if (err) {\n      callback(err, null);\n      return;\n    }\n\n    const shouldRetryReads =\n      topology.s.options.retryReads !== false &&\n      operation.session &&\n      !inTransaction &&\n      supportsRetryableReads(server) &&\n      operation.canRetryRead;\n\n    if (operation.hasAspect(Aspect.RETRYABLE) && shouldRetryReads) {\n      operation.execute(server, callbackWithRetry);\n      return;\n    }\n\n    operation.execute(server, callback);\n  });\n}\n\n// TODO: This is only supported for unified topology, it should go away once\n//       we remove support for legacy topology types.\nfunction selectServerForSessionSupport(topology, operation, callback) {\n  const Promise = topology.s.promiseLibrary;\n\n  let result;\n  if (typeof callback !== 'function') {\n    result = new Promise((resolve, reject) => {\n      callback = (err, result) => {\n        if (err) return reject(err);\n        resolve(result);\n      };\n    });\n  }\n\n  topology.selectServer(ReadPreference.primaryPreferred, err => {\n    if (err) {\n      callback(err);\n      return;\n    }\n\n    executeOperation(topology, operation, callback);\n  });\n\n  return result;\n}\n\nmodule.exports = executeOperation;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}