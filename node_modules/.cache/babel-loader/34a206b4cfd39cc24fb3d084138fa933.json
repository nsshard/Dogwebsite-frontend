{"ast":null,"code":"'use strict';\n\nconst ReadPreference = require('./read_preference');\n\nconst TopologyType = require('../sdam/common').TopologyType;\n\nconst MongoError = require('../error').MongoError;\n\nconst isRetryableWriteError = require('../error').isRetryableWriteError;\n\nconst maxWireVersion = require('../utils').maxWireVersion;\n\nconst MongoNetworkError = require('../error').MongoNetworkError;\n\nconst MMAPv1_RETRY_WRITES_ERROR_CODE = 20;\n/**\n * Emit event if it exists\n * @method\n */\n\nfunction emitSDAMEvent(self, event, description) {\n  if (self.listeners(event).length > 0) {\n    self.emit(event, description);\n  }\n}\n\nfunction createCompressionInfo(options) {\n  if (!options.compression || !options.compression.compressors) {\n    return [];\n  } // Check that all supplied compressors are valid\n\n\n  options.compression.compressors.forEach(function (compressor) {\n    if (compressor !== 'snappy' && compressor !== 'zlib') {\n      throw new Error('compressors must be at least one of snappy or zlib');\n    }\n  });\n  return options.compression.compressors;\n}\n\nfunction clone(object) {\n  return JSON.parse(JSON.stringify(object));\n}\n\nvar getPreviousDescription = function (self) {\n  if (!self.s.serverDescription) {\n    self.s.serverDescription = {\n      address: self.name,\n      arbiters: [],\n      hosts: [],\n      passives: [],\n      type: 'Unknown'\n    };\n  }\n\n  return self.s.serverDescription;\n};\n\nvar emitServerDescriptionChanged = function (self, description) {\n  if (self.listeners('serverDescriptionChanged').length > 0) {\n    // Emit the server description changed events\n    self.emit('serverDescriptionChanged', {\n      topologyId: self.s.topologyId !== -1 ? self.s.topologyId : self.id,\n      address: self.name,\n      previousDescription: getPreviousDescription(self),\n      newDescription: description\n    });\n    self.s.serverDescription = description;\n  }\n};\n\nvar getPreviousTopologyDescription = function (self) {\n  if (!self.s.topologyDescription) {\n    self.s.topologyDescription = {\n      topologyType: 'Unknown',\n      servers: [{\n        address: self.name,\n        arbiters: [],\n        hosts: [],\n        passives: [],\n        type: 'Unknown'\n      }]\n    };\n  }\n\n  return self.s.topologyDescription;\n};\n\nvar emitTopologyDescriptionChanged = function (self, description) {\n  if (self.listeners('topologyDescriptionChanged').length > 0) {\n    // Emit the server description changed events\n    self.emit('topologyDescriptionChanged', {\n      topologyId: self.s.topologyId !== -1 ? self.s.topologyId : self.id,\n      address: self.name,\n      previousDescription: getPreviousTopologyDescription(self),\n      newDescription: description\n    });\n    self.s.serverDescription = description;\n  }\n};\n\nvar changedIsMaster = function (self, currentIsmaster, ismaster) {\n  var currentType = getTopologyType(self, currentIsmaster);\n  var newType = getTopologyType(self, ismaster);\n  if (newType !== currentType) return true;\n  return false;\n};\n\nvar getTopologyType = function (self, ismaster) {\n  if (!ismaster) {\n    ismaster = self.ismaster;\n  }\n\n  if (!ismaster) return 'Unknown';\n  if (ismaster.ismaster && ismaster.msg === 'isdbgrid') return 'Mongos';\n  if (ismaster.ismaster && !ismaster.hosts) return 'Standalone';\n  if (ismaster.ismaster) return 'RSPrimary';\n  if (ismaster.secondary) return 'RSSecondary';\n  if (ismaster.arbiterOnly) return 'RSArbiter';\n  return 'Unknown';\n};\n\nvar inquireServerState = function (self) {\n  return function (callback) {\n    if (self.s.state === 'destroyed') return; // Record response time\n\n    var start = new Date().getTime(); // emitSDAMEvent\n\n    emitSDAMEvent(self, 'serverHeartbeatStarted', {\n      connectionId: self.name\n    }); // Attempt to execute ismaster command\n\n    self.command('admin.$cmd', {\n      ismaster: true\n    }, {\n      monitoring: true\n    }, function (err, r) {\n      if (!err) {\n        // Legacy event sender\n        self.emit('ismaster', r, self); // Calculate latencyMS\n\n        var latencyMS = new Date().getTime() - start; // Server heart beat event\n\n        emitSDAMEvent(self, 'serverHeartbeatSucceeded', {\n          durationMS: latencyMS,\n          reply: r.result,\n          connectionId: self.name\n        }); // Did the server change\n\n        if (changedIsMaster(self, self.s.ismaster, r.result)) {\n          // Emit server description changed if something listening\n          emitServerDescriptionChanged(self, {\n            address: self.name,\n            arbiters: [],\n            hosts: [],\n            passives: [],\n            type: !self.s.inTopology ? 'Standalone' : getTopologyType(self)\n          });\n        } // Updat ismaster view\n\n\n        self.s.ismaster = r.result; // Set server response time\n\n        self.s.isMasterLatencyMS = latencyMS;\n      } else {\n        emitSDAMEvent(self, 'serverHeartbeatFailed', {\n          durationMS: latencyMS,\n          failure: err,\n          connectionId: self.name\n        });\n      } // Peforming an ismaster monitoring callback operation\n\n\n      if (typeof callback === 'function') {\n        return callback(err, r);\n      } // Perform another sweep\n\n\n      self.s.inquireServerStateTimeout = setTimeout(inquireServerState(self), self.s.haInterval);\n    });\n  };\n}; //\n// Clone the options\n\n\nvar cloneOptions = function (options) {\n  var opts = {};\n\n  for (var name in options) {\n    opts[name] = options[name];\n  }\n\n  return opts;\n};\n\nfunction Interval(fn, time) {\n  var timer = false;\n\n  this.start = function () {\n    if (!this.isRunning()) {\n      timer = setInterval(fn, time);\n    }\n\n    return this;\n  };\n\n  this.stop = function () {\n    clearInterval(timer);\n    timer = false;\n    return this;\n  };\n\n  this.isRunning = function () {\n    return timer !== false;\n  };\n}\n\nfunction Timeout(fn, time) {\n  var timer = false;\n\n  var func = () => {\n    if (timer) {\n      clearTimeout(timer);\n      timer = false;\n      fn();\n    }\n  };\n\n  this.start = function () {\n    if (!this.isRunning()) {\n      timer = setTimeout(func, time);\n    }\n\n    return this;\n  };\n\n  this.stop = function () {\n    clearTimeout(timer);\n    timer = false;\n    return this;\n  };\n\n  this.isRunning = function () {\n    return timer !== false;\n  };\n}\n\nfunction diff(previous, current) {\n  // Difference document\n  var diff = {\n    servers: []\n  }; // Previous entry\n\n  if (!previous) {\n    previous = {\n      servers: []\n    };\n  } // Check if we have any previous servers missing in the current ones\n\n\n  for (var i = 0; i < previous.servers.length; i++) {\n    var found = false;\n\n    for (var j = 0; j < current.servers.length; j++) {\n      if (current.servers[j].address.toLowerCase() === previous.servers[i].address.toLowerCase()) {\n        found = true;\n        break;\n      }\n    }\n\n    if (!found) {\n      // Add to the diff\n      diff.servers.push({\n        address: previous.servers[i].address,\n        from: previous.servers[i].type,\n        to: 'Unknown'\n      });\n    }\n  } // Check if there are any severs that don't exist\n\n\n  for (j = 0; j < current.servers.length; j++) {\n    found = false; // Go over all the previous servers\n\n    for (i = 0; i < previous.servers.length; i++) {\n      if (previous.servers[i].address.toLowerCase() === current.servers[j].address.toLowerCase()) {\n        found = true;\n        break;\n      }\n    } // Add the server to the diff\n\n\n    if (!found) {\n      diff.servers.push({\n        address: current.servers[j].address,\n        from: 'Unknown',\n        to: current.servers[j].type\n      });\n    }\n  } // Got through all the servers\n\n\n  for (i = 0; i < previous.servers.length; i++) {\n    var prevServer = previous.servers[i]; // Go through all current servers\n\n    for (j = 0; j < current.servers.length; j++) {\n      var currServer = current.servers[j]; // Matching server\n\n      if (prevServer.address.toLowerCase() === currServer.address.toLowerCase()) {\n        // We had a change in state\n        if (prevServer.type !== currServer.type) {\n          diff.servers.push({\n            address: prevServer.address,\n            from: prevServer.type,\n            to: currServer.type\n          });\n        }\n      }\n    }\n  } // Return difference\n\n\n  return diff;\n}\n/**\n * Shared function to determine clusterTime for a given topology\n *\n * @param {*} topology\n * @param {*} clusterTime\n */\n\n\nfunction resolveClusterTime(topology, $clusterTime) {\n  if (topology.clusterTime == null) {\n    topology.clusterTime = $clusterTime;\n  } else {\n    if ($clusterTime.clusterTime.greaterThan(topology.clusterTime.clusterTime)) {\n      topology.clusterTime = $clusterTime;\n    }\n  }\n} // NOTE: this is a temporary move until the topologies can be more formally refactored\n//       to share code.\n\n\nconst SessionMixins = {\n  endSessions: function (sessions, callback) {\n    if (!Array.isArray(sessions)) {\n      sessions = [sessions];\n    } // TODO:\n    //   When connected to a sharded cluster the endSessions command\n    //   can be sent to any mongos. When connected to a replica set the\n    //   endSessions command MUST be sent to the primary if the primary\n    //   is available, otherwise it MUST be sent to any available secondary.\n    //   Is it enough to use: ReadPreference.primaryPreferred ?\n\n\n    this.command('admin.$cmd', {\n      endSessions: sessions\n    }, {\n      readPreference: ReadPreference.primaryPreferred\n    }, () => {\n      // intentionally ignored, per spec\n      if (typeof callback === 'function') callback();\n    });\n  }\n};\n\nfunction topologyType(topology) {\n  if (topology.description) {\n    return topology.description.type;\n  }\n\n  if (topology.type === 'mongos') {\n    return TopologyType.Sharded;\n  } else if (topology.type === 'replset') {\n    return TopologyType.ReplicaSetWithPrimary;\n  }\n\n  return TopologyType.Single;\n}\n\nconst RETRYABLE_WIRE_VERSION = 6;\n/**\n * Determines whether the provided topology supports retryable writes\n *\n * @param {Mongos|Replset} topology\n */\n\nconst isRetryableWritesSupported = function (topology) {\n  const maxWireVersion = topology.lastIsMaster().maxWireVersion;\n\n  if (maxWireVersion < RETRYABLE_WIRE_VERSION) {\n    return false;\n  }\n\n  if (!topology.logicalSessionTimeoutMinutes) {\n    return false;\n  }\n\n  if (topologyType(topology) === TopologyType.Single) {\n    return false;\n  }\n\n  return true;\n};\n\nconst MMAPv1_RETRY_WRITES_ERROR_MESSAGE = 'This MongoDB deployment does not support retryable writes. Please add retryWrites=false to your connection string.';\n\nfunction getMMAPError(err) {\n  if (err.code !== MMAPv1_RETRY_WRITES_ERROR_CODE || !err.errmsg.includes('Transaction numbers')) {\n    return err;\n  } // According to the retryable writes spec, we must replace the error message in this case.\n  // We need to replace err.message so the thrown message is correct and we need to replace err.errmsg to meet the spec requirement.\n\n\n  const newErr = new MongoError({\n    message: MMAPv1_RETRY_WRITES_ERROR_MESSAGE,\n    errmsg: MMAPv1_RETRY_WRITES_ERROR_MESSAGE,\n    originalError: err\n  });\n  return newErr;\n} // NOTE: only used for legacy topology types\n\n\nfunction legacyIsRetryableWriteError(err, topology) {\n  if (!(err instanceof MongoError)) {\n    return false;\n  } // if pre-4.4 server, then add error label if its a retryable write error\n\n\n  if (isRetryableWritesSupported(topology) && (err instanceof MongoNetworkError || maxWireVersion(topology) < 9 && isRetryableWriteError(err))) {\n    err.addErrorLabel('RetryableWriteError');\n  }\n\n  return err.hasErrorLabel('RetryableWriteError');\n}\n\nmodule.exports = {\n  SessionMixins,\n  resolveClusterTime,\n  inquireServerState,\n  getTopologyType,\n  emitServerDescriptionChanged,\n  emitTopologyDescriptionChanged,\n  cloneOptions,\n  createCompressionInfo,\n  clone,\n  diff,\n  Interval,\n  Timeout,\n  isRetryableWritesSupported,\n  getMMAPError,\n  topologyType,\n  legacyIsRetryableWriteError\n};","map":{"version":3,"names":["ReadPreference","require","TopologyType","MongoError","isRetryableWriteError","maxWireVersion","MongoNetworkError","MMAPv1_RETRY_WRITES_ERROR_CODE","emitSDAMEvent","self","event","description","listeners","length","emit","createCompressionInfo","options","compression","compressors","forEach","compressor","Error","clone","object","JSON","parse","stringify","getPreviousDescription","s","serverDescription","address","name","arbiters","hosts","passives","type","emitServerDescriptionChanged","topologyId","id","previousDescription","newDescription","getPreviousTopologyDescription","topologyDescription","topologyType","servers","emitTopologyDescriptionChanged","changedIsMaster","currentIsmaster","ismaster","currentType","getTopologyType","newType","msg","secondary","arbiterOnly","inquireServerState","callback","state","start","Date","getTime","connectionId","command","monitoring","err","r","latencyMS","durationMS","reply","result","inTopology","isMasterLatencyMS","failure","inquireServerStateTimeout","setTimeout","haInterval","cloneOptions","opts","Interval","fn","time","timer","isRunning","setInterval","stop","clearInterval","Timeout","func","clearTimeout","diff","previous","current","i","found","j","toLowerCase","push","from","to","prevServer","currServer","resolveClusterTime","topology","$clusterTime","clusterTime","greaterThan","SessionMixins","endSessions","sessions","Array","isArray","readPreference","primaryPreferred","Sharded","ReplicaSetWithPrimary","Single","RETRYABLE_WIRE_VERSION","isRetryableWritesSupported","lastIsMaster","logicalSessionTimeoutMinutes","MMAPv1_RETRY_WRITES_ERROR_MESSAGE","getMMAPError","code","errmsg","includes","newErr","message","originalError","legacyIsRetryableWriteError","addErrorLabel","hasErrorLabel","module","exports"],"sources":["C:/Users/Administrator/Desktop/webAPI work/web/dog-website/node_modules/koa-mongo/node_modules/mongodb/lib/core/topologies/shared.js"],"sourcesContent":["'use strict';\nconst ReadPreference = require('./read_preference');\nconst TopologyType = require('../sdam/common').TopologyType;\nconst MongoError = require('../error').MongoError;\nconst isRetryableWriteError = require('../error').isRetryableWriteError;\nconst maxWireVersion = require('../utils').maxWireVersion;\nconst MongoNetworkError = require('../error').MongoNetworkError;\nconst MMAPv1_RETRY_WRITES_ERROR_CODE = 20;\n\n/**\n * Emit event if it exists\n * @method\n */\nfunction emitSDAMEvent(self, event, description) {\n  if (self.listeners(event).length > 0) {\n    self.emit(event, description);\n  }\n}\n\nfunction createCompressionInfo(options) {\n  if (!options.compression || !options.compression.compressors) {\n    return [];\n  }\n\n  // Check that all supplied compressors are valid\n  options.compression.compressors.forEach(function(compressor) {\n    if (compressor !== 'snappy' && compressor !== 'zlib') {\n      throw new Error('compressors must be at least one of snappy or zlib');\n    }\n  });\n\n  return options.compression.compressors;\n}\n\nfunction clone(object) {\n  return JSON.parse(JSON.stringify(object));\n}\n\nvar getPreviousDescription = function(self) {\n  if (!self.s.serverDescription) {\n    self.s.serverDescription = {\n      address: self.name,\n      arbiters: [],\n      hosts: [],\n      passives: [],\n      type: 'Unknown'\n    };\n  }\n\n  return self.s.serverDescription;\n};\n\nvar emitServerDescriptionChanged = function(self, description) {\n  if (self.listeners('serverDescriptionChanged').length > 0) {\n    // Emit the server description changed events\n    self.emit('serverDescriptionChanged', {\n      topologyId: self.s.topologyId !== -1 ? self.s.topologyId : self.id,\n      address: self.name,\n      previousDescription: getPreviousDescription(self),\n      newDescription: description\n    });\n\n    self.s.serverDescription = description;\n  }\n};\n\nvar getPreviousTopologyDescription = function(self) {\n  if (!self.s.topologyDescription) {\n    self.s.topologyDescription = {\n      topologyType: 'Unknown',\n      servers: [\n        {\n          address: self.name,\n          arbiters: [],\n          hosts: [],\n          passives: [],\n          type: 'Unknown'\n        }\n      ]\n    };\n  }\n\n  return self.s.topologyDescription;\n};\n\nvar emitTopologyDescriptionChanged = function(self, description) {\n  if (self.listeners('topologyDescriptionChanged').length > 0) {\n    // Emit the server description changed events\n    self.emit('topologyDescriptionChanged', {\n      topologyId: self.s.topologyId !== -1 ? self.s.topologyId : self.id,\n      address: self.name,\n      previousDescription: getPreviousTopologyDescription(self),\n      newDescription: description\n    });\n\n    self.s.serverDescription = description;\n  }\n};\n\nvar changedIsMaster = function(self, currentIsmaster, ismaster) {\n  var currentType = getTopologyType(self, currentIsmaster);\n  var newType = getTopologyType(self, ismaster);\n  if (newType !== currentType) return true;\n  return false;\n};\n\nvar getTopologyType = function(self, ismaster) {\n  if (!ismaster) {\n    ismaster = self.ismaster;\n  }\n\n  if (!ismaster) return 'Unknown';\n  if (ismaster.ismaster && ismaster.msg === 'isdbgrid') return 'Mongos';\n  if (ismaster.ismaster && !ismaster.hosts) return 'Standalone';\n  if (ismaster.ismaster) return 'RSPrimary';\n  if (ismaster.secondary) return 'RSSecondary';\n  if (ismaster.arbiterOnly) return 'RSArbiter';\n  return 'Unknown';\n};\n\nvar inquireServerState = function(self) {\n  return function(callback) {\n    if (self.s.state === 'destroyed') return;\n    // Record response time\n    var start = new Date().getTime();\n\n    // emitSDAMEvent\n    emitSDAMEvent(self, 'serverHeartbeatStarted', { connectionId: self.name });\n\n    // Attempt to execute ismaster command\n    self.command('admin.$cmd', { ismaster: true }, { monitoring: true }, function(err, r) {\n      if (!err) {\n        // Legacy event sender\n        self.emit('ismaster', r, self);\n\n        // Calculate latencyMS\n        var latencyMS = new Date().getTime() - start;\n\n        // Server heart beat event\n        emitSDAMEvent(self, 'serverHeartbeatSucceeded', {\n          durationMS: latencyMS,\n          reply: r.result,\n          connectionId: self.name\n        });\n\n        // Did the server change\n        if (changedIsMaster(self, self.s.ismaster, r.result)) {\n          // Emit server description changed if something listening\n          emitServerDescriptionChanged(self, {\n            address: self.name,\n            arbiters: [],\n            hosts: [],\n            passives: [],\n            type: !self.s.inTopology ? 'Standalone' : getTopologyType(self)\n          });\n        }\n\n        // Updat ismaster view\n        self.s.ismaster = r.result;\n\n        // Set server response time\n        self.s.isMasterLatencyMS = latencyMS;\n      } else {\n        emitSDAMEvent(self, 'serverHeartbeatFailed', {\n          durationMS: latencyMS,\n          failure: err,\n          connectionId: self.name\n        });\n      }\n\n      // Peforming an ismaster monitoring callback operation\n      if (typeof callback === 'function') {\n        return callback(err, r);\n      }\n\n      // Perform another sweep\n      self.s.inquireServerStateTimeout = setTimeout(inquireServerState(self), self.s.haInterval);\n    });\n  };\n};\n\n//\n// Clone the options\nvar cloneOptions = function(options) {\n  var opts = {};\n  for (var name in options) {\n    opts[name] = options[name];\n  }\n  return opts;\n};\n\nfunction Interval(fn, time) {\n  var timer = false;\n\n  this.start = function() {\n    if (!this.isRunning()) {\n      timer = setInterval(fn, time);\n    }\n\n    return this;\n  };\n\n  this.stop = function() {\n    clearInterval(timer);\n    timer = false;\n    return this;\n  };\n\n  this.isRunning = function() {\n    return timer !== false;\n  };\n}\n\nfunction Timeout(fn, time) {\n  var timer = false;\n  var func = () => {\n    if (timer) {\n      clearTimeout(timer);\n      timer = false;\n\n      fn();\n    }\n  };\n\n  this.start = function() {\n    if (!this.isRunning()) {\n      timer = setTimeout(func, time);\n    }\n    return this;\n  };\n\n  this.stop = function() {\n    clearTimeout(timer);\n    timer = false;\n    return this;\n  };\n\n  this.isRunning = function() {\n    return timer !== false;\n  };\n}\n\nfunction diff(previous, current) {\n  // Difference document\n  var diff = {\n    servers: []\n  };\n\n  // Previous entry\n  if (!previous) {\n    previous = { servers: [] };\n  }\n\n  // Check if we have any previous servers missing in the current ones\n  for (var i = 0; i < previous.servers.length; i++) {\n    var found = false;\n\n    for (var j = 0; j < current.servers.length; j++) {\n      if (current.servers[j].address.toLowerCase() === previous.servers[i].address.toLowerCase()) {\n        found = true;\n        break;\n      }\n    }\n\n    if (!found) {\n      // Add to the diff\n      diff.servers.push({\n        address: previous.servers[i].address,\n        from: previous.servers[i].type,\n        to: 'Unknown'\n      });\n    }\n  }\n\n  // Check if there are any severs that don't exist\n  for (j = 0; j < current.servers.length; j++) {\n    found = false;\n\n    // Go over all the previous servers\n    for (i = 0; i < previous.servers.length; i++) {\n      if (previous.servers[i].address.toLowerCase() === current.servers[j].address.toLowerCase()) {\n        found = true;\n        break;\n      }\n    }\n\n    // Add the server to the diff\n    if (!found) {\n      diff.servers.push({\n        address: current.servers[j].address,\n        from: 'Unknown',\n        to: current.servers[j].type\n      });\n    }\n  }\n\n  // Got through all the servers\n  for (i = 0; i < previous.servers.length; i++) {\n    var prevServer = previous.servers[i];\n\n    // Go through all current servers\n    for (j = 0; j < current.servers.length; j++) {\n      var currServer = current.servers[j];\n\n      // Matching server\n      if (prevServer.address.toLowerCase() === currServer.address.toLowerCase()) {\n        // We had a change in state\n        if (prevServer.type !== currServer.type) {\n          diff.servers.push({\n            address: prevServer.address,\n            from: prevServer.type,\n            to: currServer.type\n          });\n        }\n      }\n    }\n  }\n\n  // Return difference\n  return diff;\n}\n\n/**\n * Shared function to determine clusterTime for a given topology\n *\n * @param {*} topology\n * @param {*} clusterTime\n */\nfunction resolveClusterTime(topology, $clusterTime) {\n  if (topology.clusterTime == null) {\n    topology.clusterTime = $clusterTime;\n  } else {\n    if ($clusterTime.clusterTime.greaterThan(topology.clusterTime.clusterTime)) {\n      topology.clusterTime = $clusterTime;\n    }\n  }\n}\n\n// NOTE: this is a temporary move until the topologies can be more formally refactored\n//       to share code.\nconst SessionMixins = {\n  endSessions: function(sessions, callback) {\n    if (!Array.isArray(sessions)) {\n      sessions = [sessions];\n    }\n\n    // TODO:\n    //   When connected to a sharded cluster the endSessions command\n    //   can be sent to any mongos. When connected to a replica set the\n    //   endSessions command MUST be sent to the primary if the primary\n    //   is available, otherwise it MUST be sent to any available secondary.\n    //   Is it enough to use: ReadPreference.primaryPreferred ?\n    this.command(\n      'admin.$cmd',\n      { endSessions: sessions },\n      { readPreference: ReadPreference.primaryPreferred },\n      () => {\n        // intentionally ignored, per spec\n        if (typeof callback === 'function') callback();\n      }\n    );\n  }\n};\n\nfunction topologyType(topology) {\n  if (topology.description) {\n    return topology.description.type;\n  }\n\n  if (topology.type === 'mongos') {\n    return TopologyType.Sharded;\n  } else if (topology.type === 'replset') {\n    return TopologyType.ReplicaSetWithPrimary;\n  }\n\n  return TopologyType.Single;\n}\n\nconst RETRYABLE_WIRE_VERSION = 6;\n\n/**\n * Determines whether the provided topology supports retryable writes\n *\n * @param {Mongos|Replset} topology\n */\nconst isRetryableWritesSupported = function(topology) {\n  const maxWireVersion = topology.lastIsMaster().maxWireVersion;\n  if (maxWireVersion < RETRYABLE_WIRE_VERSION) {\n    return false;\n  }\n\n  if (!topology.logicalSessionTimeoutMinutes) {\n    return false;\n  }\n\n  if (topologyType(topology) === TopologyType.Single) {\n    return false;\n  }\n\n  return true;\n};\n\nconst MMAPv1_RETRY_WRITES_ERROR_MESSAGE =\n  'This MongoDB deployment does not support retryable writes. Please add retryWrites=false to your connection string.';\n\nfunction getMMAPError(err) {\n  if (err.code !== MMAPv1_RETRY_WRITES_ERROR_CODE || !err.errmsg.includes('Transaction numbers')) {\n    return err;\n  }\n\n  // According to the retryable writes spec, we must replace the error message in this case.\n  // We need to replace err.message so the thrown message is correct and we need to replace err.errmsg to meet the spec requirement.\n  const newErr = new MongoError({\n    message: MMAPv1_RETRY_WRITES_ERROR_MESSAGE,\n    errmsg: MMAPv1_RETRY_WRITES_ERROR_MESSAGE,\n    originalError: err\n  });\n  return newErr;\n}\n\n// NOTE: only used for legacy topology types\nfunction legacyIsRetryableWriteError(err, topology) {\n  if (!(err instanceof MongoError)) {\n    return false;\n  }\n\n  // if pre-4.4 server, then add error label if its a retryable write error\n  if (\n    isRetryableWritesSupported(topology) &&\n    (err instanceof MongoNetworkError ||\n      (maxWireVersion(topology) < 9 && isRetryableWriteError(err)))\n  ) {\n    err.addErrorLabel('RetryableWriteError');\n  }\n\n  return err.hasErrorLabel('RetryableWriteError');\n}\n\nmodule.exports = {\n  SessionMixins,\n  resolveClusterTime,\n  inquireServerState,\n  getTopologyType,\n  emitServerDescriptionChanged,\n  emitTopologyDescriptionChanged,\n  cloneOptions,\n  createCompressionInfo,\n  clone,\n  diff,\n  Interval,\n  Timeout,\n  isRetryableWritesSupported,\n  getMMAPError,\n  topologyType,\n  legacyIsRetryableWriteError\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}