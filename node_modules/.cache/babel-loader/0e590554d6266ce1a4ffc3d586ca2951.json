{"ast":null,"code":"import e from \"axios\";\nimport t from \"js-cookie\";\nconst r = {\n  user: {},\n  tokens: {},\n  mode: \"live\"\n};\n\nfunction n(e) {\n  try {\n    const t = e.split(\".\")[1].replace(\"-\", \"+\").replace(\"_\", \"/\");\n    return JSON.parse(atob(t));\n  } catch (e) {\n    console.error(\"Problem decoding JWT payload\", e);\n  }\n}\n\nfunction o(e) {\n  var t, r;\n\n  if (e) {\n    if (\"string\" == typeof e) throw new Error(e);\n    if (null != e && null != (t = e.response) && null != (r = t.data) && r.message) throw new Error(e.response.data.message);\n    throw e;\n  }\n}\n\nconst i = r.user;\n\nfunction s(e, n, o) {\n  const i = `${o}.${r.tenantId}`;\n  n = n || {\n    secure: \"live\" === r.mode,\n    sameSite: \"Lax\"\n  }, \"refresh\" === o && (n.sameSite = \"Strict\"), t.set(i, e, n);\n}\n\nfunction a(e) {\n  let r, n;\n\n  try {\n    const e = window.location.pathname,\n          t = window.location.hostname,\n          o = t.split(\".\").slice(-2).join(\".\");\n    r = [void 0, e, \"/\"], n = [void 0, t, \".\" + t, o, \".\" + o];\n  } catch (e) {\n    r = [void 0, \"/\"], n = [void 0];\n  }\n\n  r.map(r => {\n    n.map(n => {\n      const o = {};\n      n && (o.domain = n), r && (o.path = r), t.remove(e, o);\n    });\n  });\n}\n\nfunction c() {\n  a(r.tokens.accessTokenName), a(r.tokens.idTokenName), a(r.tokens.refreshTokenName), r.tokens.accessToken = void 0, r.tokens.idToken = void 0, r.tokens.refreshToken = void 0, function () {\n    for (const e in r.user) \"function\" != typeof r.user[e] && delete r.user[e];\n  }();\n}\n\nfunction u(e) {\n  s(e.access.value, e.access.cookieOptions, \"access\"), s(e.id.value, e.id.cookieOptions, \"id\"), e.refresh && e.refresh.value && s(e.refresh.value, e.refresh.cookieOptions, \"refresh\"), h();\n}\n\nfunction d(e, t) {\n  try {\n    var r = e();\n  } catch (e) {\n    return t(e);\n  }\n\n  return r && r.then ? r.then(void 0, t) : r;\n}\n\nconst l = function (_ref) {\n  let {} = _ref;\n  return Promise.resolve();\n},\n      f = function () {\n  try {\n    const n = d(function () {\n      return Promise.resolve(function () {\n        try {\n          const n = t.get(r.tokens.refreshTokenName);\n          return Promise.resolve(d(function () {\n            return Promise.resolve(e.get(r.baseUrl + \"auth/refresh\", {\n              headers: {\n                authorization: \"Bearer \" + n\n              }\n            })).then(function (_ref2) {\n              let {\n                data: e,\n                status: t\n              } = _ref2;\n              if (200 !== t) throw new Error(e.message || \"Problem with request\");\n              if (e.tokens) return u(e.tokens), e;\n              throw new Error(\"Problem setting cookies\");\n            });\n          }, function (e) {\n            o(e);\n          }));\n        } catch (e) {\n          return Promise.reject(e);\n        }\n      }()).then(function () {});\n    }, function (e) {\n      console.warn(\"Refresh failed: \" + e.message);\n    });\n    return Promise.resolve(n && n.then ? n.then(function () {}) : void 0);\n  } catch (e) {\n    return Promise.reject(e);\n  }\n};\n\nfunction h() {\n  [\"access\", \"id\", \"refresh\"].map(e => {\n    try {\n      const o = t.get(r.tokens[e + \"TokenName\"]);\n      r.tokens[e + \"Token\"] = o, \"id\" === e && o && function () {\n        if (!r.tokens.idToken) return console.warn(\"Cannot define user: missing ID token\");\n        r.user = r.user || {};\n        const e = n(r.tokens.idToken),\n              t = [\"email\", \"username\", \"name\", \"image\", \"data\", \"confirmedAt\", \"createdAt\", \"updatedAt\", \"mode\", \"userId\", \"userUuid\", \"tenantId\", \"isConfirmed\"];\n\n        for (const n of t) {\n          if (\"update\" === n) return;\n          r.user[n] = e[n];\n        }\n      }();\n    } catch (t) {\n      console.warn(`Problem setting ${e} token.`);\n    }\n  });\n}\n\nr.tokens = r.tokens || {}, r.tokens.refresh = f;\nconst m = r.tokens;\n\nfunction p(e) {\n  if (\"object\" == typeof window && \"object\" == typeof window.location && window.location.href && !(window.location.href.indexOf(e + \"=\") < 0)) return decodeURIComponent(window.location.href.split(e + \"=\")[1].split(\"&\")[0]);\n}\n\nfunction w(e) {\n  if (!e || \"object\" != typeof document || \"object\" != typeof window) return;\n\n  try {\n    document && window;\n  } catch (e) {\n    return;\n  }\n\n  const t = document.createElement(\"a\");\n  t.href = e, t.pathname !== window.location.pathname && window.location.assign(`${t.pathname}${t.hash}${t.search}`);\n}\n\nfunction v(e, t) {\n  try {\n    var r = e();\n  } catch (e) {\n    return t(e);\n  }\n\n  return r && r.then ? r.then(void 0, t) : r;\n}\n\nfunction k(e, t) {\n  try {\n    var r = e();\n  } catch (e) {\n    return t(e);\n  }\n\n  return r && r.then ? r.then(void 0, t) : r;\n}\n\nconst P = function (_ref3) {\n  let {\n    email: t,\n    name: n,\n    username: i,\n    userData: s,\n    options: a\n  } = _ref3;\n\n  try {\n    return Promise.resolve(k(function () {\n      return Promise.resolve(e.post(r.baseUrl + \"auth/link\", {\n        email: t,\n        name: n,\n        username: i,\n        data: s,\n        options: a,\n        tenantId: r.tenantId\n      })).then(function (_ref4) {\n        let {\n          data: e\n        } = _ref4;\n        return e;\n      });\n    }, function (e) {\n      o(e);\n    }));\n  } catch (e) {\n    return Promise.reject(e);\n  }\n};\n\nfunction g(_ref5) {\n  let {\n    provider: e,\n    redirect: t\n  } = _ref5;\n  if (!e) throw new Error(\"Missing provider\");\n  if (!r.tenantId) throw new Error(\"Missing tenant ID\");\n  let n = `${r.baseUrl}auth/${e}/login?tenant_id=${r.tenantId}&origin=${window.location.origin}`,\n      o = t || p(\"redirect\");\n  return !1 === t && (o = \"object\" == typeof document && document.location.pathname), o && (n += \"&redirect=\" + encodeURIComponent(o)), n;\n}\n\nfunction y(e, t) {\n  try {\n    var r = e();\n  } catch (e) {\n    return t(e);\n  }\n\n  return r && r.then ? r.then(void 0, t) : r;\n}\n\nconst U = /((^127\\.)|(^10\\.)|(^172\\.1[6-9]\\.)|(^172\\.2[0-9]\\.)|(^172\\.3[0-1]\\.)|(^192\\.168\\.))\\d{1,3}\\.\\d{1,3}/g,\n      b = function () {\n  try {\n    const t = function (t, n) {\n      try {\n        var o = Promise.resolve(e.get(`${r.baseUrl}tenants/${r.tenantId}/mode`)).then(function (_ref6) {\n          let {\n            data: e\n          } = _ref6;\n          I.value = e.mode || \"test\", I.reason = E(I.value), r.mode = I.value;\n        });\n      } catch (e) {\n        return n();\n      }\n\n      return o && o.then ? o.then(void 0, n) : o;\n    }(0, function () {\n      I.value = \"test\", r.mode = I.value;\n    });\n\n    return Promise.resolve(t && t.then ? t.then(function () {}) : void 0);\n  } catch (e) {\n    return Promise.reject(e);\n  }\n},\n      I = {\n  value: \"live\",\n  reason: void 0,\n  setMode: b\n};\n\nfunction T() {\n  const e = function (e) {\n    try {\n      const e = window.location.hostname;\n      return !(!e.match(/localhost/g) && !e.match(U));\n    } catch (e) {\n      return !0;\n    }\n  }() || !function () {\n    try {\n      return \"https:\" === window.location.protocol;\n    } catch (e) {\n      return !1;\n    }\n  }() ? \"test\" : \"live\";\n  I.value = e, I.reason = E(e), r.mode = e;\n}\n\nfunction E(e) {\n  try {\n    return \"live\" === e ? \"domain\" : \"http:\" === window.location.protocol ? \"http\" : \"https:\" !== window.location.protocol ? \"protocol\" : \"domain\";\n  } catch (e) {}\n}\n\nT(), r.user.update = function (t) {\n  try {\n    return !t || Object.keys(t).length < 1 ? Promise.resolve(console.warn(\"Missing user properties to update\")) : Promise.resolve(e.put(r.baseUrl + \"self\", t, {\n      headers: {\n        authorization: \"Bearer \" + r.tokens.accessToken\n      }\n    })).then(function () {\n      return Promise.resolve(f()).then(function () {\n        return r.user;\n      });\n    });\n  } catch (e) {\n    return Promise.reject(e);\n  }\n}, r.user.hasRole = function (e) {\n  let {\n    tenantId: t\n  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  try {\n    if (!r.tokens.accessToken || !r.tenantId) return !1;\n    const {\n      authorization: o\n    } = n(r.tokens.accessToken);\n    return !!o && !(!o[t = t || r.tenantId] || !o[t].roles) && o[t].roles.indexOf(e) > -1;\n  } catch (e) {\n    return !1;\n  }\n};\nlet j = [],\n    C = !1;\nvar $ = {\n  addInitCallback: function (e) {\n    e && \"function\" == typeof e && j.push(e);\n  },\n  init: function (t) {\n    let n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    if (!t) return console.warn(\"Userfront initialized without tenant ID\");\n\n    if (r.tenantId = t, r.baseUrl = n.baseUrl || \"https://api.userfront.com/v0/\", r.baseUrl.endsWith(\"/\") || (r.baseUrl += \"/\"), n.domain) {\n      r.domain = n.domain;\n      const t = \"https://\" + r.domain;\n      e.defaults.headers.common[\"x-application-id\"] = t, e.defaults.headers.common[\"x-origin\"] = t;\n    }\n\n    r.tokens = r.tokens || {}, r.tokens.accessTokenName = \"access.\" + r.tenantId, r.tokens.idTokenName = \"id.\" + r.tenantId, r.tokens.refreshTokenName = \"refresh.\" + r.tenantId, h(), T();\n\n    try {\n      j.length > 0 && j.forEach(e => {\n        e && \"function\" == typeof e && e({\n          tenantId: t\n        });\n      }), j = [];\n    } catch (e) {}\n  },\n  registerUrlChangedEventListener: function () {\n    if (!C) {\n      C = !0;\n\n      try {\n        history.pushState = (e = history.pushState, function () {\n          var t = e.apply(this, arguments);\n          return window.dispatchEvent(new Event(\"pushstate\")), window.dispatchEvent(new Event(\"urlchanged\")), t;\n        }), history.replaceState = (e => function () {\n          var t = e.apply(this, arguments);\n          return window.dispatchEvent(new Event(\"replacestate\")), window.dispatchEvent(new Event(\"urlchanged\")), t;\n        })(history.replaceState), window.addEventListener(\"popstate\", () => {\n          window.dispatchEvent(new Event(\"urlchanged\"));\n        });\n      } catch (e) {}\n\n      var e;\n    }\n  },\n  logout: function () {\n    let {\n      method: t,\n      redirect: n\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    try {\n      return \"saml\" === t ? function () {\n        try {\n          if (!r.tokens.accessToken) throw new Error(\"Please log in to authorize your logout request.\");\n          const t = y(function () {\n            return Promise.resolve(e.get(r.baseUrl + \"auth/saml/idp/token\", {\n              headers: {\n                authorization: \"Bearer \" + r.tokens.accessToken\n              }\n            })).then(function (_ref7) {\n              let {\n                data: e\n              } = _ref7;\n              window.location.assign(`${r.baseUrl}auth/saml/idp/logout?tenant_id=${r.tenantId}&token=${e.token}&uuid=${r.user.userUuid}`);\n            });\n          }, function (e) {\n            o(e);\n          });\n          return Promise.resolve(t && t.then ? t.then(function () {}) : void 0);\n        } catch (e) {\n          return Promise.reject(e);\n        }\n      }() : Promise.resolve(r.tokens.accessToken ? y(function () {\n        return Promise.resolve(e.get(r.baseUrl + \"auth/logout\", {\n          headers: {\n            authorization: \"Bearer \" + r.tokens.accessToken\n          }\n        })).then(function (_ref8) {\n          let {\n            data: e\n          } = _ref8;\n          c(), !1 !== n && w(n || e.redirectTo);\n        });\n      }, function () {\n        c();\n      }) : c());\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  },\n  mode: I,\n  setMode: b,\n  refresh: (e, t, r) => {\n    try {\n      console.warn(\"Userfront.refresh() is deprecated and will be removed. Please use Userfront.tokens.refresh() instead.\");\n    } catch (e) {}\n\n    return f();\n  },\n  login: function () {\n    let {\n      method: t,\n      email: n,\n      username: i,\n      emailOrUsername: s,\n      password: a,\n      token: c,\n      uuid: d,\n      firstFactorCode: f,\n      verificationCode: h,\n      redirect: m\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    try {\n      if (!t) throw new Error('Userfront.login called without \"method\" property.');\n\n      switch (t) {\n        case \"apple\":\n        case \"azure\":\n        case \"facebook\":\n        case \"github\":\n        case \"google\":\n        case \"linkedin\":\n          return Promise.resolve(function (_ref9) {\n            let {\n              provider: e,\n              redirect: t\n            } = _ref9;\n            if (!e) throw new Error(\"Missing provider\");\n            const r = g({\n              provider: e,\n              redirect: t\n            });\n            window.location.assign(r);\n          }({\n            provider: t,\n            redirect: m\n          }));\n\n        case \"password\":\n          return function (_ref10) {\n            let {\n              email: t,\n              username: n,\n              emailOrUsername: i,\n              password: s,\n              redirect: a\n            } = _ref10;\n\n            try {\n              return Promise.resolve(k(function () {\n                return Promise.resolve(e.post(r.baseUrl + \"auth/basic\", {\n                  tenantId: r.tenantId,\n                  emailOrUsername: t || n || i,\n                  password: s\n                })).then(function (_ref11) {\n                  let {\n                    data: e\n                  } = _ref11;\n                  let t;\n\n                  function r(r) {\n                    if (t) return r;\n                    if (e.hasOwnProperty(\"firstFactorCode\")) return e;\n                    throw new Error(\"Please try again.\");\n                  }\n\n                  const n = function () {\n                    if (e.hasOwnProperty(\"tokens\")) return u(e.tokens), Promise.resolve(l(e)).then(function () {\n                      return !1 === a ? (t = 1, e) : (w(a || p(\"redirect\") || e.redirectTo || \"/\"), t = 1, e);\n                    });\n                  }();\n\n                  return n && n.then ? n.then(r) : r(n);\n                });\n              }, function (e) {\n                o(e);\n              }));\n            } catch (e) {\n              return Promise.reject(e);\n            }\n          }({\n            email: n,\n            username: i,\n            emailOrUsername: s,\n            password: a,\n            redirect: m\n          });\n\n        case \"passwordless\":\n          return P({\n            email: n\n          });\n\n        case \"link\":\n          return function () {\n            let {\n              token: t,\n              uuid: n,\n              redirect: i\n            } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n            try {\n              return Promise.resolve(k(function () {\n                if (t = t || p(\"token\"), n = n || p(\"uuid\"), t && n) return Promise.resolve(e.put(r.baseUrl + \"auth/link\", {\n                  token: t,\n                  uuid: n,\n                  tenantId: r.tenantId\n                })).then(function (_ref12) {\n                  let {\n                    data: e\n                  } = _ref12;\n                  let t;\n\n                  function r(r) {\n                    if (t) return r;\n                    if (e.hasOwnProperty(\"firstFactorCode\")) return e;\n                    throw new Error(\"Problem logging in.\");\n                  }\n\n                  const n = function () {\n                    if (e.hasOwnProperty(\"tokens\")) return u(e.tokens), Promise.resolve(l(e)).then(function () {\n                      return !1 === i ? (t = 1, e) : (w(i || p(\"redirect\") || e.redirectTo || \"/\"), t = 1, e);\n                    });\n                  }();\n\n                  return n && n.then ? n.then(r) : r(n);\n                });\n              }, function (e) {\n                o(e);\n              }));\n            } catch (e) {\n              return Promise.reject(e);\n            }\n          }({\n            token: c,\n            uuid: d,\n            redirect: m\n          });\n\n        case \"mfa\":\n          return Promise.resolve(function () {\n            let {\n              firstFactorCode: t,\n              verificationCode: n,\n              redirect: i\n            } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n            try {\n              if (!t || !n) throw new Error(\"Userfront.loginWithVerificationCode missing parameters.\");\n              return Promise.resolve(v(function () {\n                return Promise.resolve(e.put(r.baseUrl + \"auth/mfa\", {\n                  tenantId: r.tenantId,\n                  firstFactorCode: t,\n                  verificationCode: n\n                })).then(function (_ref13) {\n                  let {\n                    data: e\n                  } = _ref13;\n                  return u(e.tokens), Promise.resolve(l(e)).then(function () {\n                    return !1 === i || w(i || p(\"redirect\") || e.redirectTo || \"/\"), e;\n                  });\n                });\n              }, function (e) {\n                o(e);\n              }));\n            } catch (e) {\n              return Promise.reject(e);\n            }\n          }({\n            firstFactorCode: f,\n            verificationCode: h,\n            redirect: m\n          }));\n\n        case \"saml\":\n          return function () {\n            try {\n              return Promise.resolve(k(function () {\n                return r.tokens.accessToken ? Promise.resolve(e.get(r.baseUrl + \"auth/saml/idp/token\", {\n                  headers: {\n                    authorization: \"Bearer \" + r.tokens.accessToken\n                  }\n                })).then(function (_ref14) {\n                  let {\n                    data: e\n                  } = _ref14;\n                  window.location.assign(`${r.baseUrl}auth/saml/idp/login?tenant_id=${r.tenantId}&token=${e.token}&uuid=${r.user.userUuid}`);\n                }) : console.warn(\"Cannot complete SAML login without access token\");\n              }, function (e) {\n                o(e);\n              }));\n            } catch (e) {\n              return Promise.reject(e);\n            }\n          }();\n\n        default:\n          throw new Error('Userfront.login called with invalid \"method\" property.');\n      }\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  },\n  resetPassword: function (_ref15) {\n    let {\n      uuid: t,\n      token: n,\n      password: i,\n      redirect: s\n    } = _ref15;\n\n    try {\n      return Promise.resolve(k(function () {\n        if (n = n || p(\"token\"), t = t || p(\"uuid\"), !n || !t) throw new Error(\"Missing token or uuid\");\n        return Promise.resolve(e.put(r.baseUrl + \"auth/reset\", {\n          tenantId: r.tenantId,\n          uuid: t,\n          token: n,\n          password: i\n        })).then(function (_ref16) {\n          let {\n            data: e\n          } = _ref16;\n          if (e.tokens) return u(e.tokens), !1 === s || w(s || p(\"redirect\") || e.redirectTo || \"/\"), e;\n          throw new Error(\"There was a problem resetting your password. Please try again.\");\n        });\n      }, function (e) {\n        o(e);\n      }));\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  },\n  sendLoginLink: function (t) {\n    try {\n      return Promise.resolve(k(function () {\n        return Promise.resolve(e.post(r.baseUrl + \"auth/link\", {\n          email: t,\n          tenantId: r.tenantId\n        })).then(function (_ref17) {\n          let {\n            data: e\n          } = _ref17;\n          return e;\n        });\n      }, function (e) {\n        o(e);\n      }));\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  },\n  sendResetLink: function (t) {\n    try {\n      return Promise.resolve(k(function () {\n        return Promise.resolve(e.post(r.baseUrl + \"auth/reset/link\", {\n          email: t,\n          tenantId: r.tenantId\n        })).then(function (_ref18) {\n          let {\n            data: e\n          } = _ref18;\n          return e;\n        });\n      }, function (e) {\n        o(e);\n      }));\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  },\n  signup: function () {\n    let {\n      method: t,\n      username: n,\n      name: i,\n      email: s,\n      password: a,\n      data: c,\n      redirect: d\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    try {\n      if (!t) throw new Error('Userfront.signup called without \"method\" property.');\n\n      switch (t) {\n        case \"apple\":\n        case \"azure\":\n        case \"facebook\":\n        case \"github\":\n        case \"google\":\n        case \"linkedin\":\n          return Promise.resolve(function (_ref19) {\n            let {\n              provider: e,\n              redirect: t\n            } = _ref19;\n            if (!e) throw new Error(\"Missing provider\");\n            const r = g({\n              provider: e,\n              redirect: t\n            });\n            window.location.assign(r);\n          }({\n            provider: t,\n            redirect: d\n          }));\n\n        case \"password\":\n          return function () {\n            let {\n              username: t,\n              name: n,\n              email: i,\n              password: s,\n              userData: a,\n              redirect: c\n            } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n            try {\n              return Promise.resolve(k(function () {\n                return Promise.resolve(e.post(r.baseUrl + \"auth/create\", {\n                  tenantId: r.tenantId,\n                  username: t,\n                  name: n,\n                  email: i,\n                  password: s,\n                  data: a\n                })).then(function (_ref20) {\n                  let {\n                    data: e\n                  } = _ref20;\n                  if (e.tokens) return u(e.tokens), Promise.resolve(l(e)).then(function () {\n                    return !1 === c || w(c || p(\"redirect\") || e.redirectTo || \"/\"), e;\n                  });\n                  throw new Error(\"Please try again.\");\n                });\n              }, function (e) {\n                o(e);\n              }));\n            } catch (e) {\n              return Promise.reject(e);\n            }\n          }({\n            username: n,\n            name: i,\n            email: s,\n            password: a,\n            userData: c,\n            redirect: d\n          });\n\n        case \"passwordless\":\n          return P({\n            email: s,\n            name: i,\n            username: n,\n            userData: c\n          });\n\n        default:\n          throw new Error('Userfront.signup called with invalid \"method\" property.');\n      }\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  },\n  store: r,\n  tokens: m,\n  accessToken: function () {\n    return r.tokens.accessToken = t.get(r.tokens.accessTokenName), r.tokens.accessToken;\n  },\n  idToken: function () {\n    return r.tokens.idToken = t.get(r.tokens.idTokenName), r.tokens.idToken;\n  },\n  redirectIfLoggedIn: function () {\n    let {\n      redirect: t\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    try {\n      if (!r.tokens.accessToken) return Promise.resolve(c());\n      if (t) return Promise.resolve(w(t));\n      if (p(\"redirect\")) return Promise.resolve(w(p(\"redirect\")));\n\n      const n = function (t, n) {\n        try {\n          var o = Promise.resolve(e.get(r.baseUrl + \"self\", {\n            headers: {\n              authorization: \"Bearer \" + r.tokens.accessToken\n            }\n          })).then(function (_ref21) {\n            let {\n              data: e\n            } = _ref21;\n            e.tenant && e.tenant.loginRedirectPath && w(e.tenant.loginRedirectPath);\n          });\n        } catch (e) {\n          return n();\n        }\n\n        return o && o.then ? o.then(void 0, n) : o;\n      }(0, function () {\n        c();\n      });\n\n      return Promise.resolve(n && n.then ? n.then(function () {}) : void 0);\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  },\n  user: i,\n  sendSms: function () {\n    let {\n      type: t,\n      to: n,\n      firstFactorCode: i\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    try {\n      if (!t) throw new Error('Userfront.sendSms called without \"type\" property.');\n\n      switch (t) {\n        case \"verificationCode\":\n          if (!n || !i) throw new Error('Userfront.sendSms type \"verificationCode\" requires \"to\" and \"firstFactorCode\".');\n          return function () {\n            let {\n              firstFactorCode: t,\n              strategy: n,\n              channel: i,\n              to: s\n            } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n            try {\n              if (!(t && n && i && s)) throw new Error(\"Userfront.sendVerificationCode missing parameters.\");\n              return Promise.resolve(v(function () {\n                return Promise.resolve(e.post(r.baseUrl + \"auth/mfa\", {\n                  tenantId: r.tenantId,\n                  firstFactorCode: t,\n                  strategy: n,\n                  channel: i,\n                  to: s\n                })).then(function (_ref22) {\n                  let {\n                    data: e\n                  } = _ref22;\n                  return e;\n                });\n              }, function (e) {\n                o(e);\n              }));\n            } catch (e) {\n              return Promise.reject(e);\n            }\n          }({\n            firstFactorCode: i,\n            to: n,\n            strategy: \"verificationCode\",\n            channel: \"sms\"\n          });\n\n        default:\n          throw new Error('Userfront.sendSms called with invalid \"type\" property.');\n      }\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  }\n};\nexport default $;","map":{"version":3,"mappings":"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","names":["store","user","tokens","mode","getJWTPayload","token","encodedPayload","split","replace","JSON","parse","atob","error","console","throwFormattedError","Error","response","_error$response","data","_error$response$data","message","setCookie","value","options","type","cookieName","tenantId","secure","sameSite","Cookies","set","removeCookie","name","paths","domains","path","window","location","pathname","hostname","primaryDomain","slice","join","undefined","err","map","domain","remove","removeAllCookies","accessTokenName","idTokenName","refreshTokenName","accessToken","idToken","refreshToken","attr","unsetUser","setCookiesAndTokens","access","cookieOptions","id","refresh","setTokensFromCookies","body","recover","result","e","then","exchange","get","axios","baseUrl","headers","authorization","status","basicRefresh","warn","tokenName","idTokenPayload","propsToDefine","prop","setUser","getQueryAttr","attrName","href","indexOf","decodeURIComponent","redirectToPath","pathOrUrl","document","el","createElement","assign","hash","search","sendPasswordlessLink","email","username","userData","post","getProviderLink","redirect","provider","url","origin","redirectTo","encodeURIComponent","_catch","privateIPRegex","setMode","reason","getReason","setModeSync","modeValue","hn","match","isTestHostname","protocol","isHttps","update","payload","Object","keys","length","Promise","put","hasRole","roleName","roles","initCallbacks","isRegistered","addInitCallback","cb","push","init","opts","endsWith","defaults","common","forEach","registerUrlChangedEventListener","history","pushState","f","ret","apply","this","arguments","dispatchEvent","Event","replaceState","addEventListener","logout","method","userUuid","completeSamlLogout","a","b","c","login","emailOrUsername","password","uuid","firstFactorCode","verificationCode","loginWithSSO","hasOwnProperty","_exit2","loginWithPassword","_exit","loginWithLink","loginWithVerificationCode","completeSamlLogin","resetPassword","sendLoginLink","sendResetLink","signup","signupWithSSO","signupWithPassword","redirectIfLoggedIn","tenant","loginRedirectPath","sendSms","to","strategy","channel","sendVerificationCode"],"sources":["C:\\Users\\Administrator\\Desktop\\webAPI work\\web\\dog-website\\node_modules\\@userfront\\core\\src\\store.js","C:\\Users\\Administrator\\Desktop\\webAPI work\\web\\dog-website\\node_modules\\@userfront\\core\\src\\utils.js","C:\\Users\\Administrator\\Desktop\\webAPI work\\web\\dog-website\\node_modules\\@userfront\\core\\src\\user.js","C:\\Users\\Administrator\\Desktop\\webAPI work\\web\\dog-website\\node_modules\\@userfront\\core\\src\\cookies.js","C:\\Users\\Administrator\\Desktop\\webAPI work\\web\\dog-website\\node_modules\\@userfront\\core\\src\\tokens.js","C:\\Users\\Administrator\\Desktop\\webAPI work\\web\\dog-website\\node_modules\\@userfront\\core\\src\\refresh.js","C:\\Users\\Administrator\\Desktop\\webAPI work\\web\\dog-website\\node_modules\\@userfront\\core\\src\\url.js","C:\\Users\\Administrator\\Desktop\\webAPI work\\web\\dog-website\\node_modules\\@userfront\\core\\src\\mfa.js","C:\\Users\\Administrator\\Desktop\\webAPI work\\web\\dog-website\\node_modules\\@userfront\\core\\src\\signon.js","C:\\Users\\Administrator\\Desktop\\webAPI work\\web\\dog-website\\node_modules\\@userfront\\core\\src\\logout.js","C:\\Users\\Administrator\\Desktop\\webAPI work\\web\\dog-website\\node_modules\\@userfront\\core\\src\\constants.js","C:\\Users\\Administrator\\Desktop\\webAPI work\\web\\dog-website\\node_modules\\@userfront\\core\\src\\mode.js","C:\\Users\\Administrator\\Desktop\\webAPI work\\web\\dog-website\\node_modules\\@userfront\\core\\src\\user.methods.js","C:\\Users\\Administrator\\Desktop\\webAPI work\\web\\dog-website\\node_modules\\@userfront\\core\\src\\index.js"],"sourcesContent":["export const store = {\n  user: {},\n  tokens: {},\n  mode: \"live\",\n};\n","/**\n * This file is for zero-dependency utilities that can\n * be imported by any other file. Don't add any imports\n * to this file other than constants\n */\n\n/**\n * Get the unverified base64 decoded payload of a JWT\n *\n * @param {String} token - JSON Web Token\n * @returns {Object}\n */\nexport function getJWTPayload(token) {\n  try {\n    const encodedPayload = token\n      .split(\".\")[1]\n      .replace(\"-\", \"+\")\n      .replace(\"_\", \"/\");\n    return JSON.parse(atob(encodedPayload));\n  } catch (error) {\n    console.error(\"Problem decoding JWT payload\", error);\n  }\n}\n\nexport function throwFormattedError(error) {\n  if (!error) return;\n  if (typeof error === \"string\") throw new Error(error);\n  if (error?.response?.data?.message) {\n    throw new Error(error.response.data.message);\n  }\n  throw error;\n}\n","import { store } from \"./store.js\";\nimport { getJWTPayload } from \"./utils.js\";\n\n/**\n * Define the store.user object based on the ID token\n */\nexport function setUser() {\n  if (!store.tokens.idToken) {\n    return console.warn(\"Cannot define user: missing ID token\");\n  }\n\n  store.user = store.user || {};\n  const idTokenPayload = getJWTPayload(store.tokens.idToken);\n\n  // Set basic user information properties from ID token\n  const propsToDefine = [\n    \"email\",\n    \"username\",\n    \"name\",\n    \"image\",\n    \"data\",\n    \"confirmedAt\",\n    \"createdAt\",\n    \"updatedAt\",\n    \"mode\",\n    \"userId\",\n    \"userUuid\",\n    \"tenantId\",\n    \"isConfirmed\",\n  ];\n  for (const prop of propsToDefine) {\n    if (prop === \"update\") return;\n    store.user[prop] = idTokenPayload[prop];\n  }\n}\n\n/**\n * Remove all user information\n */\nexport function unsetUser() {\n  for (const attr in store.user) {\n    if (typeof store.user[attr] !== \"function\") {\n      delete store.user[attr];\n    }\n  }\n}\n\n/**\n * Export the store.user object with the update method added\n */\nexport const user = store.user;\n","import Cookies from \"js-cookie\";\nimport { store } from \"./store.js\";\nimport { setTokensFromCookies, unsetTokens } from \"./tokens.js\";\n\n/**\n * Set a cookie value based on the given options.\n * @param {String} value\n * @param {Object} options\n * @param {String} type\n */\nexport function setCookie(value, options, type) {\n  const cookieName = `${type}.${store.tenantId}`;\n  options = options || {\n    secure: store.mode === \"live\",\n    sameSite: \"Lax\",\n  };\n  if (type === \"refresh\") {\n    options.sameSite = \"Strict\";\n  }\n  Cookies.set(cookieName, value, options);\n}\n\n/**\n * Remove a cookie by name, regardless of its cookie setting(s).\n * @param {String} name\n */\nfunction removeCookie(name) {\n  // Define all possible path and domain combinations\n  let paths, domains;\n  try {\n    const path = window.location.pathname;\n    const hostname = window.location.hostname;\n    const hostnameParts = hostname.split(\".\");\n    const primaryDomain = hostnameParts.slice(-2).join(\".\");\n    paths = [undefined, path, \"/\"];\n    domains = [\n      undefined,\n      hostname,\n      `.${hostname}`,\n      primaryDomain,\n      `.${primaryDomain}`,\n    ];\n  } catch (err) {\n    paths = [undefined, \"/\"];\n    domains = [undefined];\n  }\n\n  // Iterate over paths and domains, and remove cookies if present\n  paths.map((path) => {\n    domains.map((domain) => {\n      const options = {};\n      if (domain) options.domain = domain;\n      if (path) options.path = path;\n      Cookies.remove(name, options);\n    });\n  });\n}\n\n/**\n * Remove all auth cookies (access, id, refresh).\n */\nexport function removeAllCookies() {\n  removeCookie(store.tokens.accessTokenName);\n  removeCookie(store.tokens.idTokenName);\n  removeCookie(store.tokens.refreshTokenName);\n  unsetTokens();\n}\n\n/**\n * Set the cookies from a tokens object, and add to the local store.\n * @param {Object} tokens\n */\nexport function setCookiesAndTokens(tokens) {\n  setCookie(tokens.access.value, tokens.access.cookieOptions, \"access\");\n  setCookie(tokens.id.value, tokens.id.cookieOptions, \"id\");\n  if (tokens.refresh && tokens.refresh.value) {\n    setCookie(tokens.refresh.value, tokens.refresh.cookieOptions, \"refresh\");\n  }\n  setTokensFromCookies();\n}\n","import Cookies from \"js-cookie\";\nimport { store } from \"./store.js\";\nimport { setUser, unsetUser } from \"./user.js\";\nimport { refresh } from \"./refresh.js\";\n\nstore.tokens = store.tokens || {};\nstore.tokens.refresh = refresh;\n\nexport function setTokenNames() {\n  store.tokens = store.tokens || {};\n  store.tokens.accessTokenName = `access.${store.tenantId}`;\n  store.tokens.idTokenName = `id.${store.tenantId}`;\n  store.tokens.refreshTokenName = `refresh.${store.tenantId}`;\n}\n\n/**\n * Set and then return the access token\n */\nexport function accessToken() {\n  store.tokens.accessToken = Cookies.get(store.tokens.accessTokenName);\n  return store.tokens.accessToken;\n}\n\n/**\n * Set and then return the ID token\n */\nexport function idToken() {\n  store.tokens.idToken = Cookies.get(store.tokens.idTokenName);\n  return store.tokens.idToken;\n}\n\n/**\n * Define the store token values from the cookie values.\n */\nexport function setTokensFromCookies() {\n  const tokenNames = [\"access\", \"id\", \"refresh\"];\n  tokenNames.map((tokenName) => {\n    try {\n      const token = Cookies.get(store.tokens[`${tokenName}TokenName`]);\n      store.tokens[`${tokenName}Token`] = token;\n\n      // Set the user object whenever the ID token is set\n      if (tokenName === \"id\" && token) {\n        setUser();\n      }\n    } catch (error) {\n      console.warn(`Problem setting ${tokenName} token.`);\n    }\n  });\n}\n\n/**\n * Set the store token values to undefined\n */\nexport function unsetTokens() {\n  store.tokens.accessToken = undefined;\n  store.tokens.idToken = undefined;\n  store.tokens.refreshToken = undefined;\n  unsetUser();\n}\n\n/**\n * Export the store.tokens object\n */\nexport const tokens = store.tokens;\n\n// NOTE Commenting this out 6/11/21 because the packages it relies on (jsonwebtoken & jwks-rsa)\n// both cause a lot of bloat. If we want to verify tokens, this is a nice way to do it, but\n// we need to find libraries designed for the browser instead of node.\n/**\n * Verify the provided token\n * @param {String} token\n * @returns {Promise<void>} The provided token has been verified if `verifyToken` resolves without error\n */\n// export async function verifyToken(token) {\n//   if (!token) throw new Error(\"Missing token\");\n\n//   let publicKey;\n//   try {\n//     const decodedToken = jwt.decode(token, { complete: true });\n//     if (!decodedToken.header || !decodedToken.header.kid) {\n//       throw new Error(\"Token kid not defined\");\n//     }\n\n//     const client = new JwksClient({\n//       jwksUri: `${apiUrl}tenants/${store.tenantId}/jwks/${store.mode}`,\n//       requestHeaders: { origin: window.location.origin },\n//     });\n\n//     const key = await client.getSigningKey(decodedToken.header.kid);\n//     publicKey = key.getPublicKey();\n//   } catch (error) {\n//     throw error;\n//   }\n\n//   if (!publicKey) {\n//     throw new Error(\"Public key not found\");\n//   }\n\n//   try {\n//     jwt.verify(token, publicKey);\n//   } catch (error) {\n//     throw new Error(\"Token verification failed\");\n//   }\n\n//   return Promise.resolve();\n// }\n","import Cookies from \"js-cookie\";\nimport axios from \"axios\";\nimport { setCookiesAndTokens } from \"./cookies.js\";\nimport { store } from \"./store.js\";\n// import { getIframe, postMessageAsPromise } from \"./iframe.js\";\nimport { throwFormattedError } from \"./utils.js\";\n\n/**\n * Refresh the access and ID tokens\n * - When in test mode, uses the basic refresh method\n * - For tenants without a custom SSL certificate, uses the basic refresh method\n * - For tenants with a custom SSL certificate and in live mode, uses the httpOnly refresh method\n * @returns {Promise}\n */\nexport async function refresh() {\n  try {\n    await basicRefresh();\n  } catch (error) {\n    console.warn(`Refresh failed: ${error.message}`);\n  }\n}\n\n/**\n * Use a regular (non-httpOnly) cookie to refresh the access and ID tokens.\n *\n * The basic refresh method is used automatically in test mode and in live\n * mode whenever an SSL certificate has not been set up.\n */\nasync function basicRefresh() {\n  const refreshToken = Cookies.get(store.tokens.refreshTokenName);\n  try {\n    const { data, status } = await axios.get(`${store.baseUrl}auth/refresh`, {\n      headers: {\n        authorization: `Bearer ${refreshToken}`,\n      },\n    });\n    if (status !== 200) {\n      throw new Error(data.message || \"Problem with request\");\n    }\n    if (data.tokens) {\n      setCookiesAndTokens(data.tokens);\n      return data;\n    } else {\n      throw new Error(\"Problem setting cookies\");\n    }\n  } catch (error) {\n    throwFormattedError(error);\n  }\n}\n\n// TODO re-enable httpOnly refresh method once new endpoints are stable [06/15/21]\n/**\n *\n * The httpOnly refresh method is only available for tenants with configured\n * SSL certificates while in live mode.\n */\n// async function httpOnlyRefresh() {\n//   const iframe = getIframe();\n//   if (!iframe) return;\n//   return postMessageAsPromise({\n//     type: \"refresh\",\n//     tenantId: store.tenantId,\n//   });\n// }\n\n/**\n * Use a sessionId and nonce to set the iframe refresh token\n * @param {String} sessionId\n * @param {String} nonce\n * @returns {Promise}\n */\nexport async function exchange({ sessionId, nonce }) {\n  return;\n\n  // TODO re-enable httpOnly exchange method once new endpoints are stable [06/15/21]\n  // --------------------------\n  // const iframe = getIframe();\n  // if (!iframe) return;\n  // return postMessageAsPromise({\n  //   type: \"exchange\",\n  //   tenantId: store.tenantId,\n  //   payload: {\n  //     sessionId,\n  //     nonce,\n  //   },\n  // });\n}\n","import axios from \"axios\";\n\nimport { store } from \"./store.js\";\nimport { removeAllCookies } from \"./cookies.js\";\n\n/**\n * Get the value of a query attribute, e.g. ?attr=value\n * @param {String} attrName\n */\nexport function getQueryAttr(attrName) {\n  if (\n    typeof window !== \"object\" ||\n    typeof window.location !== \"object\" ||\n    !window.location.href ||\n    window.location.href.indexOf(`${attrName}=`) < 0\n  ) {\n    return;\n  }\n  return decodeURIComponent(\n    window.location.href.split(`${attrName}=`)[1].split(\"&\")[0]\n  );\n}\n\n// TODO replace with direct check of the access token.\n/**\n * If the access token is valid, redirect the browser to the\n * tenant's login redirection path (path after login).\n */\nexport async function redirectIfLoggedIn({ redirect } = {}) {\n  if (!store.tokens.accessToken) {\n    return removeAllCookies();\n  }\n\n  // Redirect to a provided path (check options first, then url querystring)\n  if (redirect) {\n    return redirectToPath(redirect);\n  } else if (getQueryAttr(\"redirect\")) {\n    return redirectToPath(getQueryAttr(\"redirect\"));\n  }\n\n  // If no path was provided, look up the path and then redirect there\n  try {\n    const { data } = await axios.get(`${store.baseUrl}self`, {\n      headers: {\n        authorization: `Bearer ${store.tokens.accessToken}`,\n      },\n    });\n    if (data.tenant && data.tenant.loginRedirectPath) {\n      redirectToPath(data.tenant.loginRedirectPath);\n    }\n  } catch (err) {\n    removeAllCookies();\n  }\n}\n\n/**\n * Redirect to path portion of a URL.\n */\nexport function redirectToPath(pathOrUrl) {\n  // Return if no pathOrUrl, or if SSR or mobile\n  if (\n    !pathOrUrl ||\n    typeof document !== \"object\" ||\n    typeof window !== \"object\"\n  ) {\n    return;\n  }\n  try {\n    document && window;\n  } catch (error) {\n    return;\n  }\n\n  // Perform hard redirect\n  const el = document.createElement(\"a\");\n  el.href = pathOrUrl;\n  let path = `${el.pathname}${el.hash}${el.search}`;\n  if (el.pathname !== window.location.pathname) {\n    window.location.assign(path);\n  }\n}\n","import axios from \"axios\";\nimport { setCookiesAndTokens } from \"./cookies.js\";\nimport { store } from \"./store.js\";\nimport { getQueryAttr, redirectToPath } from \"./url.js\";\nimport { exchange } from \"./refresh.js\";\nimport { throwFormattedError } from \"./utils.js\";\n\n/**\n * Send an SMS to a phone number\n * @param {String} type Type of SMS to send\n * @param {String} to Phone number in E.164 format\n * @param {String} firstFactorCode Identifier obtained from login() response\n * @returns {Object}\n */\nexport async function sendSms({ type, to, firstFactorCode } = {}) {\n  if (!type) {\n    throw new Error('Userfront.sendSms called without \"type\" property.');\n  }\n\n  switch (type) {\n    case \"verificationCode\":\n      if (!to || !firstFactorCode) {\n        throw new Error(\n          'Userfront.sendSms type \"verificationCode\" requires \"to\" and \"firstFactorCode\".'\n        );\n      }\n\n      return sendVerificationCode({\n        firstFactorCode,\n        to,\n        strategy: \"verificationCode\",\n        channel: \"sms\",\n      });\n    default:\n      throw new Error('Userfront.sendSms called with invalid \"type\" property.');\n  }\n}\n\n/**\n * Send an MFA verification code\n * @param {String} firstFactorCode Identifier obtained from login() response\n * @param {String} strategy Type of MFA strategy\n * @param {String} channel Method of sending the verification code\n * @param {String} to Phone number in E.164 format\n * @returns {Object}\n */\nexport async function sendVerificationCode({\n  firstFactorCode,\n  strategy,\n  channel,\n  to,\n} = {}) {\n  if (!firstFactorCode || !strategy || !channel || !to) {\n    throw new Error(\"Userfront.sendVerificationCode missing parameters.\");\n  }\n\n  try {\n    const { data } = await axios.post(`${store.baseUrl}auth/mfa`, {\n      tenantId: store.tenantId,\n      firstFactorCode,\n      strategy,\n      channel,\n      to,\n    });\n\n    return data;\n  } catch (error) {\n    throwFormattedError(error);\n  }\n}\n\n/**\n * Log in using firstFactorCode and MFA verification code\n * @param {String} firstFactorCode Identifier obtained from login() response\n * @param {String} verificationCode Code provided by the user\n * @param {String|Boolean} redirect Redirect to given path unless specified as `false`\n * @returns {Object}\n */\nexport async function loginWithVerificationCode({\n  firstFactorCode,\n  verificationCode,\n  redirect,\n} = {}) {\n  if (!firstFactorCode || !verificationCode) {\n    throw new Error(\"Userfront.loginWithVerificationCode missing parameters.\");\n  }\n\n  try {\n    const { data } = await axios.put(`${store.baseUrl}auth/mfa`, {\n      tenantId: store.tenantId,\n      firstFactorCode,\n      verificationCode,\n    });\n\n    setCookiesAndTokens(data.tokens);\n    await exchange(data);\n    if (redirect === false) {\n      return data;\n    }\n\n    redirectToPath(\n      redirect || getQueryAttr(\"redirect\") || data.redirectTo || \"/\"\n    );\n    return data;\n  } catch (error) {\n    throwFormattedError(error);\n  }\n}\n","import axios from \"axios\";\nimport { setCookiesAndTokens } from \"./cookies.js\";\nimport { store } from \"./store.js\";\nimport { getQueryAttr, redirectToPath } from \"./url.js\";\nimport { exchange } from \"./refresh.js\";\nimport { throwFormattedError } from \"./utils.js\";\nimport { loginWithVerificationCode } from \"./mfa.js\";\n\n/**\n * This file has methods for signing up and logging in\n */\n\n/**\n * Register a user via the provided method. This method serves to call other\n * methods, depending on the \"method\" parameter passed in.\n * @param {String} method\n * @param {String} username\n * @param {String} name\n * @param {String} email\n * @param {String} password\n * @param {Object} data - Object for custom user fields\n * @param {String} redirect - path to redirect to, or if false, do not redirect\n */\nexport async function signup({\n  method,\n  username,\n  name,\n  email,\n  password,\n  data,\n  redirect,\n} = {}) {\n  if (!method) {\n    throw new Error('Userfront.signup called without \"method\" property.');\n  }\n  switch (method) {\n    case \"apple\":\n    case \"azure\":\n    case \"facebook\":\n    case \"github\":\n    case \"google\":\n    case \"linkedin\":\n      return signupWithSSO({ provider: method, redirect });\n    case \"password\":\n      return signupWithPassword({\n        username,\n        name,\n        email,\n        password,\n        userData: data,\n        redirect,\n      });\n    case \"passwordless\":\n      return sendPasswordlessLink({ email, name, username, userData: data });\n    default:\n      throw new Error(\n        'Userfront.signup called with invalid \"method\" property.'\n      );\n  }\n}\n\n/**\n * Register a new user in via SSO provider.\n * Redirect the browser after successful authentication and 302 redirect from server.\n * @param {String} provider Name of SSO provider\n */\nfunction signupWithSSO({ provider, redirect }) {\n  if (!provider) throw new Error(\"Missing provider\");\n  const url = getProviderLink({ provider, redirect });\n  window.location.assign(url);\n}\n\n/**\n * Register a new user with username, name, email, and password.\n * Redirect the browser after successful signup based on the redirectTo value returned.\n * @param {String} username\n * @param {String} name\n * @param {String} email\n * @param {String} password\n * @param {Object} userData - alias for the user.data object, since \"data\" is used in the response\n * @param {String} redirect - do not redirect if false, or redirect to a specific path\n */\nasync function signupWithPassword({\n  username,\n  name,\n  email,\n  password,\n  userData,\n  redirect,\n} = {}) {\n  try {\n    const { data } = await axios.post(`${store.baseUrl}auth/create`, {\n      tenantId: store.tenantId,\n      username,\n      name,\n      email,\n      password,\n      data: userData,\n    });\n    if (data.tokens) {\n      setCookiesAndTokens(data.tokens);\n      await exchange(data);\n      if (redirect === false) return data;\n      redirectToPath(\n        redirect || getQueryAttr(\"redirect\") || data.redirectTo || \"/\"\n      );\n      return data;\n    } else {\n      throw new Error(\"Please try again.\");\n    }\n  } catch (error) {\n    throwFormattedError(error);\n  }\n}\n\n/**\n * Log a user in via the provided method. This method serves to call other\n * methods, depending on the \"method\" parameter passed in.\n * @param {String} method\n * @param {String} email\n * @param {String} username\n * @param {String} emailOrUsername\n * @param {String} password\n * @param {String} token\n * @param {String} uuid\n * @param {String} redirect - do not redirect if false, or redirect to given path\n */\nexport async function login({\n  method,\n  email,\n  username,\n  emailOrUsername,\n  password,\n  token,\n  uuid,\n  firstFactorCode,\n  verificationCode,\n  redirect,\n} = {}) {\n  if (!method) {\n    throw new Error('Userfront.login called without \"method\" property.');\n  }\n  switch (method) {\n    case \"apple\":\n    case \"azure\":\n    case \"facebook\":\n    case \"github\":\n    case \"google\":\n    case \"linkedin\":\n      return loginWithSSO({ provider: method, redirect });\n    case \"password\":\n      return loginWithPassword({\n        email,\n        username,\n        emailOrUsername,\n        password,\n        redirect,\n      });\n    case \"passwordless\":\n      return sendPasswordlessLink({ email });\n    case \"link\":\n      return loginWithLink({ token, uuid, redirect });\n    case \"mfa\":\n      return loginWithVerificationCode({\n        firstFactorCode,\n        verificationCode,\n        redirect,\n      });\n    case \"saml\":\n      return completeSamlLogin();\n    default:\n      throw new Error('Userfront.login called with invalid \"method\" property.');\n  }\n}\n\n/**\n * Log a user in via SSO provider.\n * Redirect the browser after successful authentication and 302 redirect from server.\n * @param {String} provider Name of SSO provider\n * @param {String} redirect - do not redirect if false, or redirect to given path\n */\nfunction loginWithSSO({ provider, redirect }) {\n  if (!provider) throw new Error(\"Missing provider\");\n  const url = getProviderLink({ provider, redirect });\n  window.location.assign(url);\n}\n\nexport function getProviderLink({ provider, redirect }) {\n  if (!provider) throw new Error(\"Missing provider\");\n  if (!store.tenantId) throw new Error(\"Missing tenant ID\");\n\n  let url = `${store.baseUrl}auth/${provider}/login?tenant_id=${store.tenantId}&origin=${window.location.origin}`;\n\n  let redirectTo = redirect || getQueryAttr(\"redirect\");\n  if (redirect === false) {\n    redirectTo = typeof document === \"object\" && document.location.pathname;\n  }\n  if (redirectTo) {\n    url += `&redirect=${encodeURIComponent(redirectTo)}`;\n  }\n\n  return url;\n}\n\n/**\n * Log a user in with email/username and password.\n * Redirect the browser after successful login based on the redirectTo value returned.\n * @param {Object} options\n */\nasync function loginWithPassword({\n  email,\n  username,\n  emailOrUsername,\n  password,\n  redirect,\n}) {\n  try {\n    const { data } = await axios.post(`${store.baseUrl}auth/basic`, {\n      tenantId: store.tenantId,\n      emailOrUsername: email || username || emailOrUsername,\n      password,\n    });\n\n    if (data.hasOwnProperty(\"tokens\")) {\n      setCookiesAndTokens(data.tokens);\n      await exchange(data);\n      if (redirect === false) return data;\n      redirectToPath(\n        redirect || getQueryAttr(\"redirect\") || data.redirectTo || \"/\"\n      );\n      return data;\n    }\n\n    if (data.hasOwnProperty(\"firstFactorCode\")) {\n      return data;\n    }\n\n    throw new Error(\"Please try again.\");\n  } catch (error) {\n    throwFormattedError(error);\n  }\n}\n\nasync function completeSamlLogin() {\n  try {\n    if (!store.tokens.accessToken) {\n      return console.warn(\"Cannot complete SAML login without access token\");\n    }\n\n    const { data } = await axios.get(`${store.baseUrl}auth/saml/idp/token`, {\n      headers: {\n        authorization: `Bearer ${store.tokens.accessToken}`,\n      },\n    });\n\n    window.location.assign(\n      `${store.baseUrl}auth/saml/idp/login?tenant_id=${store.tenantId}&token=${data.token}&uuid=${store.user.userUuid}`\n    );\n  } catch (error) {\n    throwFormattedError(error);\n  }\n}\n\n/**\n * Log a user in with a token/uuid combo passed into the function or\n * in the URL querystring. ?token=...&uuid=...\n * @param {String} token\n * @param {UUID} uuid\n * @param {String} redirect - do not redirect if false, or redirect to given path\n */\nexport async function loginWithLink({ token, uuid, redirect } = {}) {\n  try {\n    token = token || getQueryAttr(\"token\");\n    uuid = uuid || getQueryAttr(\"uuid\");\n    if (!token || !uuid) return;\n\n    const { data } = await axios.put(`${store.baseUrl}auth/link`, {\n      token,\n      uuid,\n      tenantId: store.tenantId,\n    });\n\n    if (data.hasOwnProperty(\"tokens\")) {\n      setCookiesAndTokens(data.tokens);\n      await exchange(data);\n      if (redirect === false) return data;\n      redirectToPath(\n        redirect || getQueryAttr(\"redirect\") || data.redirectTo || \"/\"\n      );\n      return data;\n    }\n\n    if (data.hasOwnProperty(\"firstFactorCode\")) {\n      return data;\n    }\n\n    throw new Error(\"Problem logging in.\");\n  } catch (error) {\n    throwFormattedError(error);\n  }\n}\n\n/**\n * Send a login link to the provided email.\n * @param {String} email\n */\nexport async function sendLoginLink(email) {\n  try {\n    const { data } = await axios.post(`${store.baseUrl}auth/link`, {\n      email,\n      tenantId: store.tenantId,\n    });\n    return data;\n  } catch (error) {\n    throwFormattedError(error);\n  }\n}\n\n/**\n * Create or update a user and send them a link to log in.\n * @param {Object} inputs\n */\nexport async function sendPasswordlessLink({\n  email,\n  name,\n  username,\n  userData,\n  options,\n}) {\n  try {\n    const { data } = await axios.post(`${store.baseUrl}auth/link`, {\n      email,\n      name,\n      username,\n      data: userData,\n      options,\n      tenantId: store.tenantId,\n    });\n    return data;\n  } catch (error) {\n    throwFormattedError(error);\n  }\n}\n\n/**\n * Send a password reset link to the provided email.\n * @param {String} email\n */\nexport async function sendResetLink(email) {\n  try {\n    const { data } = await axios.post(`${store.baseUrl}auth/reset/link`, {\n      email,\n      tenantId: store.tenantId,\n    });\n    return data;\n  } catch (error) {\n    throwFormattedError(error);\n  }\n}\n\nexport async function resetPassword({ uuid, token, password, redirect }) {\n  try {\n    token = token || getQueryAttr(\"token\");\n    uuid = uuid || getQueryAttr(\"uuid\");\n    if (!token || !uuid) throw new Error(\"Missing token or uuid\");\n    const { data } = await axios.put(`${store.baseUrl}auth/reset`, {\n      tenantId: store.tenantId,\n      uuid,\n      token,\n      password,\n    });\n    if (data.tokens) {\n      setCookiesAndTokens(data.tokens);\n\n      // Return if redirect is explicitly false\n      if (redirect === false) return data;\n\n      redirectToPath(\n        redirect || getQueryAttr(\"redirect\") || data.redirectTo || \"/\"\n      );\n\n      return data;\n    } else {\n      throw new Error(\n        \"There was a problem resetting your password. Please try again.\"\n      );\n    }\n  } catch (error) {\n    throwFormattedError(error);\n  }\n}\n","import axios from \"axios\";\n\nimport { getIframe, postMessageAsPromise } from \"./iframe.js\";\nimport { store } from \"./store.js\";\nimport { removeAllCookies } from \"./cookies.js\";\nimport { setTokensFromCookies } from \"./tokens.js\";\nimport { redirectToPath } from \"./url\";\nimport { throwFormattedError } from \"./utils.js\";\n\n/**\n * Log a user out and redirect to the logout path.\n */\nexport async function logout({ method, redirect } = {}) {\n  if (method === \"saml\") {\n    return completeSamlLogout();\n  }\n  if (!store.tokens.accessToken) {\n    return removeAllCookies();\n  }\n\n  try {\n    const { data } = await axios.get(`${store.baseUrl}auth/logout`, {\n      headers: {\n        authorization: `Bearer ${store.tokens.accessToken}`,\n      },\n    });\n    removeAllCookies();\n    if (redirect === false) return;\n    redirectToPath(redirect || data.redirectTo);\n  } catch (err) {\n    removeAllCookies();\n  }\n}\n\nasync function completeSamlLogout() {\n  if (!store.tokens.accessToken) {\n    throw new Error(\"Please log in to authorize your logout request.\");\n  }\n\n  try {\n    const { data } = await axios.get(`${store.baseUrl}auth/saml/idp/token`, {\n      headers: {\n        authorization: `Bearer ${store.tokens.accessToken}`,\n      },\n    });\n\n    window.location.assign(\n      `${store.baseUrl}auth/saml/idp/logout?tenant_id=${store.tenantId}&token=${data.token}&uuid=${store.user.userUuid}`\n    );\n  } catch (error) {\n    throwFormattedError(error);\n  }\n}\n\n// TODO re-enable exchange method once new endpoints are stable [06/15/21]\n// --------------------------\n// const iframe = getIframe();\n// if (!iframe) return;\n// try {\n//   const { data } = await postMessageAsPromise({\n//     type: \"logout\",\n//     tenantId: store.tenantId,\n//   });\n//   removeAllCookies();\n//   setTokensFromCookies();\n//   redirectToPath(data.redirectTo || \"/\");\n// } catch (error) {\n//   removeAllCookies();\n//   redirectToPath(\"/\");\n// }\n","export const apiUrl = `https://api.userfront.com/v0/`;\n\nexport const privateIPRegex =\n  /((^127\\.)|(^10\\.)|(^172\\.1[6-9]\\.)|(^172\\.2[0-9]\\.)|(^172\\.3[0-1]\\.)|(^192\\.168\\.))\\d{1,3}\\.\\d{1,3}/g;\n","import axios from \"axios\";\nimport { privateIPRegex } from \"./constants.js\";\nimport { store } from \"./store.js\";\n\n/**\n * Global mode object\n */\nexport const mode = {\n  value: \"live\",\n  reason: undefined,\n  setMode,\n};\n\nsetModeSync();\n\n/**\n * Determine whether a hostname is in test mode.\n * @param {String} hn\n */\nexport function isTestHostname(hn) {\n  try {\n    const hostname = hn || window.location.hostname;\n    return !!(hostname.match(/localhost/g) || hostname.match(privateIPRegex));\n  } catch (err) {\n    return true;\n  }\n}\n\nexport function isHttps() {\n  try {\n    return window.location.protocol === \"https:\";\n  } catch (error) {\n    return false;\n  }\n}\n\n/**\n * Define the mode of operation (live or test)\n */\nexport async function setMode() {\n  try {\n    const { data } = await axios.get(\n      `${store.baseUrl}tenants/${store.tenantId}/mode`\n    );\n    mode.value = data.mode || \"test\";\n    mode.reason = getReason(mode.value);\n    store.mode = mode.value;\n  } catch (err) {\n    mode.value = \"test\";\n    store.mode = mode.value;\n  }\n}\n\n/**\n * Estimate the mode without making an API call\n */\nexport function setModeSync() {\n  const modeValue = isTestHostname() || !isHttps() ? \"test\" : \"live\";\n  mode.value = modeValue;\n  mode.reason = getReason(modeValue);\n  store.mode = modeValue;\n}\n\n/**\n * Set the reason for the mode\n * - http\n * - domain\n */\nfunction getReason(mode) {\n  try {\n    if (mode === \"live\") {\n      return \"domain\";\n    }\n    if (window.location.protocol === \"http:\") {\n      return \"http\";\n    } else if (window.location.protocol !== \"https:\") {\n      return \"protocol\";\n    } else {\n      return \"domain\";\n    }\n  } catch (error) {}\n}\n","/**\n * user methods are refactored into a separate file to avoid a circular dependency\n * between Userfront.refresh() [which requires setUser()]\n * and Userfront.user.update() [which requires refresh()].\n */\n\nimport axios from \"axios\";\nimport { refresh } from \"./refresh.js\";\nimport { store } from \"./store.js\";\nimport { getJWTPayload } from \"./utils.js\";\n\n/**\n * Update the user record on Userfront\n * @param {Object} payload User properties to update e.g. { name: 'John Doe' }\n */\nexport async function update(payload) {\n  if (!payload || Object.keys(payload).length < 1) {\n    return console.warn(\"Missing user properties to update\");\n  }\n\n  // Make request to update the user\n  await axios.put(`${store.baseUrl}self`, payload, {\n    headers: {\n      authorization: `Bearer ${store.tokens.accessToken}`,\n    },\n  });\n\n  // Refresh the access and ID tokens, and set the store.user object from the ID token\n  await refresh();\n\n  return store.user;\n}\n\n/**\n * Determine whether the access token has a given role\n * @param {String} roleName\n * @param {Object} options\n * @returns {Boolean}\n */\nexport function hasRole(roleName, { tenantId } = {}) {\n  try {\n    if (!store.tokens.accessToken || !store.tenantId) {\n      return false;\n    }\n    const { authorization } = getJWTPayload(store.tokens.accessToken);\n    if (!authorization) {\n      return false;\n    }\n    tenantId = tenantId || store.tenantId;\n    if (!authorization[tenantId] || !authorization[tenantId].roles) {\n      return false;\n    }\n    return authorization[tenantId].roles.indexOf(roleName) > -1;\n  } catch (error) {\n    return false;\n  }\n}\n\n/**\n * Add the methods to the store.user object\n */\nstore.user.update = update;\nstore.user.hasRole = hasRole;\n","import axios from \"axios\";\nimport { store } from \"./store.js\";\nimport {\n  tokens,\n  accessToken,\n  idToken,\n  setTokensFromCookies,\n  setTokenNames,\n} from \"./tokens\";\nimport { redirectIfLoggedIn } from \"./url.js\";\nimport { sendSms } from \"./mfa.js\";\nimport {\n  login,\n  resetPassword,\n  sendLoginLink,\n  sendResetLink,\n  signup,\n} from \"./signon.js\";\nimport { logout } from \"./logout.js\";\nimport { mode, setMode, setModeSync } from \"./mode.js\";\n// import { setIframe } from \"./iframe.js\";\nimport { user } from \"./user.js\";\nimport \"./user.methods.js\";\nimport { refresh } from \"./refresh.js\";\nimport { apiUrl } from \"./constants.js\";\n\nlet initCallbacks = [];\n\n/**\n * Initialize the Userfront library.\n * @param {String} tenantId\n */\nfunction init(tenantId, opts = {}) {\n  if (!tenantId) return console.warn(\"Userfront initialized without tenant ID\");\n\n  store.tenantId = tenantId;\n\n  store.baseUrl = opts.baseUrl || apiUrl;\n  if (!store.baseUrl.endsWith(\"/\")) {\n    store.baseUrl += \"/\";\n  }\n\n  if (opts.domain) {\n    store.domain = opts.domain;\n    const url = `https://${store.domain}`;\n    axios.defaults.headers.common[\n      \"x-application-id\"\n    ] = url\n    axios.defaults.headers.common[\n      \"x-origin\"\n    ] = url\n  }\n\n  setTokenNames();\n  // setIframe(); // TODO re-enable when iframe is needed\n  setTokensFromCookies();\n  setModeSync();\n\n  try {\n    if (initCallbacks.length > 0) {\n      initCallbacks.forEach((cb) => {\n        if (!cb || typeof cb !== \"function\") return;\n        cb({ tenantId });\n      });\n    }\n    initCallbacks = [];\n  } catch (error) {}\n}\n\n/**\n * Add a callback function to be called upon Userfront.init()\n * @param {Function} cb\n */\nfunction addInitCallback(cb) {\n  if (!cb || typeof cb !== \"function\") return;\n  initCallbacks.push(cb);\n}\n\n/**\n\n * Register a window-level event called \"urlchanged\" that will fire\n * whenever the browser URL changes.\n */\nlet isRegistered = false;\nfunction registerUrlChangedEventListener() {\n  if (isRegistered) return;\n  isRegistered = true;\n  try {\n    history.pushState = ((f) =>\n      function pushState() {\n        var ret = f.apply(this, arguments);\n        window.dispatchEvent(new Event(\"pushstate\"));\n        window.dispatchEvent(new Event(\"urlchanged\"));\n        return ret;\n      })(history.pushState);\n\n    history.replaceState = ((f) =>\n      function replaceState() {\n        var ret = f.apply(this, arguments);\n        window.dispatchEvent(new Event(\"replacestate\"));\n        window.dispatchEvent(new Event(\"urlchanged\"));\n        return ret;\n      })(history.replaceState);\n\n    window.addEventListener(\"popstate\", () => {\n      window.dispatchEvent(new Event(\"urlchanged\"));\n    });\n  } catch (error) {}\n}\n\n/**\n * EXPORTS\n */\n\nexport default {\n  // index\n  addInitCallback,\n  init,\n  registerUrlChangedEventListener,\n\n  //logout\n  logout,\n\n  // mode\n  mode,\n  setMode,\n\n  // refresh\n  refresh: (a, b, c) => {\n    try {\n      console.warn(\n        \"Userfront.refresh() is deprecated and will be removed. Please use Userfront.tokens.refresh() instead.\"\n      );\n    } catch (error) {}\n    return refresh(a, b, c);\n  },\n\n  // signon\n  login,\n  resetPassword,\n  sendLoginLink,\n  sendResetLink,\n  signup,\n\n  // store\n  store,\n\n  // tokens\n  tokens,\n  accessToken,\n  idToken,\n\n  // url\n  redirectIfLoggedIn,\n\n  // user\n  user,\n\n  // mfa\n  sendSms,\n\n  // utils\n};\n"]},"metadata":{},"sourceType":"module"}