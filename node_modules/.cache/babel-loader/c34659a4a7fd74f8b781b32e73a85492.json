{"ast":null,"code":"'use strict';\n\nconst buildCountCommand = require('./collection_ops').buildCountCommand;\n\nconst handleCallback = require('../utils').handleCallback;\n\nconst MongoError = require('../core').MongoError;\n\nconst push = Array.prototype.push;\n\nconst CursorState = require('../core/cursor').CursorState;\n/**\n * Get the count of documents for this cursor.\n *\n * @method\n * @param {Cursor} cursor The Cursor instance on which to count.\n * @param {boolean} [applySkipLimit=true] Specifies whether the count command apply limit and skip settings should be applied on the cursor or in the provided options.\n * @param {object} [options] Optional settings. See Cursor.prototype.count for a list of options.\n * @param {Cursor~countResultCallback} [callback] The result callback.\n */\n\n\nfunction count(cursor, applySkipLimit, opts, callback) {\n  if (applySkipLimit) {\n    if (typeof cursor.cursorSkip() === 'number') opts.skip = cursor.cursorSkip();\n    if (typeof cursor.cursorLimit() === 'number') opts.limit = cursor.cursorLimit();\n  } // Ensure we have the right read preference inheritance\n\n\n  if (opts.readPreference) {\n    cursor.setReadPreference(opts.readPreference);\n  }\n\n  if (typeof opts.maxTimeMS !== 'number' && cursor.cmd && typeof cursor.cmd.maxTimeMS === 'number') {\n    opts.maxTimeMS = cursor.cmd.maxTimeMS;\n  }\n\n  let options = {};\n  options.skip = opts.skip;\n  options.limit = opts.limit;\n  options.hint = opts.hint;\n  options.maxTimeMS = opts.maxTimeMS; // Command\n\n  options.collectionName = cursor.namespace.collection;\n  let command;\n\n  try {\n    command = buildCountCommand(cursor, cursor.cmd.query, options);\n  } catch (err) {\n    return callback(err);\n  } // Set cursor server to the same as the topology\n\n\n  cursor.server = cursor.topology.s.coreTopology; // Execute the command\n\n  cursor.topology.command(cursor.namespace.withCollection('$cmd'), command, cursor.options, (err, result) => {\n    callback(err, result ? result.result.n : null);\n  });\n}\n/**\n * Iterates over all the documents for this cursor. See Cursor.prototype.each for more information.\n *\n * @method\n * @deprecated\n * @param {Cursor} cursor The Cursor instance on which to run.\n * @param {Cursor~resultCallback} callback The result callback.\n */\n\n\nfunction each(cursor, callback) {\n  if (!callback) throw MongoError.create({\n    message: 'callback is mandatory',\n    driver: true\n  });\n  if (cursor.isNotified()) return;\n\n  if (cursor.s.state === CursorState.CLOSED || cursor.isDead()) {\n    return handleCallback(callback, MongoError.create({\n      message: 'Cursor is closed',\n      driver: true\n    }));\n  }\n\n  if (cursor.s.state === CursorState.INIT) {\n    cursor.s.state = CursorState.OPEN;\n  } // Define function to avoid global scope escape\n\n\n  let fn = null; // Trampoline all the entries\n\n  if (cursor.bufferedCount() > 0) {\n    while (fn = loop(cursor, callback)) fn(cursor, callback);\n\n    each(cursor, callback);\n  } else {\n    cursor.next((err, item) => {\n      if (err) return handleCallback(callback, err);\n\n      if (item == null) {\n        return cursor.close({\n          skipKillCursors: true\n        }, () => handleCallback(callback, null, null));\n      }\n\n      if (handleCallback(callback, null, item) === false) return;\n      each(cursor, callback);\n    });\n  }\n} // Trampoline emptying the number of retrieved items\n// without incurring a nextTick operation\n\n\nfunction loop(cursor, callback) {\n  // No more items we are done\n  if (cursor.bufferedCount() === 0) return; // Get the next document\n\n  cursor._next(callback); // Loop\n\n\n  return loop;\n}\n/**\n * Returns an array of documents. See Cursor.prototype.toArray for more information.\n *\n * @method\n * @param {Cursor} cursor The Cursor instance from which to get the next document.\n * @param {Cursor~toArrayResultCallback} [callback] The result callback.\n */\n\n\nfunction toArray(cursor, callback) {\n  const items = []; // Reset cursor\n\n  cursor.rewind();\n  cursor.s.state = CursorState.INIT; // Fetch all the documents\n\n  const fetchDocs = () => {\n    cursor._next((err, doc) => {\n      if (err) {\n        return handleCallback(callback, err);\n      }\n\n      if (doc == null) {\n        return cursor.close({\n          skipKillCursors: true\n        }, () => handleCallback(callback, null, items));\n      } // Add doc to items\n\n\n      items.push(doc); // Get all buffered objects\n\n      if (cursor.bufferedCount() > 0) {\n        let docs = cursor.readBufferedDocuments(cursor.bufferedCount()); // Transform the doc if transform method added\n\n        if (cursor.s.transforms && typeof cursor.s.transforms.doc === 'function') {\n          docs = docs.map(cursor.s.transforms.doc);\n        }\n\n        push.apply(items, docs);\n      } // Attempt a fetch\n\n\n      fetchDocs();\n    });\n  };\n\n  fetchDocs();\n}\n\nmodule.exports = {\n  count,\n  each,\n  toArray\n};","map":{"version":3,"names":["buildCountCommand","require","handleCallback","MongoError","push","Array","prototype","CursorState","count","cursor","applySkipLimit","opts","callback","cursorSkip","skip","cursorLimit","limit","readPreference","setReadPreference","maxTimeMS","cmd","options","hint","collectionName","namespace","collection","command","query","err","server","topology","s","coreTopology","withCollection","result","n","each","create","message","driver","isNotified","state","CLOSED","isDead","INIT","OPEN","fn","bufferedCount","loop","next","item","close","skipKillCursors","_next","toArray","items","rewind","fetchDocs","doc","docs","readBufferedDocuments","transforms","map","apply","module","exports"],"sources":["C:/Users/Administrator/Desktop/webAPI work/web/dog-website/node_modules/koa-mongo/node_modules/mongodb/lib/operations/cursor_ops.js"],"sourcesContent":["'use strict';\n\nconst buildCountCommand = require('./collection_ops').buildCountCommand;\nconst handleCallback = require('../utils').handleCallback;\nconst MongoError = require('../core').MongoError;\nconst push = Array.prototype.push;\nconst CursorState = require('../core/cursor').CursorState;\n\n/**\n * Get the count of documents for this cursor.\n *\n * @method\n * @param {Cursor} cursor The Cursor instance on which to count.\n * @param {boolean} [applySkipLimit=true] Specifies whether the count command apply limit and skip settings should be applied on the cursor or in the provided options.\n * @param {object} [options] Optional settings. See Cursor.prototype.count for a list of options.\n * @param {Cursor~countResultCallback} [callback] The result callback.\n */\nfunction count(cursor, applySkipLimit, opts, callback) {\n  if (applySkipLimit) {\n    if (typeof cursor.cursorSkip() === 'number') opts.skip = cursor.cursorSkip();\n    if (typeof cursor.cursorLimit() === 'number') opts.limit = cursor.cursorLimit();\n  }\n\n  // Ensure we have the right read preference inheritance\n  if (opts.readPreference) {\n    cursor.setReadPreference(opts.readPreference);\n  }\n\n  if (\n    typeof opts.maxTimeMS !== 'number' &&\n    cursor.cmd &&\n    typeof cursor.cmd.maxTimeMS === 'number'\n  ) {\n    opts.maxTimeMS = cursor.cmd.maxTimeMS;\n  }\n\n  let options = {};\n  options.skip = opts.skip;\n  options.limit = opts.limit;\n  options.hint = opts.hint;\n  options.maxTimeMS = opts.maxTimeMS;\n\n  // Command\n  options.collectionName = cursor.namespace.collection;\n\n  let command;\n  try {\n    command = buildCountCommand(cursor, cursor.cmd.query, options);\n  } catch (err) {\n    return callback(err);\n  }\n\n  // Set cursor server to the same as the topology\n  cursor.server = cursor.topology.s.coreTopology;\n\n  // Execute the command\n  cursor.topology.command(\n    cursor.namespace.withCollection('$cmd'),\n    command,\n    cursor.options,\n    (err, result) => {\n      callback(err, result ? result.result.n : null);\n    }\n  );\n}\n\n/**\n * Iterates over all the documents for this cursor. See Cursor.prototype.each for more information.\n *\n * @method\n * @deprecated\n * @param {Cursor} cursor The Cursor instance on which to run.\n * @param {Cursor~resultCallback} callback The result callback.\n */\nfunction each(cursor, callback) {\n  if (!callback) throw MongoError.create({ message: 'callback is mandatory', driver: true });\n  if (cursor.isNotified()) return;\n  if (cursor.s.state === CursorState.CLOSED || cursor.isDead()) {\n    return handleCallback(\n      callback,\n      MongoError.create({ message: 'Cursor is closed', driver: true })\n    );\n  }\n\n  if (cursor.s.state === CursorState.INIT) {\n    cursor.s.state = CursorState.OPEN;\n  }\n\n  // Define function to avoid global scope escape\n  let fn = null;\n  // Trampoline all the entries\n  if (cursor.bufferedCount() > 0) {\n    while ((fn = loop(cursor, callback))) fn(cursor, callback);\n    each(cursor, callback);\n  } else {\n    cursor.next((err, item) => {\n      if (err) return handleCallback(callback, err);\n      if (item == null) {\n        return cursor.close({ skipKillCursors: true }, () => handleCallback(callback, null, null));\n      }\n\n      if (handleCallback(callback, null, item) === false) return;\n      each(cursor, callback);\n    });\n  }\n}\n\n// Trampoline emptying the number of retrieved items\n// without incurring a nextTick operation\nfunction loop(cursor, callback) {\n  // No more items we are done\n  if (cursor.bufferedCount() === 0) return;\n  // Get the next document\n  cursor._next(callback);\n  // Loop\n  return loop;\n}\n\n/**\n * Returns an array of documents. See Cursor.prototype.toArray for more information.\n *\n * @method\n * @param {Cursor} cursor The Cursor instance from which to get the next document.\n * @param {Cursor~toArrayResultCallback} [callback] The result callback.\n */\nfunction toArray(cursor, callback) {\n  const items = [];\n\n  // Reset cursor\n  cursor.rewind();\n  cursor.s.state = CursorState.INIT;\n\n  // Fetch all the documents\n  const fetchDocs = () => {\n    cursor._next((err, doc) => {\n      if (err) {\n        return handleCallback(callback, err);\n      }\n\n      if (doc == null) {\n        return cursor.close({ skipKillCursors: true }, () => handleCallback(callback, null, items));\n      }\n\n      // Add doc to items\n      items.push(doc);\n\n      // Get all buffered objects\n      if (cursor.bufferedCount() > 0) {\n        let docs = cursor.readBufferedDocuments(cursor.bufferedCount());\n\n        // Transform the doc if transform method added\n        if (cursor.s.transforms && typeof cursor.s.transforms.doc === 'function') {\n          docs = docs.map(cursor.s.transforms.doc);\n        }\n\n        push.apply(items, docs);\n      }\n\n      // Attempt a fetch\n      fetchDocs();\n    });\n  };\n\n  fetchDocs();\n}\n\nmodule.exports = { count, each, toArray };\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}