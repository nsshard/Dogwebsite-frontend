{"ast":null,"code":"'use strict';\n\nvar Emitter = require('events').EventEmitter;\n\nvar GridFSBucketReadStream = require('./download');\n\nvar GridFSBucketWriteStream = require('./upload');\n\nvar shallowClone = require('../utils').shallowClone;\n\nvar toError = require('../utils').toError;\n\nvar util = require('util');\n\nvar executeLegacyOperation = require('../utils').executeLegacyOperation;\n\nvar DEFAULT_GRIDFS_BUCKET_OPTIONS = {\n  bucketName: 'fs',\n  chunkSizeBytes: 255 * 1024\n};\nmodule.exports = GridFSBucket;\n/**\n * Constructor for a streaming GridFS interface\n * @class\n * @extends external:EventEmitter\n * @param {Db} db A db handle\n * @param {object} [options] Optional settings.\n * @param {string} [options.bucketName=\"fs\"] The 'files' and 'chunks' collections will be prefixed with the bucket name followed by a dot.\n * @param {number} [options.chunkSizeBytes=255 * 1024] Number of bytes stored in each chunk. Defaults to 255KB\n * @param {object} [options.writeConcern] Optional write concern to be passed to write operations, for instance `{ w: 1 }`\n * @param {object} [options.readPreference] Optional read preference to be passed to read operations\n * @fires GridFSBucketWriteStream#index\n */\n\nfunction GridFSBucket(db, options) {\n  Emitter.apply(this);\n  this.setMaxListeners(0);\n\n  if (options && typeof options === 'object') {\n    options = shallowClone(options);\n    var keys = Object.keys(DEFAULT_GRIDFS_BUCKET_OPTIONS);\n\n    for (var i = 0; i < keys.length; ++i) {\n      if (!options[keys[i]]) {\n        options[keys[i]] = DEFAULT_GRIDFS_BUCKET_OPTIONS[keys[i]];\n      }\n    }\n  } else {\n    options = DEFAULT_GRIDFS_BUCKET_OPTIONS;\n  }\n\n  this.s = {\n    db: db,\n    options: options,\n    _chunksCollection: db.collection(options.bucketName + '.chunks'),\n    _filesCollection: db.collection(options.bucketName + '.files'),\n    checkedIndexes: false,\n    calledOpenUploadStream: false,\n    promiseLibrary: db.s.promiseLibrary || Promise\n  };\n}\n\nutil.inherits(GridFSBucket, Emitter);\n/**\n * When the first call to openUploadStream is made, the upload stream will\n * check to see if it needs to create the proper indexes on the chunks and\n * files collections. This event is fired either when 1) it determines that\n * no index creation is necessary, 2) when it successfully creates the\n * necessary indexes.\n *\n * @event GridFSBucket#index\n * @type {Error}\n */\n\n/**\n * Returns a writable stream (GridFSBucketWriteStream) for writing\n * buffers to GridFS. The stream's 'id' property contains the resulting\n * file's id.\n * @method\n * @param {string} filename The value of the 'filename' key in the files doc\n * @param {object} [options] Optional settings.\n * @param {number} [options.chunkSizeBytes] Optional overwrite this bucket's chunkSizeBytes for this file\n * @param {object} [options.metadata] Optional object to store in the file document's `metadata` field\n * @param {string} [options.contentType] Optional string to store in the file document's `contentType` field\n * @param {array} [options.aliases] Optional array of strings to store in the file document's `aliases` field\n * @param {boolean} [options.disableMD5=false] If true, disables adding an md5 field to file data\n * @return {GridFSBucketWriteStream}\n */\n\nGridFSBucket.prototype.openUploadStream = function (filename, options) {\n  if (options) {\n    options = shallowClone(options);\n  } else {\n    options = {};\n  }\n\n  if (!options.chunkSizeBytes) {\n    options.chunkSizeBytes = this.s.options.chunkSizeBytes;\n  }\n\n  return new GridFSBucketWriteStream(this, filename, options);\n};\n/**\n * Returns a writable stream (GridFSBucketWriteStream) for writing\n * buffers to GridFS for a custom file id. The stream's 'id' property contains the resulting\n * file's id.\n * @method\n * @param {string|number|object} id A custom id used to identify the file\n * @param {string} filename The value of the 'filename' key in the files doc\n * @param {object} [options] Optional settings.\n * @param {number} [options.chunkSizeBytes] Optional overwrite this bucket's chunkSizeBytes for this file\n * @param {object} [options.metadata] Optional object to store in the file document's `metadata` field\n * @param {string} [options.contentType] Optional string to store in the file document's `contentType` field\n * @param {array} [options.aliases] Optional array of strings to store in the file document's `aliases` field\n * @param {boolean} [options.disableMD5=false] If true, disables adding an md5 field to file data\n * @return {GridFSBucketWriteStream}\n */\n\n\nGridFSBucket.prototype.openUploadStreamWithId = function (id, filename, options) {\n  if (options) {\n    options = shallowClone(options);\n  } else {\n    options = {};\n  }\n\n  if (!options.chunkSizeBytes) {\n    options.chunkSizeBytes = this.s.options.chunkSizeBytes;\n  }\n\n  options.id = id;\n  return new GridFSBucketWriteStream(this, filename, options);\n};\n/**\n * Returns a readable stream (GridFSBucketReadStream) for streaming file\n * data from GridFS.\n * @method\n * @param {ObjectId} id The id of the file doc\n * @param {Object} [options] Optional settings.\n * @param {Number} [options.start] Optional 0-based offset in bytes to start streaming from\n * @param {Number} [options.end] Optional 0-based offset in bytes to stop streaming before\n * @return {GridFSBucketReadStream}\n */\n\n\nGridFSBucket.prototype.openDownloadStream = function (id, options) {\n  var filter = {\n    _id: id\n  };\n  options = {\n    start: options && options.start,\n    end: options && options.end\n  };\n  return new GridFSBucketReadStream(this.s._chunksCollection, this.s._filesCollection, this.s.options.readPreference, filter, options);\n};\n/**\n * Deletes a file with the given id\n * @method\n * @param {ObjectId} id The id of the file doc\n * @param {GridFSBucket~errorCallback} [callback]\n */\n\n\nGridFSBucket.prototype.delete = function (id, callback) {\n  return executeLegacyOperation(this.s.db.s.topology, _delete, [this, id, callback], {\n    skipSessions: true\n  });\n};\n/**\n * @ignore\n */\n\n\nfunction _delete(_this, id, callback) {\n  _this.s._filesCollection.deleteOne({\n    _id: id\n  }, function (error, res) {\n    if (error) {\n      return callback(error);\n    }\n\n    _this.s._chunksCollection.deleteMany({\n      files_id: id\n    }, function (error) {\n      if (error) {\n        return callback(error);\n      } // Delete orphaned chunks before returning FileNotFound\n\n\n      if (!res.result.n) {\n        var errmsg = 'FileNotFound: no file with id ' + id + ' found';\n        return callback(new Error(errmsg));\n      }\n\n      callback();\n    });\n  });\n}\n/**\n * Convenience wrapper around find on the files collection\n * @method\n * @param {Object} filter\n * @param {Object} [options] Optional settings for cursor\n * @param {number} [options.batchSize=1000] The number of documents to return per batch. See {@link https://docs.mongodb.com/manual/reference/command/find|find command documentation}.\n * @param {number} [options.limit] Optional limit for cursor\n * @param {number} [options.maxTimeMS] Optional maxTimeMS for cursor\n * @param {boolean} [options.noCursorTimeout] Optionally set cursor's `noCursorTimeout` flag\n * @param {number} [options.skip] Optional skip for cursor\n * @param {object} [options.sort] Optional sort for cursor\n * @return {Cursor}\n */\n\n\nGridFSBucket.prototype.find = function (filter, options) {\n  filter = filter || {};\n  options = options || {};\n\n  var cursor = this.s._filesCollection.find(filter);\n\n  if (options.batchSize != null) {\n    cursor.batchSize(options.batchSize);\n  }\n\n  if (options.limit != null) {\n    cursor.limit(options.limit);\n  }\n\n  if (options.maxTimeMS != null) {\n    cursor.maxTimeMS(options.maxTimeMS);\n  }\n\n  if (options.noCursorTimeout != null) {\n    cursor.addCursorFlag('noCursorTimeout', options.noCursorTimeout);\n  }\n\n  if (options.skip != null) {\n    cursor.skip(options.skip);\n  }\n\n  if (options.sort != null) {\n    cursor.sort(options.sort);\n  }\n\n  return cursor;\n};\n/**\n * Returns a readable stream (GridFSBucketReadStream) for streaming the\n * file with the given name from GridFS. If there are multiple files with\n * the same name, this will stream the most recent file with the given name\n * (as determined by the `uploadDate` field). You can set the `revision`\n * option to change this behavior.\n * @method\n * @param {String} filename The name of the file to stream\n * @param {Object} [options] Optional settings\n * @param {number} [options.revision=-1] The revision number relative to the oldest file with the given filename. 0 gets you the oldest file, 1 gets you the 2nd oldest, -1 gets you the newest.\n * @param {Number} [options.start] Optional 0-based offset in bytes to start streaming from\n * @param {Number} [options.end] Optional 0-based offset in bytes to stop streaming before\n * @return {GridFSBucketReadStream}\n */\n\n\nGridFSBucket.prototype.openDownloadStreamByName = function (filename, options) {\n  var sort = {\n    uploadDate: -1\n  };\n  var skip = null;\n\n  if (options && options.revision != null) {\n    if (options.revision >= 0) {\n      sort = {\n        uploadDate: 1\n      };\n      skip = options.revision;\n    } else {\n      skip = -options.revision - 1;\n    }\n  }\n\n  var filter = {\n    filename: filename\n  };\n  options = {\n    sort: sort,\n    skip: skip,\n    start: options && options.start,\n    end: options && options.end\n  };\n  return new GridFSBucketReadStream(this.s._chunksCollection, this.s._filesCollection, this.s.options.readPreference, filter, options);\n};\n/**\n * Renames the file with the given _id to the given string\n * @method\n * @param {ObjectId} id the id of the file to rename\n * @param {String} filename new name for the file\n * @param {GridFSBucket~errorCallback} [callback]\n */\n\n\nGridFSBucket.prototype.rename = function (id, filename, callback) {\n  return executeLegacyOperation(this.s.db.s.topology, _rename, [this, id, filename, callback], {\n    skipSessions: true\n  });\n};\n/**\n * @ignore\n */\n\n\nfunction _rename(_this, id, filename, callback) {\n  var filter = {\n    _id: id\n  };\n  var update = {\n    $set: {\n      filename: filename\n    }\n  };\n\n  _this.s._filesCollection.updateOne(filter, update, function (error, res) {\n    if (error) {\n      return callback(error);\n    }\n\n    if (!res.result.n) {\n      return callback(toError('File with id ' + id + ' not found'));\n    }\n\n    callback();\n  });\n}\n/**\n * Removes this bucket's files collection, followed by its chunks collection.\n * @method\n * @param {GridFSBucket~errorCallback} [callback]\n */\n\n\nGridFSBucket.prototype.drop = function (callback) {\n  return executeLegacyOperation(this.s.db.s.topology, _drop, [this, callback], {\n    skipSessions: true\n  });\n};\n/**\n * Return the db logger\n * @method\n * @return {Logger} return the db logger\n * @ignore\n */\n\n\nGridFSBucket.prototype.getLogger = function () {\n  return this.s.db.s.logger;\n};\n/**\n * @ignore\n */\n\n\nfunction _drop(_this, callback) {\n  _this.s._filesCollection.drop(function (error) {\n    if (error) {\n      return callback(error);\n    }\n\n    _this.s._chunksCollection.drop(function (error) {\n      if (error) {\n        return callback(error);\n      }\n\n      return callback();\n    });\n  });\n}\n/**\n * Callback format for all GridFSBucket methods that can accept a callback.\n * @callback GridFSBucket~errorCallback\n * @param {MongoError|undefined} error If present, an error instance representing any errors that occurred\n * @param {*} result If present, a returned result for the method\n */","map":{"version":3,"names":["Emitter","require","EventEmitter","GridFSBucketReadStream","GridFSBucketWriteStream","shallowClone","toError","util","executeLegacyOperation","DEFAULT_GRIDFS_BUCKET_OPTIONS","bucketName","chunkSizeBytes","module","exports","GridFSBucket","db","options","apply","setMaxListeners","keys","Object","i","length","s","_chunksCollection","collection","_filesCollection","checkedIndexes","calledOpenUploadStream","promiseLibrary","Promise","inherits","prototype","openUploadStream","filename","openUploadStreamWithId","id","openDownloadStream","filter","_id","start","end","readPreference","delete","callback","topology","_delete","skipSessions","_this","deleteOne","error","res","deleteMany","files_id","result","n","errmsg","Error","find","cursor","batchSize","limit","maxTimeMS","noCursorTimeout","addCursorFlag","skip","sort","openDownloadStreamByName","uploadDate","revision","rename","_rename","update","$set","updateOne","drop","_drop","getLogger","logger"],"sources":["C:/Users/Administrator/Desktop/webAPI work/web/dog-website/node_modules/koa-mongo/node_modules/mongodb/lib/gridfs-stream/index.js"],"sourcesContent":["'use strict';\n\nvar Emitter = require('events').EventEmitter;\nvar GridFSBucketReadStream = require('./download');\nvar GridFSBucketWriteStream = require('./upload');\nvar shallowClone = require('../utils').shallowClone;\nvar toError = require('../utils').toError;\nvar util = require('util');\nvar executeLegacyOperation = require('../utils').executeLegacyOperation;\n\nvar DEFAULT_GRIDFS_BUCKET_OPTIONS = {\n  bucketName: 'fs',\n  chunkSizeBytes: 255 * 1024\n};\n\nmodule.exports = GridFSBucket;\n\n/**\n * Constructor for a streaming GridFS interface\n * @class\n * @extends external:EventEmitter\n * @param {Db} db A db handle\n * @param {object} [options] Optional settings.\n * @param {string} [options.bucketName=\"fs\"] The 'files' and 'chunks' collections will be prefixed with the bucket name followed by a dot.\n * @param {number} [options.chunkSizeBytes=255 * 1024] Number of bytes stored in each chunk. Defaults to 255KB\n * @param {object} [options.writeConcern] Optional write concern to be passed to write operations, for instance `{ w: 1 }`\n * @param {object} [options.readPreference] Optional read preference to be passed to read operations\n * @fires GridFSBucketWriteStream#index\n */\n\nfunction GridFSBucket(db, options) {\n  Emitter.apply(this);\n  this.setMaxListeners(0);\n\n  if (options && typeof options === 'object') {\n    options = shallowClone(options);\n    var keys = Object.keys(DEFAULT_GRIDFS_BUCKET_OPTIONS);\n    for (var i = 0; i < keys.length; ++i) {\n      if (!options[keys[i]]) {\n        options[keys[i]] = DEFAULT_GRIDFS_BUCKET_OPTIONS[keys[i]];\n      }\n    }\n  } else {\n    options = DEFAULT_GRIDFS_BUCKET_OPTIONS;\n  }\n\n  this.s = {\n    db: db,\n    options: options,\n    _chunksCollection: db.collection(options.bucketName + '.chunks'),\n    _filesCollection: db.collection(options.bucketName + '.files'),\n    checkedIndexes: false,\n    calledOpenUploadStream: false,\n    promiseLibrary: db.s.promiseLibrary || Promise\n  };\n}\n\nutil.inherits(GridFSBucket, Emitter);\n\n/**\n * When the first call to openUploadStream is made, the upload stream will\n * check to see if it needs to create the proper indexes on the chunks and\n * files collections. This event is fired either when 1) it determines that\n * no index creation is necessary, 2) when it successfully creates the\n * necessary indexes.\n *\n * @event GridFSBucket#index\n * @type {Error}\n */\n\n/**\n * Returns a writable stream (GridFSBucketWriteStream) for writing\n * buffers to GridFS. The stream's 'id' property contains the resulting\n * file's id.\n * @method\n * @param {string} filename The value of the 'filename' key in the files doc\n * @param {object} [options] Optional settings.\n * @param {number} [options.chunkSizeBytes] Optional overwrite this bucket's chunkSizeBytes for this file\n * @param {object} [options.metadata] Optional object to store in the file document's `metadata` field\n * @param {string} [options.contentType] Optional string to store in the file document's `contentType` field\n * @param {array} [options.aliases] Optional array of strings to store in the file document's `aliases` field\n * @param {boolean} [options.disableMD5=false] If true, disables adding an md5 field to file data\n * @return {GridFSBucketWriteStream}\n */\n\nGridFSBucket.prototype.openUploadStream = function(filename, options) {\n  if (options) {\n    options = shallowClone(options);\n  } else {\n    options = {};\n  }\n  if (!options.chunkSizeBytes) {\n    options.chunkSizeBytes = this.s.options.chunkSizeBytes;\n  }\n  return new GridFSBucketWriteStream(this, filename, options);\n};\n\n/**\n * Returns a writable stream (GridFSBucketWriteStream) for writing\n * buffers to GridFS for a custom file id. The stream's 'id' property contains the resulting\n * file's id.\n * @method\n * @param {string|number|object} id A custom id used to identify the file\n * @param {string} filename The value of the 'filename' key in the files doc\n * @param {object} [options] Optional settings.\n * @param {number} [options.chunkSizeBytes] Optional overwrite this bucket's chunkSizeBytes for this file\n * @param {object} [options.metadata] Optional object to store in the file document's `metadata` field\n * @param {string} [options.contentType] Optional string to store in the file document's `contentType` field\n * @param {array} [options.aliases] Optional array of strings to store in the file document's `aliases` field\n * @param {boolean} [options.disableMD5=false] If true, disables adding an md5 field to file data\n * @return {GridFSBucketWriteStream}\n */\n\nGridFSBucket.prototype.openUploadStreamWithId = function(id, filename, options) {\n  if (options) {\n    options = shallowClone(options);\n  } else {\n    options = {};\n  }\n\n  if (!options.chunkSizeBytes) {\n    options.chunkSizeBytes = this.s.options.chunkSizeBytes;\n  }\n\n  options.id = id;\n\n  return new GridFSBucketWriteStream(this, filename, options);\n};\n\n/**\n * Returns a readable stream (GridFSBucketReadStream) for streaming file\n * data from GridFS.\n * @method\n * @param {ObjectId} id The id of the file doc\n * @param {Object} [options] Optional settings.\n * @param {Number} [options.start] Optional 0-based offset in bytes to start streaming from\n * @param {Number} [options.end] Optional 0-based offset in bytes to stop streaming before\n * @return {GridFSBucketReadStream}\n */\n\nGridFSBucket.prototype.openDownloadStream = function(id, options) {\n  var filter = { _id: id };\n  options = {\n    start: options && options.start,\n    end: options && options.end\n  };\n\n  return new GridFSBucketReadStream(\n    this.s._chunksCollection,\n    this.s._filesCollection,\n    this.s.options.readPreference,\n    filter,\n    options\n  );\n};\n\n/**\n * Deletes a file with the given id\n * @method\n * @param {ObjectId} id The id of the file doc\n * @param {GridFSBucket~errorCallback} [callback]\n */\n\nGridFSBucket.prototype.delete = function(id, callback) {\n  return executeLegacyOperation(this.s.db.s.topology, _delete, [this, id, callback], {\n    skipSessions: true\n  });\n};\n\n/**\n * @ignore\n */\n\nfunction _delete(_this, id, callback) {\n  _this.s._filesCollection.deleteOne({ _id: id }, function(error, res) {\n    if (error) {\n      return callback(error);\n    }\n\n    _this.s._chunksCollection.deleteMany({ files_id: id }, function(error) {\n      if (error) {\n        return callback(error);\n      }\n\n      // Delete orphaned chunks before returning FileNotFound\n      if (!res.result.n) {\n        var errmsg = 'FileNotFound: no file with id ' + id + ' found';\n        return callback(new Error(errmsg));\n      }\n\n      callback();\n    });\n  });\n}\n\n/**\n * Convenience wrapper around find on the files collection\n * @method\n * @param {Object} filter\n * @param {Object} [options] Optional settings for cursor\n * @param {number} [options.batchSize=1000] The number of documents to return per batch. See {@link https://docs.mongodb.com/manual/reference/command/find|find command documentation}.\n * @param {number} [options.limit] Optional limit for cursor\n * @param {number} [options.maxTimeMS] Optional maxTimeMS for cursor\n * @param {boolean} [options.noCursorTimeout] Optionally set cursor's `noCursorTimeout` flag\n * @param {number} [options.skip] Optional skip for cursor\n * @param {object} [options.sort] Optional sort for cursor\n * @return {Cursor}\n */\n\nGridFSBucket.prototype.find = function(filter, options) {\n  filter = filter || {};\n  options = options || {};\n\n  var cursor = this.s._filesCollection.find(filter);\n\n  if (options.batchSize != null) {\n    cursor.batchSize(options.batchSize);\n  }\n  if (options.limit != null) {\n    cursor.limit(options.limit);\n  }\n  if (options.maxTimeMS != null) {\n    cursor.maxTimeMS(options.maxTimeMS);\n  }\n  if (options.noCursorTimeout != null) {\n    cursor.addCursorFlag('noCursorTimeout', options.noCursorTimeout);\n  }\n  if (options.skip != null) {\n    cursor.skip(options.skip);\n  }\n  if (options.sort != null) {\n    cursor.sort(options.sort);\n  }\n\n  return cursor;\n};\n\n/**\n * Returns a readable stream (GridFSBucketReadStream) for streaming the\n * file with the given name from GridFS. If there are multiple files with\n * the same name, this will stream the most recent file with the given name\n * (as determined by the `uploadDate` field). You can set the `revision`\n * option to change this behavior.\n * @method\n * @param {String} filename The name of the file to stream\n * @param {Object} [options] Optional settings\n * @param {number} [options.revision=-1] The revision number relative to the oldest file with the given filename. 0 gets you the oldest file, 1 gets you the 2nd oldest, -1 gets you the newest.\n * @param {Number} [options.start] Optional 0-based offset in bytes to start streaming from\n * @param {Number} [options.end] Optional 0-based offset in bytes to stop streaming before\n * @return {GridFSBucketReadStream}\n */\n\nGridFSBucket.prototype.openDownloadStreamByName = function(filename, options) {\n  var sort = { uploadDate: -1 };\n  var skip = null;\n  if (options && options.revision != null) {\n    if (options.revision >= 0) {\n      sort = { uploadDate: 1 };\n      skip = options.revision;\n    } else {\n      skip = -options.revision - 1;\n    }\n  }\n\n  var filter = { filename: filename };\n  options = {\n    sort: sort,\n    skip: skip,\n    start: options && options.start,\n    end: options && options.end\n  };\n  return new GridFSBucketReadStream(\n    this.s._chunksCollection,\n    this.s._filesCollection,\n    this.s.options.readPreference,\n    filter,\n    options\n  );\n};\n\n/**\n * Renames the file with the given _id to the given string\n * @method\n * @param {ObjectId} id the id of the file to rename\n * @param {String} filename new name for the file\n * @param {GridFSBucket~errorCallback} [callback]\n */\n\nGridFSBucket.prototype.rename = function(id, filename, callback) {\n  return executeLegacyOperation(this.s.db.s.topology, _rename, [this, id, filename, callback], {\n    skipSessions: true\n  });\n};\n\n/**\n * @ignore\n */\n\nfunction _rename(_this, id, filename, callback) {\n  var filter = { _id: id };\n  var update = { $set: { filename: filename } };\n  _this.s._filesCollection.updateOne(filter, update, function(error, res) {\n    if (error) {\n      return callback(error);\n    }\n    if (!res.result.n) {\n      return callback(toError('File with id ' + id + ' not found'));\n    }\n    callback();\n  });\n}\n\n/**\n * Removes this bucket's files collection, followed by its chunks collection.\n * @method\n * @param {GridFSBucket~errorCallback} [callback]\n */\n\nGridFSBucket.prototype.drop = function(callback) {\n  return executeLegacyOperation(this.s.db.s.topology, _drop, [this, callback], {\n    skipSessions: true\n  });\n};\n\n/**\n * Return the db logger\n * @method\n * @return {Logger} return the db logger\n * @ignore\n */\nGridFSBucket.prototype.getLogger = function() {\n  return this.s.db.s.logger;\n};\n\n/**\n * @ignore\n */\n\nfunction _drop(_this, callback) {\n  _this.s._filesCollection.drop(function(error) {\n    if (error) {\n      return callback(error);\n    }\n    _this.s._chunksCollection.drop(function(error) {\n      if (error) {\n        return callback(error);\n      }\n\n      return callback();\n    });\n  });\n}\n\n/**\n * Callback format for all GridFSBucket methods that can accept a callback.\n * @callback GridFSBucket~errorCallback\n * @param {MongoError|undefined} error If present, an error instance representing any errors that occurred\n * @param {*} result If present, a returned result for the method\n */\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}