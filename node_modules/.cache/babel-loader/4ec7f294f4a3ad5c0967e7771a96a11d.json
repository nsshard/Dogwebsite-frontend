{"ast":null,"code":"var path = require('path'),\n    fs = require('fs'),\n    f = require('util').format,\n    resolveFrom = require('resolve-from'),\n    semver = require('semver');\n\nvar exists = fs.existsSync || path.existsSync; // Find the location of a package.json file near or above the given location\n\nvar find_package_json = function (location) {\n  var found = false;\n\n  while (!found) {\n    if (exists(location + '/package.json')) {\n      found = location;\n    } else if (location !== '/') {\n      location = path.dirname(location);\n    } else {\n      return false;\n    }\n  }\n\n  return location;\n}; // Find the package.json object of the module closest up the module call tree that contains name in that module's peerOptionalDependencies\n\n\nvar find_package_json_with_name = function (name) {\n  // Walk up the module call tree until we find a module containing name in its peerOptionalDependencies\n  var currentModule = module;\n  var found = false;\n\n  while (currentModule) {\n    // Check currentModule has a package.json\n    location = currentModule.filename;\n    var location = find_package_json(location);\n\n    if (!location) {\n      currentModule = currentModule.parent;\n      continue;\n    } // Read the package.json file\n\n\n    var object = JSON.parse(fs.readFileSync(f('%s/package.json', location))); // Is the name defined by interal file references\n\n    var parts = name.split(/\\//); // Check whether this package.json contains peerOptionalDependencies containing the name we're searching for\n\n    if (!object.peerOptionalDependencies || object.peerOptionalDependencies && !object.peerOptionalDependencies[parts[0]]) {\n      currentModule = currentModule.parent;\n      continue;\n    }\n\n    found = true;\n    break;\n  } // Check whether name has been found in currentModule's peerOptionalDependencies\n\n\n  if (!found) {\n    throw new Error(f('no optional dependency [%s] defined in peerOptionalDependencies in any package.json', parts[0]));\n  }\n\n  return {\n    object: object,\n    parts: parts\n  };\n};\n\nvar require_optional = function (name, options) {\n  options = options || {};\n  options.strict = typeof options.strict == 'boolean' ? options.strict : true;\n  var res = find_package_json_with_name(name);\n  var object = res.object;\n  var parts = res.parts; // Unpack the expected version\n\n  var expectedVersions = object.peerOptionalDependencies[parts[0]]; // The resolved package\n\n  var moduleEntry = undefined; // Module file\n\n  var moduleEntryFile = name;\n\n  try {\n    // Validate if it's possible to read the module\n    moduleEntry = require(moduleEntryFile);\n  } catch (err) {\n    // Attempt to resolve in top level package\n    try {\n      // Get the module entry file\n      moduleEntryFile = resolveFrom(process.cwd(), name);\n      if (moduleEntryFile == null) return undefined; // Attempt to resolve the module\n\n      moduleEntry = require(moduleEntryFile);\n    } catch (err) {\n      if (err.code === 'MODULE_NOT_FOUND') return undefined;\n    }\n  } // Resolve the location of the module's package.json file\n\n\n  var location = find_package_json(require.resolve(moduleEntryFile));\n\n  if (!location) {\n    throw new Error('package.json can not be located');\n  } // Read the module file\n\n\n  var dependentOnModule = JSON.parse(fs.readFileSync(f('%s/package.json', location))); // Get the version\n\n  var version = dependentOnModule.version; // Validate if the found module satisfies the version id\n\n  if (semver.satisfies(version, expectedVersions) == false && options.strict) {\n    var error = new Error(f('optional dependency [%s] found but version [%s] did not satisfy constraint [%s]', parts[0], version, expectedVersions));\n    error.code = 'OPTIONAL_MODULE_NOT_FOUND';\n    throw error;\n  } // Satifies the module requirement\n\n\n  return moduleEntry;\n};\n\nrequire_optional.exists = function (name) {\n  try {\n    var m = require_optional(name);\n    if (m === undefined) return false;\n    return true;\n  } catch (err) {\n    return false;\n  }\n};\n\nmodule.exports = require_optional;","map":{"version":3,"names":["path","require","fs","f","format","resolveFrom","semver","exists","existsSync","find_package_json","location","found","dirname","find_package_json_with_name","name","currentModule","module","filename","parent","object","JSON","parse","readFileSync","parts","split","peerOptionalDependencies","Error","require_optional","options","strict","res","expectedVersions","moduleEntry","undefined","moduleEntryFile","err","process","cwd","code","resolve","dependentOnModule","version","satisfies","error","m","exports"],"sources":["C:/Users/Administrator/Desktop/webAPI work/web/dog-website/node_modules/require_optional/index.js"],"sourcesContent":["var path = require('path'),\n  fs = require('fs'),\n  f = require('util').format,\n  resolveFrom = require('resolve-from'),\n  semver = require('semver');\n\nvar exists = fs.existsSync || path.existsSync;\n\n// Find the location of a package.json file near or above the given location\nvar find_package_json = function(location) {\n  var found = false;\n\n  while(!found) {\n    if (exists(location + '/package.json')) {\n      found = location;\n    } else if (location !== '/') {\n      location = path.dirname(location);\n    } else {\n      return false;\n    }\n  }\n\n  return location;\n}\n\n// Find the package.json object of the module closest up the module call tree that contains name in that module's peerOptionalDependencies\nvar find_package_json_with_name = function(name) {\n  // Walk up the module call tree until we find a module containing name in its peerOptionalDependencies\n  var currentModule = module;\n  var found = false;\n  while (currentModule) {\n    // Check currentModule has a package.json\n    location = currentModule.filename;\n    var location = find_package_json(location)\n    if (!location) {\n      currentModule = currentModule.parent;\n      continue;\n    }\n\n    // Read the package.json file\n    var object = JSON.parse(fs.readFileSync(f('%s/package.json', location)));\n    // Is the name defined by interal file references\n    var parts = name.split(/\\//);\n\n    // Check whether this package.json contains peerOptionalDependencies containing the name we're searching for\n    if (!object.peerOptionalDependencies || (object.peerOptionalDependencies && !object.peerOptionalDependencies[parts[0]])) {\n      currentModule = currentModule.parent;\n      continue;\n    }\n    found = true;\n    break;\n  }\n\n  // Check whether name has been found in currentModule's peerOptionalDependencies\n  if (!found) {\n    throw new Error(f('no optional dependency [%s] defined in peerOptionalDependencies in any package.json', parts[0]));\n  }\n\n  return {\n    object: object,\n    parts: parts\n  }\n}\n\nvar require_optional = function(name, options) {\n  options = options || {};\n  options.strict = typeof options.strict == 'boolean' ? options.strict : true;\n\n  var res = find_package_json_with_name(name)\n  var object = res.object;\n  var parts = res.parts;\n\n  // Unpack the expected version\n  var expectedVersions = object.peerOptionalDependencies[parts[0]];\n  // The resolved package\n  var moduleEntry = undefined;\n  // Module file\n  var moduleEntryFile = name;\n\n  try {\n    // Validate if it's possible to read the module\n    moduleEntry = require(moduleEntryFile);\n  } catch(err) {\n    // Attempt to resolve in top level package\n    try {\n      // Get the module entry file\n      moduleEntryFile = resolveFrom(process.cwd(), name);\n      if(moduleEntryFile == null) return undefined;\n      // Attempt to resolve the module\n      moduleEntry = require(moduleEntryFile);\n    } catch(err) {\n      if(err.code === 'MODULE_NOT_FOUND') return undefined;\n    }\n  }\n\n  // Resolve the location of the module's package.json file\n  var location = find_package_json(require.resolve(moduleEntryFile));\n  if(!location) {\n    throw new Error('package.json can not be located');\n  }\n\n  // Read the module file\n  var dependentOnModule = JSON.parse(fs.readFileSync(f('%s/package.json', location)));\n  // Get the version\n  var version = dependentOnModule.version;\n  // Validate if the found module satisfies the version id\n  if(semver.satisfies(version, expectedVersions) == false\n    && options.strict) {\n      var error = new Error(f('optional dependency [%s] found but version [%s] did not satisfy constraint [%s]', parts[0], version, expectedVersions));\n      error.code = 'OPTIONAL_MODULE_NOT_FOUND';\n      throw error;\n  }\n\n  // Satifies the module requirement\n  return moduleEntry;\n}\n\nrequire_optional.exists = function(name) {\n  try {\n    var m = require_optional(name);\n    if(m === undefined) return false;\n    return true;\n  } catch(err) {\n    return false;\n  }\n}\n\nmodule.exports = require_optional;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}