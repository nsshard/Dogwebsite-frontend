{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DropDatabaseOperation = exports.DropCollectionOperation = void 0;\n\nconst error_1 = require(\"../error\");\n\nconst command_1 = require(\"./command\");\n\nconst operation_1 = require(\"./operation\");\n/** @internal */\n\n\nclass DropCollectionOperation extends command_1.CommandOperation {\n  constructor(db, name) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    super(db, options);\n    this.db = db;\n    this.options = options;\n    this.name = name;\n  }\n\n  execute(server, session, callback) {\n    (async () => {\n      var _a, _b, _c, _d;\n\n      const db = this.db;\n      const options = this.options;\n      const name = this.name;\n      const encryptedFieldsMap = (_a = db.s.client.options.autoEncryption) === null || _a === void 0 ? void 0 : _a.encryptedFieldsMap;\n      let encryptedFields = (_b = options.encryptedFields) !== null && _b !== void 0 ? _b : encryptedFieldsMap === null || encryptedFieldsMap === void 0 ? void 0 : encryptedFieldsMap[`${db.databaseName}.${name}`];\n\n      if (!encryptedFields && encryptedFieldsMap) {\n        // If the MongoClient was configued with an encryptedFieldsMap,\n        // and no encryptedFields config was available in it or explicitly\n        // passed as an argument, the spec tells us to look one up using\n        // listCollections().\n        const listCollectionsResult = await db.listCollections({\n          name\n        }, {\n          nameOnly: false\n        }).toArray();\n        encryptedFields = (_d = (_c = listCollectionsResult === null || listCollectionsResult === void 0 ? void 0 : listCollectionsResult[0]) === null || _c === void 0 ? void 0 : _c.options) === null || _d === void 0 ? void 0 : _d.encryptedFields;\n      }\n\n      let result;\n      let errorForMainOperation;\n\n      try {\n        result = await this.executeWithoutEncryptedFieldsCheck(server, session);\n      } catch (err) {\n        if (!encryptedFields || !(err instanceof error_1.MongoServerError) || err.code !== error_1.MONGODB_ERROR_CODES.NamespaceNotFound) {\n          throw err;\n        } // Save a possible NamespaceNotFound error for later\n        // in the encryptedFields case, so that the auxilliary\n        // collections will still be dropped.\n\n\n        errorForMainOperation = err;\n      }\n\n      if (encryptedFields) {\n        const escCollection = encryptedFields.escCollection || `enxcol_.${name}.esc`;\n        const eccCollection = encryptedFields.eccCollection || `enxcol_.${name}.ecc`;\n        const ecocCollection = encryptedFields.ecocCollection || `enxcol_.${name}.ecoc`;\n\n        for (const collectionName of [escCollection, eccCollection, ecocCollection]) {\n          // Drop auxilliary collections, ignoring potential NamespaceNotFound errors.\n          const dropOp = new DropCollectionOperation(db, collectionName);\n\n          try {\n            await dropOp.executeWithoutEncryptedFieldsCheck(server, session);\n          } catch (err) {\n            if (!(err instanceof error_1.MongoServerError) || err.code !== error_1.MONGODB_ERROR_CODES.NamespaceNotFound) {\n              throw err;\n            }\n          }\n        }\n\n        if (errorForMainOperation) {\n          throw errorForMainOperation;\n        }\n      }\n\n      return result;\n    })().then(result => callback(undefined, result), err => callback(err));\n  }\n\n  executeWithoutEncryptedFieldsCheck(server, session) {\n    return new Promise((resolve, reject) => {\n      super.executeCommand(server, session, {\n        drop: this.name\n      }, (err, result) => {\n        if (err) return reject(err);\n        resolve(!!result.ok);\n      });\n    });\n  }\n\n}\n\nexports.DropCollectionOperation = DropCollectionOperation;\n/** @internal */\n\nclass DropDatabaseOperation extends command_1.CommandOperation {\n  constructor(db, options) {\n    super(db, options);\n    this.options = options;\n  }\n\n  execute(server, session, callback) {\n    super.executeCommand(server, session, {\n      dropDatabase: 1\n    }, (err, result) => {\n      if (err) return callback(err);\n      if (result.ok) return callback(undefined, true);\n      callback(undefined, false);\n    });\n  }\n\n}\n\nexports.DropDatabaseOperation = DropDatabaseOperation;\n(0, operation_1.defineAspects)(DropCollectionOperation, [operation_1.Aspect.WRITE_OPERATION]);\n(0, operation_1.defineAspects)(DropDatabaseOperation, [operation_1.Aspect.WRITE_OPERATION]);","map":{"version":3,"mappings":"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","names":["DropCollectionOperation","command_1","constructor","db","name","options","execute","server","session","callback","encryptedFieldsMap","s","client","autoEncryption","_a","encryptedFields","_b","databaseName","listCollectionsResult","listCollections","nameOnly","toArray","_c","_d","result","errorForMainOperation","executeWithoutEncryptedFieldsCheck","err","error_1","code","NamespaceNotFound","escCollection","eccCollection","ecocCollection","collectionName","dropOp","then","undefined","Promise","resolve","reject","executeCommand","drop","ok","exports","DropDatabaseOperation","dropDatabase","operation_1","WRITE_OPERATION"],"sources":["C:\\Users\\Administrator\\Desktop\\webAPI work\\web\\dog-website\\node_modules\\mongodb\\src\\operations\\drop.ts"],"sourcesContent":["import type { Document } from '../bson';\nimport type { Db } from '../db';\nimport { MONGODB_ERROR_CODES, MongoServerError } from '../error';\nimport type { Server } from '../sdam/server';\nimport type { ClientSession } from '../sessions';\nimport type { Callback } from '../utils';\nimport { CommandOperation, CommandOperationOptions } from './command';\nimport { Aspect, defineAspects } from './operation';\n\n/** @public */\nexport interface DropCollectionOptions extends CommandOperationOptions {\n  /** @experimental */\n  encryptedFields?: Document;\n}\n\n/** @internal */\nexport class DropCollectionOperation extends CommandOperation<boolean> {\n  override options: DropCollectionOptions;\n  db: Db;\n  name: string;\n\n  constructor(db: Db, name: string, options: DropCollectionOptions = {}) {\n    super(db, options);\n    this.db = db;\n    this.options = options;\n    this.name = name;\n  }\n\n  override execute(\n    server: Server,\n    session: ClientSession | undefined,\n    callback: Callback<boolean>\n  ): void {\n    (async () => {\n      const db = this.db;\n      const options = this.options;\n      const name = this.name;\n\n      const encryptedFieldsMap = db.s.client.options.autoEncryption?.encryptedFieldsMap;\n      let encryptedFields: Document | undefined =\n        options.encryptedFields ?? encryptedFieldsMap?.[`${db.databaseName}.${name}`];\n\n      if (!encryptedFields && encryptedFieldsMap) {\n        // If the MongoClient was configued with an encryptedFieldsMap,\n        // and no encryptedFields config was available in it or explicitly\n        // passed as an argument, the spec tells us to look one up using\n        // listCollections().\n        const listCollectionsResult = await db\n          .listCollections({ name }, { nameOnly: false })\n          .toArray();\n        encryptedFields = listCollectionsResult?.[0]?.options?.encryptedFields;\n      }\n\n      let result;\n      let errorForMainOperation;\n      try {\n        result = await this.executeWithoutEncryptedFieldsCheck(server, session);\n      } catch (err) {\n        if (\n          !encryptedFields ||\n          !(err instanceof MongoServerError) ||\n          err.code !== MONGODB_ERROR_CODES.NamespaceNotFound\n        ) {\n          throw err;\n        }\n        // Save a possible NamespaceNotFound error for later\n        // in the encryptedFields case, so that the auxilliary\n        // collections will still be dropped.\n        errorForMainOperation = err;\n      }\n\n      if (encryptedFields) {\n        const escCollection = encryptedFields.escCollection || `enxcol_.${name}.esc`;\n        const eccCollection = encryptedFields.eccCollection || `enxcol_.${name}.ecc`;\n        const ecocCollection = encryptedFields.ecocCollection || `enxcol_.${name}.ecoc`;\n\n        for (const collectionName of [escCollection, eccCollection, ecocCollection]) {\n          // Drop auxilliary collections, ignoring potential NamespaceNotFound errors.\n          const dropOp = new DropCollectionOperation(db, collectionName);\n          try {\n            await dropOp.executeWithoutEncryptedFieldsCheck(server, session);\n          } catch (err) {\n            if (\n              !(err instanceof MongoServerError) ||\n              err.code !== MONGODB_ERROR_CODES.NamespaceNotFound\n            ) {\n              throw err;\n            }\n          }\n        }\n\n        if (errorForMainOperation) {\n          throw errorForMainOperation;\n        }\n      }\n\n      return result;\n    })().then(\n      result => callback(undefined, result),\n      err => callback(err)\n    );\n  }\n\n  private executeWithoutEncryptedFieldsCheck(\n    server: Server,\n    session: ClientSession | undefined\n  ): Promise<boolean> {\n    return new Promise<boolean>((resolve, reject) => {\n      super.executeCommand(server, session, { drop: this.name }, (err, result) => {\n        if (err) return reject(err);\n        resolve(!!result.ok);\n      });\n    });\n  }\n}\n\n/** @public */\nexport type DropDatabaseOptions = CommandOperationOptions;\n\n/** @internal */\nexport class DropDatabaseOperation extends CommandOperation<boolean> {\n  override options: DropDatabaseOptions;\n\n  constructor(db: Db, options: DropDatabaseOptions) {\n    super(db, options);\n    this.options = options;\n  }\n  override execute(\n    server: Server,\n    session: ClientSession | undefined,\n    callback: Callback<boolean>\n  ): void {\n    super.executeCommand(server, session, { dropDatabase: 1 }, (err, result) => {\n      if (err) return callback(err);\n      if (result.ok) return callback(undefined, true);\n      callback(undefined, false);\n    });\n  }\n}\n\ndefineAspects(DropCollectionOperation, [Aspect.WRITE_OPERATION]);\ndefineAspects(DropDatabaseOperation, [Aspect.WRITE_OPERATION]);\n"]},"metadata":{},"sourceType":"script"}