{"ast":null,"code":"\"use strict\";\n\nconst EventEmitter = require(\"events\").EventEmitter;\n\nconst factoryValidator = require(\"./factoryValidator\");\n\nconst PoolOptions = require(\"./PoolOptions\");\n\nconst ResourceRequest = require(\"./ResourceRequest\");\n\nconst ResourceLoan = require(\"./ResourceLoan\");\n\nconst PooledResource = require(\"./PooledResource\");\n\nconst DefaultEvictor = require(\"./DefaultEvictor\");\n\nconst Deque = require(\"./Deque\");\n\nconst Deferred = require(\"./Deferred\");\n\nconst PriorityQueue = require(\"./PriorityQueue\");\n\nconst DequeIterator = require(\"./DequeIterator\");\n\nconst reflector = require(\"./utils\").reflector;\n/**\n * TODO: move me\n */\n\n\nconst FACTORY_CREATE_ERROR = \"factoryCreateError\";\nconst FACTORY_DESTROY_ERROR = \"factoryDestroyError\";\n\nclass Pool extends EventEmitter {\n  /**\n   * Generate an Object pool with a specified `factory` and `config`.\n   *\n   * @param {typeof DefaultEvictor} Evictor\n   * @param {typeof Deque} Deque\n   * @param {typeof PriorityQueue} PriorityQueue\n   * @param {Object} factory\n   *   Factory to be used for generating and destroying the items.\n   * @param {Function} factory.create\n   *   Should create the item to be acquired,\n   *   and call it's first callback argument with the generated item as it's argument.\n   * @param {Function} factory.destroy\n   *   Should gently close any resources that the item is using.\n   *   Called before the items is destroyed.\n   * @param {Function} factory.validate\n   *   Test if a resource is still valid .Should return a promise that resolves to a boolean, true if resource is still valid and false\n   *   If it should be removed from pool.\n   * @param {Object} options\n   */\n  constructor(Evictor, Deque, PriorityQueue, factory, options) {\n    super();\n    factoryValidator(factory);\n    this._config = new PoolOptions(options); // TODO: fix up this ugly glue-ing\n\n    this._Promise = this._config.Promise;\n    this._factory = factory;\n    this._draining = false;\n    this._started = false;\n    /**\n     * Holds waiting clients\n     * @type {PriorityQueue}\n     */\n\n    this._waitingClientsQueue = new PriorityQueue(this._config.priorityRange);\n    /**\n     * Collection of promises for resource creation calls made by the pool to factory.create\n     * @type {Set}\n     */\n\n    this._factoryCreateOperations = new Set();\n    /**\n     * Collection of promises for resource destruction calls made by the pool to factory.destroy\n     * @type {Set}\n     */\n\n    this._factoryDestroyOperations = new Set();\n    /**\n     * A queue/stack of pooledResources awaiting acquisition\n     * TODO: replace with LinkedList backed array\n     * @type {Deque}\n     */\n\n    this._availableObjects = new Deque();\n    /**\n     * Collection of references for any resource that are undergoing validation before being acquired\n     * @type {Set}\n     */\n\n    this._testOnBorrowResources = new Set();\n    /**\n     * Collection of references for any resource that are undergoing validation before being returned\n     * @type {Set}\n     */\n\n    this._testOnReturnResources = new Set();\n    /**\n     * Collection of promises for any validations currently in process\n     * @type {Set}\n     */\n\n    this._validationOperations = new Set();\n    /**\n     * All objects associated with this pool in any state (except destroyed)\n     * @type {Set}\n     */\n\n    this._allObjects = new Set();\n    /**\n     * Loans keyed by the borrowed resource\n     * @type {Map}\n     */\n\n    this._resourceLoans = new Map();\n    /**\n     * Infinitely looping iterator over available object\n     * @type {DequeIterator}\n     */\n\n    this._evictionIterator = this._availableObjects.iterator();\n    this._evictor = new Evictor();\n    /**\n     * handle for setTimeout for next eviction run\n     * @type {(number|null)}\n     */\n\n    this._scheduledEviction = null; // create initial resources (if factory.min > 0)\n\n    if (this._config.autostart === true) {\n      this.start();\n    }\n  }\n\n  _destroy(pooledResource) {\n    // FIXME: do we need another state for \"in destruction\"?\n    pooledResource.invalidate();\n\n    this._allObjects.delete(pooledResource); // NOTE: this maybe very bad promise usage?\n\n\n    const destroyPromise = this._factory.destroy(pooledResource.obj);\n\n    const wrappedDestroyPromise = this._Promise.resolve(destroyPromise);\n\n    this._trackOperation(wrappedDestroyPromise, this._factoryDestroyOperations).catch(reason => {\n      this.emit(FACTORY_DESTROY_ERROR, reason);\n    }); // TODO: maybe ensuring minimum pool size should live outside here\n\n\n    this._ensureMinimum();\n  }\n  /**\n   * Attempt to move an available resource into test and then onto a waiting client\n   * @return {Boolean} could we move an available resource into test\n   */\n\n\n  _testOnBorrow() {\n    if (this._availableObjects.length < 1) {\n      return false;\n    }\n\n    const pooledResource = this._availableObjects.shift(); // Mark the resource as in test\n\n\n    pooledResource.test();\n\n    this._testOnBorrowResources.add(pooledResource);\n\n    const validationPromise = this._factory.validate(pooledResource.obj);\n\n    const wrappedValidationPromise = this._Promise.resolve(validationPromise);\n\n    this._trackOperation(wrappedValidationPromise, this._validationOperations).then(isValid => {\n      this._testOnBorrowResources.delete(pooledResource);\n\n      if (isValid === false) {\n        pooledResource.invalidate();\n\n        this._destroy(pooledResource);\n\n        this._dispense();\n\n        return;\n      }\n\n      this._dispatchPooledResourceToNextWaitingClient(pooledResource);\n    });\n\n    return true;\n  }\n  /**\n   * Attempt to move an available resource to a waiting client\n   * @return {Boolean} [description]\n   */\n\n\n  _dispatchResource() {\n    if (this._availableObjects.length < 1) {\n      return false;\n    }\n\n    const pooledResource = this._availableObjects.shift();\n\n    this._dispatchPooledResourceToNextWaitingClient(pooledResource);\n\n    return false;\n  }\n  /**\n   * Attempt to resolve an outstanding resource request using an available resource from\n   * the pool, or creating new ones\n   *\n   * @private\n   */\n\n\n  _dispense() {\n    /**\n     * Local variables for ease of reading/writing\n     * these don't (shouldn't) change across the execution of this fn\n     */\n    const numWaitingClients = this._waitingClientsQueue.length; // If there aren't any waiting requests then there is nothing to do\n    // so lets short-circuit\n\n    if (numWaitingClients < 1) {\n      return;\n    }\n\n    const resourceShortfall = numWaitingClients - this._potentiallyAllocableResourceCount;\n    const actualNumberOfResourcesToCreate = Math.min(this.spareResourceCapacity, resourceShortfall);\n\n    for (let i = 0; actualNumberOfResourcesToCreate > i; i++) {\n      this._createResource();\n    } // If we are doing test-on-borrow see how many more resources need to be moved into test\n    // to help satisfy waitingClients\n\n\n    if (this._config.testOnBorrow === true) {\n      // how many available resources do we need to shift into test\n      const desiredNumberOfResourcesToMoveIntoTest = numWaitingClients - this._testOnBorrowResources.size;\n      const actualNumberOfResourcesToMoveIntoTest = Math.min(this._availableObjects.length, desiredNumberOfResourcesToMoveIntoTest);\n\n      for (let i = 0; actualNumberOfResourcesToMoveIntoTest > i; i++) {\n        this._testOnBorrow();\n      }\n    } // if we aren't testing-on-borrow then lets try to allocate what we can\n\n\n    if (this._config.testOnBorrow === false) {\n      const actualNumberOfResourcesToDispatch = Math.min(this._availableObjects.length, numWaitingClients);\n\n      for (let i = 0; actualNumberOfResourcesToDispatch > i; i++) {\n        this._dispatchResource();\n      }\n    }\n  }\n  /**\n   * Dispatches a pooledResource to the next waiting client (if any) else\n   * puts the PooledResource back on the available list\n   * @param  {PooledResource} pooledResource [description]\n   * @return {Boolean}                [description]\n   */\n\n\n  _dispatchPooledResourceToNextWaitingClient(pooledResource) {\n    const clientResourceRequest = this._waitingClientsQueue.dequeue();\n\n    if (clientResourceRequest === undefined || clientResourceRequest.state !== Deferred.PENDING) {\n      // While we were away either all the waiting clients timed out\n      // or were somehow fulfilled. put our pooledResource back.\n      this._addPooledResourceToAvailableObjects(pooledResource); // TODO: do need to trigger anything before we leave?\n\n\n      return false;\n    }\n\n    const loan = new ResourceLoan(pooledResource, this._Promise);\n\n    this._resourceLoans.set(pooledResource.obj, loan);\n\n    pooledResource.allocate();\n    clientResourceRequest.resolve(pooledResource.obj);\n    return true;\n  }\n  /**\n   * tracks on operation using given set\n   * handles adding/removing from the set and resolve/rejects the value/reason\n   * @param  {Promise} operation\n   * @param  {Set} set       Set holding operations\n   * @return {Promise}       Promise that resolves once operation has been removed from set\n   */\n\n\n  _trackOperation(operation, set) {\n    set.add(operation);\n    return operation.then(v => {\n      set.delete(operation);\n      return this._Promise.resolve(v);\n    }, e => {\n      set.delete(operation);\n      return this._Promise.reject(e);\n    });\n  }\n  /**\n   * @private\n   */\n\n\n  _createResource() {\n    // An attempt to create a resource\n    const factoryPromise = this._factory.create();\n\n    const wrappedFactoryPromise = this._Promise.resolve(factoryPromise).then(resource => {\n      const pooledResource = new PooledResource(resource);\n\n      this._allObjects.add(pooledResource);\n\n      this._addPooledResourceToAvailableObjects(pooledResource);\n    });\n\n    this._trackOperation(wrappedFactoryPromise, this._factoryCreateOperations).then(() => {\n      this._dispense(); // Stop bluebird complaining about this side-effect only handler\n      // - a promise was created in a handler but was not returned from it\n      // https://goo.gl/rRqMUw\n\n\n      return null;\n    }).catch(reason => {\n      this.emit(FACTORY_CREATE_ERROR, reason);\n\n      this._dispense();\n    });\n  }\n  /**\n   * @private\n   */\n\n\n  _ensureMinimum() {\n    if (this._draining === true) {\n      return;\n    }\n\n    const minShortfall = this._config.min - this._count;\n\n    for (let i = 0; i < minShortfall; i++) {\n      this._createResource();\n    }\n  }\n\n  _evict() {\n    const testsToRun = Math.min(this._config.numTestsPerEvictionRun, this._availableObjects.length);\n    const evictionConfig = {\n      softIdleTimeoutMillis: this._config.softIdleTimeoutMillis,\n      idleTimeoutMillis: this._config.idleTimeoutMillis,\n      min: this._config.min\n    };\n\n    for (let testsHaveRun = 0; testsHaveRun < testsToRun;) {\n      const iterationResult = this._evictionIterator.next(); // Safety check incase we could get stuck in infinite loop because we\n      // somehow emptied the array after chekcing it's length\n\n\n      if (iterationResult.done === true && this._availableObjects.length < 1) {\n        this._evictionIterator.reset();\n\n        return;\n      } // if this happens it should just mean we reached the end of the\n      // list and can reset the cursor.\n\n\n      if (iterationResult.done === true && this._availableObjects.length > 0) {\n        this._evictionIterator.reset();\n\n        continue;\n      }\n\n      const resource = iterationResult.value;\n\n      const shouldEvict = this._evictor.evict(evictionConfig, resource, this._availableObjects.length);\n\n      testsHaveRun++;\n\n      if (shouldEvict === true) {\n        // take it out of the _availableObjects list\n        this._evictionIterator.remove();\n\n        this._destroy(resource);\n      }\n    }\n  }\n\n  _scheduleEvictorRun() {\n    // Start eviction if set\n    if (this._config.evictionRunIntervalMillis > 0) {\n      // @ts-ignore\n      this._scheduledEviction = setTimeout(() => {\n        this._evict();\n\n        this._scheduleEvictorRun();\n      }, this._config.evictionRunIntervalMillis);\n    }\n  }\n\n  _descheduleEvictorRun() {\n    if (this._scheduledEviction) {\n      clearTimeout(this._scheduledEviction);\n    }\n\n    this._scheduledEviction = null;\n  }\n\n  start() {\n    if (this._draining === true) {\n      return;\n    }\n\n    if (this._started === true) {\n      return;\n    }\n\n    this._started = true;\n\n    this._scheduleEvictorRun();\n\n    this._ensureMinimum();\n  }\n  /**\n   * Request a new resource. The callback will be called,\n   * when a new resource is available, passing the resource to the callback.\n   * TODO: should we add a seperate \"acquireWithPriority\" function\n   *\n   * @param {Number} [priority=0]\n   *   Optional.  Integer between 0 and (priorityRange - 1).  Specifies the priority\n   *   of the caller if there are no available resources.  Lower numbers mean higher\n   *   priority.\n   *\n   * @returns {Promise}\n   */\n\n\n  acquire(priority) {\n    if (this._started === false && this._config.autostart === false) {\n      this.start();\n    }\n\n    if (this._draining) {\n      return this._Promise.reject(new Error(\"pool is draining and cannot accept work\"));\n    } // TODO: should we defer this check till after this event loop incase \"the situation\" changes in the meantime\n\n\n    if (this.spareResourceCapacity < 1 && this._availableObjects.length < 1 && this._config.maxWaitingClients !== undefined && this._waitingClientsQueue.length >= this._config.maxWaitingClients) {\n      return this._Promise.reject(new Error(\"max waitingClients count exceeded\"));\n    }\n\n    const resourceRequest = new ResourceRequest(this._config.acquireTimeoutMillis, this._Promise);\n\n    this._waitingClientsQueue.enqueue(resourceRequest, priority);\n\n    this._dispense();\n\n    return resourceRequest.promise;\n  }\n  /**\n   * [use method, aquires a resource, passes the resource to a user supplied function and releases it]\n   * @param  {Function} fn [a function that accepts a resource and returns a promise that resolves/rejects once it has finished using the resource]\n   * @return {Promise}      [resolves once the resource is released to the pool]\n   */\n\n\n  use(fn) {\n    return this.acquire().then(resource => {\n      return fn(resource).then(result => {\n        this.release(resource);\n        return result;\n      }, err => {\n        this.destroy(resource);\n        throw err;\n      });\n    });\n  }\n  /**\n   * Check if resource is currently on loan from the pool\n   *\n   * @param {Function} resource\n   *    Resource for checking.\n   *\n   * @returns {Boolean}\n   *  True if resource belongs to this pool and false otherwise\n   */\n\n\n  isBorrowedResource(resource) {\n    return this._resourceLoans.has(resource);\n  }\n  /**\n   * Return the resource to the pool when it is no longer required.\n   *\n   * @param {Object} resource\n   *   The acquired object to be put back to the pool.\n   */\n\n\n  release(resource) {\n    // check for an outstanding loan\n    const loan = this._resourceLoans.get(resource);\n\n    if (loan === undefined) {\n      return this._Promise.reject(new Error(\"Resource not currently part of this pool\"));\n    }\n\n    this._resourceLoans.delete(resource);\n\n    loan.resolve();\n    const pooledResource = loan.pooledResource;\n    pooledResource.deallocate();\n\n    this._addPooledResourceToAvailableObjects(pooledResource);\n\n    this._dispense();\n\n    return this._Promise.resolve();\n  }\n  /**\n   * Request the resource to be destroyed. The factory's destroy handler\n   * will also be called.\n   *\n   * This should be called within an acquire() block as an alternative to release().\n   *\n   * @param {Object} resource\n   *   The acquired resource to be destoyed.\n   */\n\n\n  destroy(resource) {\n    // check for an outstanding loan\n    const loan = this._resourceLoans.get(resource);\n\n    if (loan === undefined) {\n      return this._Promise.reject(new Error(\"Resource not currently part of this pool\"));\n    }\n\n    this._resourceLoans.delete(resource);\n\n    loan.resolve();\n    const pooledResource = loan.pooledResource;\n    pooledResource.deallocate();\n\n    this._destroy(pooledResource);\n\n    this._dispense();\n\n    return this._Promise.resolve();\n  }\n\n  _addPooledResourceToAvailableObjects(pooledResource) {\n    pooledResource.idle();\n\n    if (this._config.fifo === true) {\n      this._availableObjects.push(pooledResource);\n    } else {\n      this._availableObjects.unshift(pooledResource);\n    }\n  }\n  /**\n   * Disallow any new acquire calls and let the request backlog dissapate.\n   * The Pool will no longer attempt to maintain a \"min\" number of resources\n   * and will only make new resources on demand.\n   * Resolves once all resource requests are fulfilled and all resources are returned to pool and available...\n   * Should probably be called \"drain work\"\n   * @returns {Promise}\n   */\n\n\n  drain() {\n    this._draining = true;\n    return this.__allResourceRequestsSettled().then(() => {\n      return this.__allResourcesReturned();\n    }).then(() => {\n      this._descheduleEvictorRun();\n    });\n  }\n\n  __allResourceRequestsSettled() {\n    if (this._waitingClientsQueue.length > 0) {\n      // wait for last waiting client to be settled\n      // FIXME: what if they can \"resolve\" out of order....?\n      return reflector(this._waitingClientsQueue.tail.promise);\n    }\n\n    return this._Promise.resolve();\n  } // FIXME: this is a horrific mess\n\n\n  __allResourcesReturned() {\n    const ps = Array.from(this._resourceLoans.values()).map(loan => loan.promise).map(reflector);\n    return this._Promise.all(ps);\n  }\n  /**\n   * Forcibly destroys all available resources regardless of timeout.  Intended to be\n   * invoked as part of a drain.  Does not prevent the creation of new\n   * resources as a result of subsequent calls to acquire.\n   *\n   * Note that if factory.min > 0 and the pool isn't \"draining\", the pool will destroy all idle resources\n   * in the pool, but replace them with newly created resources up to the\n   * specified factory.min value.  If this is not desired, set factory.min\n   * to zero before calling clear()\n   *\n   */\n\n\n  clear() {\n    const reflectedCreatePromises = Array.from(this._factoryCreateOperations).map(reflector); // wait for outstanding factory.create to complete\n\n    return this._Promise.all(reflectedCreatePromises).then(() => {\n      // Destroy existing resources\n      // @ts-ignore\n      for (const resource of this._availableObjects) {\n        this._destroy(resource);\n      }\n\n      const reflectedDestroyPromises = Array.from(this._factoryDestroyOperations).map(reflector);\n      return reflector(this._Promise.all(reflectedDestroyPromises));\n    });\n  }\n  /**\n   * How many resources are available to allocated\n   * (includes resources that have not been tested and may faul validation)\n   * NOTE: internal for now as the name is awful and might not be useful to anyone\n   * @return {Number} number of resources the pool has to allocate\n   */\n\n\n  get _potentiallyAllocableResourceCount() {\n    return this._availableObjects.length + this._testOnBorrowResources.size + this._testOnReturnResources.size + this._factoryCreateOperations.size;\n  }\n  /**\n   * The combined count of the currently created objects and those in the\n   * process of being created\n   * Does NOT include resources in the process of being destroyed\n   * sort of legacy...\n   * @return {Number}\n   */\n\n\n  get _count() {\n    return this._allObjects.size + this._factoryCreateOperations.size;\n  }\n  /**\n   * How many more resources does the pool have room for\n   * @return {Number} number of resources the pool could create before hitting any limits\n   */\n\n\n  get spareResourceCapacity() {\n    return this._config.max - (this._allObjects.size + this._factoryCreateOperations.size);\n  }\n  /**\n   * see _count above\n   * @return {Number} [description]\n   */\n\n\n  get size() {\n    return this._count;\n  }\n  /**\n   * number of available resources\n   * @return {Number} [description]\n   */\n\n\n  get available() {\n    return this._availableObjects.length;\n  }\n  /**\n   * number of resources that are currently acquired\n   * @return {Number} [description]\n   */\n\n\n  get borrowed() {\n    return this._resourceLoans.size;\n  }\n  /**\n   * number of waiting acquire calls\n   * @return {Number} [description]\n   */\n\n\n  get pending() {\n    return this._waitingClientsQueue.length;\n  }\n  /**\n   * maximum size of the pool\n   * @return {Number} [description]\n   */\n\n\n  get max() {\n    return this._config.max;\n  }\n  /**\n   * minimum size of the pool\n   * @return {Number} [description]\n   */\n\n\n  get min() {\n    return this._config.min;\n  }\n\n}\n\nmodule.exports = Pool;","map":{"version":3,"names":["EventEmitter","require","factoryValidator","PoolOptions","ResourceRequest","ResourceLoan","PooledResource","DefaultEvictor","Deque","Deferred","PriorityQueue","DequeIterator","reflector","FACTORY_CREATE_ERROR","FACTORY_DESTROY_ERROR","Pool","constructor","Evictor","factory","options","_config","_Promise","Promise","_factory","_draining","_started","_waitingClientsQueue","priorityRange","_factoryCreateOperations","Set","_factoryDestroyOperations","_availableObjects","_testOnBorrowResources","_testOnReturnResources","_validationOperations","_allObjects","_resourceLoans","Map","_evictionIterator","iterator","_evictor","_scheduledEviction","autostart","start","_destroy","pooledResource","invalidate","delete","destroyPromise","destroy","obj","wrappedDestroyPromise","resolve","_trackOperation","catch","reason","emit","_ensureMinimum","_testOnBorrow","length","shift","test","add","validationPromise","validate","wrappedValidationPromise","then","isValid","_dispense","_dispatchPooledResourceToNextWaitingClient","_dispatchResource","numWaitingClients","resourceShortfall","_potentiallyAllocableResourceCount","actualNumberOfResourcesToCreate","Math","min","spareResourceCapacity","i","_createResource","testOnBorrow","desiredNumberOfResourcesToMoveIntoTest","size","actualNumberOfResourcesToMoveIntoTest","actualNumberOfResourcesToDispatch","clientResourceRequest","dequeue","undefined","state","PENDING","_addPooledResourceToAvailableObjects","loan","set","allocate","operation","v","e","reject","factoryPromise","create","wrappedFactoryPromise","resource","minShortfall","_count","_evict","testsToRun","numTestsPerEvictionRun","evictionConfig","softIdleTimeoutMillis","idleTimeoutMillis","testsHaveRun","iterationResult","next","done","reset","value","shouldEvict","evict","remove","_scheduleEvictorRun","evictionRunIntervalMillis","setTimeout","_descheduleEvictorRun","clearTimeout","acquire","priority","Error","maxWaitingClients","resourceRequest","acquireTimeoutMillis","enqueue","promise","use","fn","result","release","err","isBorrowedResource","has","get","deallocate","idle","fifo","push","unshift","drain","__allResourceRequestsSettled","__allResourcesReturned","tail","ps","Array","from","values","map","all","clear","reflectedCreatePromises","reflectedDestroyPromises","max","available","borrowed","pending","module","exports"],"sources":["C:/Users/Administrator/Desktop/webAPI work/web/dog-website/node_modules/generic-pool/lib/Pool.js"],"sourcesContent":["\"use strict\";\n\nconst EventEmitter = require(\"events\").EventEmitter;\n\nconst factoryValidator = require(\"./factoryValidator\");\nconst PoolOptions = require(\"./PoolOptions\");\nconst ResourceRequest = require(\"./ResourceRequest\");\nconst ResourceLoan = require(\"./ResourceLoan\");\nconst PooledResource = require(\"./PooledResource\");\nconst DefaultEvictor = require(\"./DefaultEvictor\");\nconst Deque = require(\"./Deque\");\nconst Deferred = require(\"./Deferred\");\nconst PriorityQueue = require(\"./PriorityQueue\");\nconst DequeIterator = require(\"./DequeIterator\");\n\nconst reflector = require(\"./utils\").reflector;\n\n/**\n * TODO: move me\n */\nconst FACTORY_CREATE_ERROR = \"factoryCreateError\";\nconst FACTORY_DESTROY_ERROR = \"factoryDestroyError\";\n\nclass Pool extends EventEmitter {\n  /**\n   * Generate an Object pool with a specified `factory` and `config`.\n   *\n   * @param {typeof DefaultEvictor} Evictor\n   * @param {typeof Deque} Deque\n   * @param {typeof PriorityQueue} PriorityQueue\n   * @param {Object} factory\n   *   Factory to be used for generating and destroying the items.\n   * @param {Function} factory.create\n   *   Should create the item to be acquired,\n   *   and call it's first callback argument with the generated item as it's argument.\n   * @param {Function} factory.destroy\n   *   Should gently close any resources that the item is using.\n   *   Called before the items is destroyed.\n   * @param {Function} factory.validate\n   *   Test if a resource is still valid .Should return a promise that resolves to a boolean, true if resource is still valid and false\n   *   If it should be removed from pool.\n   * @param {Object} options\n   */\n  constructor(Evictor, Deque, PriorityQueue, factory, options) {\n    super();\n\n    factoryValidator(factory);\n\n    this._config = new PoolOptions(options);\n\n    // TODO: fix up this ugly glue-ing\n    this._Promise = this._config.Promise;\n\n    this._factory = factory;\n    this._draining = false;\n    this._started = false;\n    /**\n     * Holds waiting clients\n     * @type {PriorityQueue}\n     */\n    this._waitingClientsQueue = new PriorityQueue(this._config.priorityRange);\n\n    /**\n     * Collection of promises for resource creation calls made by the pool to factory.create\n     * @type {Set}\n     */\n    this._factoryCreateOperations = new Set();\n\n    /**\n     * Collection of promises for resource destruction calls made by the pool to factory.destroy\n     * @type {Set}\n     */\n    this._factoryDestroyOperations = new Set();\n\n    /**\n     * A queue/stack of pooledResources awaiting acquisition\n     * TODO: replace with LinkedList backed array\n     * @type {Deque}\n     */\n    this._availableObjects = new Deque();\n\n    /**\n     * Collection of references for any resource that are undergoing validation before being acquired\n     * @type {Set}\n     */\n    this._testOnBorrowResources = new Set();\n\n    /**\n     * Collection of references for any resource that are undergoing validation before being returned\n     * @type {Set}\n     */\n    this._testOnReturnResources = new Set();\n\n    /**\n     * Collection of promises for any validations currently in process\n     * @type {Set}\n     */\n    this._validationOperations = new Set();\n\n    /**\n     * All objects associated with this pool in any state (except destroyed)\n     * @type {Set}\n     */\n    this._allObjects = new Set();\n\n    /**\n     * Loans keyed by the borrowed resource\n     * @type {Map}\n     */\n    this._resourceLoans = new Map();\n\n    /**\n     * Infinitely looping iterator over available object\n     * @type {DequeIterator}\n     */\n    this._evictionIterator = this._availableObjects.iterator();\n\n    this._evictor = new Evictor();\n\n    /**\n     * handle for setTimeout for next eviction run\n     * @type {(number|null)}\n     */\n    this._scheduledEviction = null;\n\n    // create initial resources (if factory.min > 0)\n    if (this._config.autostart === true) {\n      this.start();\n    }\n  }\n\n  _destroy(pooledResource) {\n    // FIXME: do we need another state for \"in destruction\"?\n    pooledResource.invalidate();\n    this._allObjects.delete(pooledResource);\n    // NOTE: this maybe very bad promise usage?\n    const destroyPromise = this._factory.destroy(pooledResource.obj);\n    const wrappedDestroyPromise = this._Promise.resolve(destroyPromise);\n\n    this._trackOperation(\n      wrappedDestroyPromise,\n      this._factoryDestroyOperations\n    ).catch(reason => {\n      this.emit(FACTORY_DESTROY_ERROR, reason);\n    });\n\n    // TODO: maybe ensuring minimum pool size should live outside here\n    this._ensureMinimum();\n  }\n\n  /**\n   * Attempt to move an available resource into test and then onto a waiting client\n   * @return {Boolean} could we move an available resource into test\n   */\n  _testOnBorrow() {\n    if (this._availableObjects.length < 1) {\n      return false;\n    }\n\n    const pooledResource = this._availableObjects.shift();\n    // Mark the resource as in test\n    pooledResource.test();\n    this._testOnBorrowResources.add(pooledResource);\n    const validationPromise = this._factory.validate(pooledResource.obj);\n    const wrappedValidationPromise = this._Promise.resolve(validationPromise);\n\n    this._trackOperation(\n      wrappedValidationPromise,\n      this._validationOperations\n    ).then(isValid => {\n      this._testOnBorrowResources.delete(pooledResource);\n\n      if (isValid === false) {\n        pooledResource.invalidate();\n        this._destroy(pooledResource);\n        this._dispense();\n        return;\n      }\n      this._dispatchPooledResourceToNextWaitingClient(pooledResource);\n    });\n\n    return true;\n  }\n\n  /**\n   * Attempt to move an available resource to a waiting client\n   * @return {Boolean} [description]\n   */\n  _dispatchResource() {\n    if (this._availableObjects.length < 1) {\n      return false;\n    }\n\n    const pooledResource = this._availableObjects.shift();\n    this._dispatchPooledResourceToNextWaitingClient(pooledResource);\n    return false;\n  }\n\n  /**\n   * Attempt to resolve an outstanding resource request using an available resource from\n   * the pool, or creating new ones\n   *\n   * @private\n   */\n  _dispense() {\n    /**\n     * Local variables for ease of reading/writing\n     * these don't (shouldn't) change across the execution of this fn\n     */\n    const numWaitingClients = this._waitingClientsQueue.length;\n\n    // If there aren't any waiting requests then there is nothing to do\n    // so lets short-circuit\n    if (numWaitingClients < 1) {\n      return;\n    }\n\n    const resourceShortfall =\n      numWaitingClients - this._potentiallyAllocableResourceCount;\n\n    const actualNumberOfResourcesToCreate = Math.min(\n      this.spareResourceCapacity,\n      resourceShortfall\n    );\n    for (let i = 0; actualNumberOfResourcesToCreate > i; i++) {\n      this._createResource();\n    }\n\n    // If we are doing test-on-borrow see how many more resources need to be moved into test\n    // to help satisfy waitingClients\n    if (this._config.testOnBorrow === true) {\n      // how many available resources do we need to shift into test\n      const desiredNumberOfResourcesToMoveIntoTest =\n        numWaitingClients - this._testOnBorrowResources.size;\n      const actualNumberOfResourcesToMoveIntoTest = Math.min(\n        this._availableObjects.length,\n        desiredNumberOfResourcesToMoveIntoTest\n      );\n      for (let i = 0; actualNumberOfResourcesToMoveIntoTest > i; i++) {\n        this._testOnBorrow();\n      }\n    }\n\n    // if we aren't testing-on-borrow then lets try to allocate what we can\n    if (this._config.testOnBorrow === false) {\n      const actualNumberOfResourcesToDispatch = Math.min(\n        this._availableObjects.length,\n        numWaitingClients\n      );\n      for (let i = 0; actualNumberOfResourcesToDispatch > i; i++) {\n        this._dispatchResource();\n      }\n    }\n  }\n\n  /**\n   * Dispatches a pooledResource to the next waiting client (if any) else\n   * puts the PooledResource back on the available list\n   * @param  {PooledResource} pooledResource [description]\n   * @return {Boolean}                [description]\n   */\n  _dispatchPooledResourceToNextWaitingClient(pooledResource) {\n    const clientResourceRequest = this._waitingClientsQueue.dequeue();\n    if (\n      clientResourceRequest === undefined ||\n      clientResourceRequest.state !== Deferred.PENDING\n    ) {\n      // While we were away either all the waiting clients timed out\n      // or were somehow fulfilled. put our pooledResource back.\n      this._addPooledResourceToAvailableObjects(pooledResource);\n      // TODO: do need to trigger anything before we leave?\n      return false;\n    }\n    const loan = new ResourceLoan(pooledResource, this._Promise);\n    this._resourceLoans.set(pooledResource.obj, loan);\n    pooledResource.allocate();\n    clientResourceRequest.resolve(pooledResource.obj);\n    return true;\n  }\n\n  /**\n   * tracks on operation using given set\n   * handles adding/removing from the set and resolve/rejects the value/reason\n   * @param  {Promise} operation\n   * @param  {Set} set       Set holding operations\n   * @return {Promise}       Promise that resolves once operation has been removed from set\n   */\n  _trackOperation(operation, set) {\n    set.add(operation);\n\n    return operation.then(\n      v => {\n        set.delete(operation);\n        return this._Promise.resolve(v);\n      },\n      e => {\n        set.delete(operation);\n        return this._Promise.reject(e);\n      }\n    );\n  }\n\n  /**\n   * @private\n   */\n  _createResource() {\n    // An attempt to create a resource\n    const factoryPromise = this._factory.create();\n    const wrappedFactoryPromise = this._Promise\n      .resolve(factoryPromise)\n      .then(resource => {\n        const pooledResource = new PooledResource(resource);\n        this._allObjects.add(pooledResource);\n        this._addPooledResourceToAvailableObjects(pooledResource);\n      });\n\n    this._trackOperation(wrappedFactoryPromise, this._factoryCreateOperations)\n      .then(() => {\n        this._dispense();\n        // Stop bluebird complaining about this side-effect only handler\n        // - a promise was created in a handler but was not returned from it\n        // https://goo.gl/rRqMUw\n        return null;\n      })\n      .catch(reason => {\n        this.emit(FACTORY_CREATE_ERROR, reason);\n        this._dispense();\n      });\n  }\n\n  /**\n   * @private\n   */\n  _ensureMinimum() {\n    if (this._draining === true) {\n      return;\n    }\n    const minShortfall = this._config.min - this._count;\n    for (let i = 0; i < minShortfall; i++) {\n      this._createResource();\n    }\n  }\n\n  _evict() {\n    const testsToRun = Math.min(\n      this._config.numTestsPerEvictionRun,\n      this._availableObjects.length\n    );\n    const evictionConfig = {\n      softIdleTimeoutMillis: this._config.softIdleTimeoutMillis,\n      idleTimeoutMillis: this._config.idleTimeoutMillis,\n      min: this._config.min\n    };\n    for (let testsHaveRun = 0; testsHaveRun < testsToRun; ) {\n      const iterationResult = this._evictionIterator.next();\n\n      // Safety check incase we could get stuck in infinite loop because we\n      // somehow emptied the array after chekcing it's length\n      if (iterationResult.done === true && this._availableObjects.length < 1) {\n        this._evictionIterator.reset();\n        return;\n      }\n      // if this happens it should just mean we reached the end of the\n      // list and can reset the cursor.\n      if (iterationResult.done === true && this._availableObjects.length > 0) {\n        this._evictionIterator.reset();\n        continue;\n      }\n\n      const resource = iterationResult.value;\n\n      const shouldEvict = this._evictor.evict(\n        evictionConfig,\n        resource,\n        this._availableObjects.length\n      );\n      testsHaveRun++;\n\n      if (shouldEvict === true) {\n        // take it out of the _availableObjects list\n        this._evictionIterator.remove();\n        this._destroy(resource);\n      }\n    }\n  }\n\n  _scheduleEvictorRun() {\n    // Start eviction if set\n    if (this._config.evictionRunIntervalMillis > 0) {\n      // @ts-ignore\n      this._scheduledEviction = setTimeout(() => {\n        this._evict();\n        this._scheduleEvictorRun();\n      }, this._config.evictionRunIntervalMillis);\n    }\n  }\n\n  _descheduleEvictorRun() {\n    if (this._scheduledEviction) {\n      clearTimeout(this._scheduledEviction);\n    }\n    this._scheduledEviction = null;\n  }\n\n  start() {\n    if (this._draining === true) {\n      return;\n    }\n    if (this._started === true) {\n      return;\n    }\n    this._started = true;\n    this._scheduleEvictorRun();\n    this._ensureMinimum();\n  }\n\n  /**\n   * Request a new resource. The callback will be called,\n   * when a new resource is available, passing the resource to the callback.\n   * TODO: should we add a seperate \"acquireWithPriority\" function\n   *\n   * @param {Number} [priority=0]\n   *   Optional.  Integer between 0 and (priorityRange - 1).  Specifies the priority\n   *   of the caller if there are no available resources.  Lower numbers mean higher\n   *   priority.\n   *\n   * @returns {Promise}\n   */\n  acquire(priority) {\n    if (this._started === false && this._config.autostart === false) {\n      this.start();\n    }\n\n    if (this._draining) {\n      return this._Promise.reject(\n        new Error(\"pool is draining and cannot accept work\")\n      );\n    }\n\n    // TODO: should we defer this check till after this event loop incase \"the situation\" changes in the meantime\n    if (\n      this.spareResourceCapacity < 1 &&\n      this._availableObjects.length < 1 &&\n      this._config.maxWaitingClients !== undefined &&\n      this._waitingClientsQueue.length >= this._config.maxWaitingClients\n    ) {\n      return this._Promise.reject(\n        new Error(\"max waitingClients count exceeded\")\n      );\n    }\n\n    const resourceRequest = new ResourceRequest(\n      this._config.acquireTimeoutMillis,\n      this._Promise\n    );\n    this._waitingClientsQueue.enqueue(resourceRequest, priority);\n    this._dispense();\n\n    return resourceRequest.promise;\n  }\n\n  /**\n   * [use method, aquires a resource, passes the resource to a user supplied function and releases it]\n   * @param  {Function} fn [a function that accepts a resource and returns a promise that resolves/rejects once it has finished using the resource]\n   * @return {Promise}      [resolves once the resource is released to the pool]\n   */\n  use(fn) {\n    return this.acquire().then(resource => {\n      return fn(resource).then(\n        result => {\n          this.release(resource);\n          return result;\n        },\n        err => {\n          this.destroy(resource);\n          throw err;\n        }\n      );\n    });\n  }\n\n  /**\n   * Check if resource is currently on loan from the pool\n   *\n   * @param {Function} resource\n   *    Resource for checking.\n   *\n   * @returns {Boolean}\n   *  True if resource belongs to this pool and false otherwise\n   */\n  isBorrowedResource(resource) {\n    return this._resourceLoans.has(resource);\n  }\n\n  /**\n   * Return the resource to the pool when it is no longer required.\n   *\n   * @param {Object} resource\n   *   The acquired object to be put back to the pool.\n   */\n  release(resource) {\n    // check for an outstanding loan\n    const loan = this._resourceLoans.get(resource);\n\n    if (loan === undefined) {\n      return this._Promise.reject(\n        new Error(\"Resource not currently part of this pool\")\n      );\n    }\n\n    this._resourceLoans.delete(resource);\n    loan.resolve();\n    const pooledResource = loan.pooledResource;\n\n    pooledResource.deallocate();\n    this._addPooledResourceToAvailableObjects(pooledResource);\n\n    this._dispense();\n    return this._Promise.resolve();\n  }\n\n  /**\n   * Request the resource to be destroyed. The factory's destroy handler\n   * will also be called.\n   *\n   * This should be called within an acquire() block as an alternative to release().\n   *\n   * @param {Object} resource\n   *   The acquired resource to be destoyed.\n   */\n  destroy(resource) {\n    // check for an outstanding loan\n    const loan = this._resourceLoans.get(resource);\n\n    if (loan === undefined) {\n      return this._Promise.reject(\n        new Error(\"Resource not currently part of this pool\")\n      );\n    }\n\n    this._resourceLoans.delete(resource);\n    loan.resolve();\n    const pooledResource = loan.pooledResource;\n\n    pooledResource.deallocate();\n    this._destroy(pooledResource);\n\n    this._dispense();\n    return this._Promise.resolve();\n  }\n\n  _addPooledResourceToAvailableObjects(pooledResource) {\n    pooledResource.idle();\n    if (this._config.fifo === true) {\n      this._availableObjects.push(pooledResource);\n    } else {\n      this._availableObjects.unshift(pooledResource);\n    }\n  }\n\n  /**\n   * Disallow any new acquire calls and let the request backlog dissapate.\n   * The Pool will no longer attempt to maintain a \"min\" number of resources\n   * and will only make new resources on demand.\n   * Resolves once all resource requests are fulfilled and all resources are returned to pool and available...\n   * Should probably be called \"drain work\"\n   * @returns {Promise}\n   */\n  drain() {\n    this._draining = true;\n    return this.__allResourceRequestsSettled()\n      .then(() => {\n        return this.__allResourcesReturned();\n      })\n      .then(() => {\n        this._descheduleEvictorRun();\n      });\n  }\n\n  __allResourceRequestsSettled() {\n    if (this._waitingClientsQueue.length > 0) {\n      // wait for last waiting client to be settled\n      // FIXME: what if they can \"resolve\" out of order....?\n      return reflector(this._waitingClientsQueue.tail.promise);\n    }\n    return this._Promise.resolve();\n  }\n\n  // FIXME: this is a horrific mess\n  __allResourcesReturned() {\n    const ps = Array.from(this._resourceLoans.values())\n      .map(loan => loan.promise)\n      .map(reflector);\n    return this._Promise.all(ps);\n  }\n\n  /**\n   * Forcibly destroys all available resources regardless of timeout.  Intended to be\n   * invoked as part of a drain.  Does not prevent the creation of new\n   * resources as a result of subsequent calls to acquire.\n   *\n   * Note that if factory.min > 0 and the pool isn't \"draining\", the pool will destroy all idle resources\n   * in the pool, but replace them with newly created resources up to the\n   * specified factory.min value.  If this is not desired, set factory.min\n   * to zero before calling clear()\n   *\n   */\n  clear() {\n    const reflectedCreatePromises = Array.from(\n      this._factoryCreateOperations\n    ).map(reflector);\n\n    // wait for outstanding factory.create to complete\n    return this._Promise.all(reflectedCreatePromises).then(() => {\n      // Destroy existing resources\n      // @ts-ignore\n      for (const resource of this._availableObjects) {\n        this._destroy(resource);\n      }\n      const reflectedDestroyPromises = Array.from(\n        this._factoryDestroyOperations\n      ).map(reflector);\n      return reflector(this._Promise.all(reflectedDestroyPromises));\n    });\n  }\n\n  /**\n   * How many resources are available to allocated\n   * (includes resources that have not been tested and may faul validation)\n   * NOTE: internal for now as the name is awful and might not be useful to anyone\n   * @return {Number} number of resources the pool has to allocate\n   */\n  get _potentiallyAllocableResourceCount() {\n    return (\n      this._availableObjects.length +\n      this._testOnBorrowResources.size +\n      this._testOnReturnResources.size +\n      this._factoryCreateOperations.size\n    );\n  }\n\n  /**\n   * The combined count of the currently created objects and those in the\n   * process of being created\n   * Does NOT include resources in the process of being destroyed\n   * sort of legacy...\n   * @return {Number}\n   */\n  get _count() {\n    return this._allObjects.size + this._factoryCreateOperations.size;\n  }\n\n  /**\n   * How many more resources does the pool have room for\n   * @return {Number} number of resources the pool could create before hitting any limits\n   */\n  get spareResourceCapacity() {\n    return (\n      this._config.max -\n      (this._allObjects.size + this._factoryCreateOperations.size)\n    );\n  }\n\n  /**\n   * see _count above\n   * @return {Number} [description]\n   */\n  get size() {\n    return this._count;\n  }\n\n  /**\n   * number of available resources\n   * @return {Number} [description]\n   */\n  get available() {\n    return this._availableObjects.length;\n  }\n\n  /**\n   * number of resources that are currently acquired\n   * @return {Number} [description]\n   */\n  get borrowed() {\n    return this._resourceLoans.size;\n  }\n\n  /**\n   * number of waiting acquire calls\n   * @return {Number} [description]\n   */\n  get pending() {\n    return this._waitingClientsQueue.length;\n  }\n\n  /**\n   * maximum size of the pool\n   * @return {Number} [description]\n   */\n  get max() {\n    return this._config.max;\n  }\n\n  /**\n   * minimum size of the pool\n   * @return {Number} [description]\n   */\n  get min() {\n    return this._config.min;\n  }\n}\n\nmodule.exports = Pool;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}