{"ast":null,"code":"\"use strict\";\n/**\n * Creates an interator for a DoublyLinkedList starting at the given node\n * It's internal cursor will remains relative to the last \"iterated\" node as that\n * node moves through the list until it either iterates to the end of the list,\n * or the the node it's tracking is removed from the list. Until the first 'next'\n * call it tracks the head/tail of the linked list. This means that one can create\n * an iterator on an empty list, then add nodes, and then the iterator will follow\n * those nodes. Because the DoublyLinkedList nodes don't track their owning \"list\" and\n * it's highly inefficient to walk the list for every iteration, the iterator won't know\n * if the node has been detached from one List and added to another list, or if the iterator\n *\n * The created object is an es6 compatible iterator\n */\n\nclass DoublyLinkedListIterator {\n  /**\n   * @param  {Object} doublyLinkedList     a node that is part of a doublyLinkedList\n   * @param  {Boolean} [reverse=false]     is this a reverse iterator? default: false\n   */\n  constructor(doublyLinkedList, reverse) {\n    this._list = doublyLinkedList; // NOTE: these key names are tied to the DoublyLinkedListIterator\n\n    this._direction = reverse === true ? \"prev\" : \"next\";\n    this._startPosition = reverse === true ? \"tail\" : \"head\";\n    this._started = false;\n    this._cursor = null;\n    this._done = false;\n  }\n\n  _start() {\n    this._cursor = this._list[this._startPosition];\n    this._started = true;\n  }\n\n  _advanceCursor() {\n    if (this._started === false) {\n      this._started = true;\n      this._cursor = this._list[this._startPosition];\n      return;\n    }\n\n    this._cursor = this._cursor[this._direction];\n  }\n\n  reset() {\n    this._done = false;\n    this._started = false;\n    this._cursor = null;\n  }\n\n  remove() {\n    if (this._started === false || this._done === true || this._isCursorDetached()) {\n      return false;\n    }\n\n    this._list.remove(this._cursor);\n  }\n\n  next() {\n    if (this._done === true) {\n      return {\n        done: true\n      };\n    }\n\n    this._advanceCursor(); // if there is no node at the cursor or the node at the cursor is no longer part of\n    // a doubly linked list then we are done/finished/kaput\n\n\n    if (this._cursor === null || this._isCursorDetached()) {\n      this._done = true;\n      return {\n        done: true\n      };\n    }\n\n    return {\n      value: this._cursor,\n      done: false\n    };\n  }\n  /**\n   * Is the node detached from a list?\n   * NOTE: you can trick/bypass/confuse this check by removing a node from one DoublyLinkedList\n   * and adding it to another.\n   * TODO: We can make this smarter by checking the direction of travel and only checking\n   * the required next/prev/head/tail rather than all of them\n   * @return {Boolean}      [description]\n   */\n\n\n  _isCursorDetached() {\n    return this._cursor.prev === null && this._cursor.next === null && this._list.tail !== this._cursor && this._list.head !== this._cursor;\n  }\n\n}\n\nmodule.exports = DoublyLinkedListIterator;","map":{"version":3,"names":["DoublyLinkedListIterator","constructor","doublyLinkedList","reverse","_list","_direction","_startPosition","_started","_cursor","_done","_start","_advanceCursor","reset","remove","_isCursorDetached","next","done","value","prev","tail","head","module","exports"],"sources":["C:/Users/Administrator/Desktop/webAPI work/web/dog-website/node_modules/generic-pool/lib/DoublyLinkedListIterator.js"],"sourcesContent":["\"use strict\";\n\n/**\n * Creates an interator for a DoublyLinkedList starting at the given node\n * It's internal cursor will remains relative to the last \"iterated\" node as that\n * node moves through the list until it either iterates to the end of the list,\n * or the the node it's tracking is removed from the list. Until the first 'next'\n * call it tracks the head/tail of the linked list. This means that one can create\n * an iterator on an empty list, then add nodes, and then the iterator will follow\n * those nodes. Because the DoublyLinkedList nodes don't track their owning \"list\" and\n * it's highly inefficient to walk the list for every iteration, the iterator won't know\n * if the node has been detached from one List and added to another list, or if the iterator\n *\n * The created object is an es6 compatible iterator\n */\nclass DoublyLinkedListIterator {\n  /**\n   * @param  {Object} doublyLinkedList     a node that is part of a doublyLinkedList\n   * @param  {Boolean} [reverse=false]     is this a reverse iterator? default: false\n   */\n  constructor(doublyLinkedList, reverse) {\n    this._list = doublyLinkedList;\n    // NOTE: these key names are tied to the DoublyLinkedListIterator\n    this._direction = reverse === true ? \"prev\" : \"next\";\n    this._startPosition = reverse === true ? \"tail\" : \"head\";\n    this._started = false;\n    this._cursor = null;\n    this._done = false;\n  }\n\n  _start() {\n    this._cursor = this._list[this._startPosition];\n    this._started = true;\n  }\n\n  _advanceCursor() {\n    if (this._started === false) {\n      this._started = true;\n      this._cursor = this._list[this._startPosition];\n      return;\n    }\n    this._cursor = this._cursor[this._direction];\n  }\n\n  reset() {\n    this._done = false;\n    this._started = false;\n    this._cursor = null;\n  }\n\n  remove() {\n    if (\n      this._started === false ||\n      this._done === true ||\n      this._isCursorDetached()\n    ) {\n      return false;\n    }\n    this._list.remove(this._cursor);\n  }\n\n  next() {\n    if (this._done === true) {\n      return { done: true };\n    }\n\n    this._advanceCursor();\n\n    // if there is no node at the cursor or the node at the cursor is no longer part of\n    // a doubly linked list then we are done/finished/kaput\n    if (this._cursor === null || this._isCursorDetached()) {\n      this._done = true;\n      return { done: true };\n    }\n\n    return {\n      value: this._cursor,\n      done: false\n    };\n  }\n\n  /**\n   * Is the node detached from a list?\n   * NOTE: you can trick/bypass/confuse this check by removing a node from one DoublyLinkedList\n   * and adding it to another.\n   * TODO: We can make this smarter by checking the direction of travel and only checking\n   * the required next/prev/head/tail rather than all of them\n   * @return {Boolean}      [description]\n   */\n  _isCursorDetached() {\n    return (\n      this._cursor.prev === null &&\n      this._cursor.next === null &&\n      this._list.tail !== this._cursor &&\n      this._list.head !== this._cursor\n    );\n  }\n}\n\nmodule.exports = DoublyLinkedListIterator;\n"],"mappings":"AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,MAAMA,wBAAN,CAA+B;EAC7B;AACF;AACA;AACA;EACEC,WAAW,CAACC,gBAAD,EAAmBC,OAAnB,EAA4B;IACrC,KAAKC,KAAL,GAAaF,gBAAb,CADqC,CAErC;;IACA,KAAKG,UAAL,GAAkBF,OAAO,KAAK,IAAZ,GAAmB,MAAnB,GAA4B,MAA9C;IACA,KAAKG,cAAL,GAAsBH,OAAO,KAAK,IAAZ,GAAmB,MAAnB,GAA4B,MAAlD;IACA,KAAKI,QAAL,GAAgB,KAAhB;IACA,KAAKC,OAAL,GAAe,IAAf;IACA,KAAKC,KAAL,GAAa,KAAb;EACD;;EAEDC,MAAM,GAAG;IACP,KAAKF,OAAL,GAAe,KAAKJ,KAAL,CAAW,KAAKE,cAAhB,CAAf;IACA,KAAKC,QAAL,GAAgB,IAAhB;EACD;;EAEDI,cAAc,GAAG;IACf,IAAI,KAAKJ,QAAL,KAAkB,KAAtB,EAA6B;MAC3B,KAAKA,QAAL,GAAgB,IAAhB;MACA,KAAKC,OAAL,GAAe,KAAKJ,KAAL,CAAW,KAAKE,cAAhB,CAAf;MACA;IACD;;IACD,KAAKE,OAAL,GAAe,KAAKA,OAAL,CAAa,KAAKH,UAAlB,CAAf;EACD;;EAEDO,KAAK,GAAG;IACN,KAAKH,KAAL,GAAa,KAAb;IACA,KAAKF,QAAL,GAAgB,KAAhB;IACA,KAAKC,OAAL,GAAe,IAAf;EACD;;EAEDK,MAAM,GAAG;IACP,IACE,KAAKN,QAAL,KAAkB,KAAlB,IACA,KAAKE,KAAL,KAAe,IADf,IAEA,KAAKK,iBAAL,EAHF,EAIE;MACA,OAAO,KAAP;IACD;;IACD,KAAKV,KAAL,CAAWS,MAAX,CAAkB,KAAKL,OAAvB;EACD;;EAEDO,IAAI,GAAG;IACL,IAAI,KAAKN,KAAL,KAAe,IAAnB,EAAyB;MACvB,OAAO;QAAEO,IAAI,EAAE;MAAR,CAAP;IACD;;IAED,KAAKL,cAAL,GALK,CAOL;IACA;;;IACA,IAAI,KAAKH,OAAL,KAAiB,IAAjB,IAAyB,KAAKM,iBAAL,EAA7B,EAAuD;MACrD,KAAKL,KAAL,GAAa,IAAb;MACA,OAAO;QAAEO,IAAI,EAAE;MAAR,CAAP;IACD;;IAED,OAAO;MACLC,KAAK,EAAE,KAAKT,OADP;MAELQ,IAAI,EAAE;IAFD,CAAP;EAID;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;;EACEF,iBAAiB,GAAG;IAClB,OACE,KAAKN,OAAL,CAAaU,IAAb,KAAsB,IAAtB,IACA,KAAKV,OAAL,CAAaO,IAAb,KAAsB,IADtB,IAEA,KAAKX,KAAL,CAAWe,IAAX,KAAoB,KAAKX,OAFzB,IAGA,KAAKJ,KAAL,CAAWgB,IAAX,KAAoB,KAAKZ,OAJ3B;EAMD;;AAjF4B;;AAoF/Ba,MAAM,CAACC,OAAP,GAAiBtB,wBAAjB"},"metadata":{},"sourceType":"script"}