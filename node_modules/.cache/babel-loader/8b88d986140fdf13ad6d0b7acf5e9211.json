{"ast":null,"code":"'use strict';\n\nconst retrieveBSON = require('./connection/utils').retrieveBSON;\n\nconst EventEmitter = require('events');\n\nconst BSON = retrieveBSON();\nconst Binary = BSON.Binary;\n\nconst uuidV4 = require('./utils').uuidV4;\n\nconst MongoError = require('./error').MongoError;\n\nconst isRetryableError = require('././error').isRetryableError;\n\nconst MongoNetworkError = require('./error').MongoNetworkError;\n\nconst MongoWriteConcernError = require('./error').MongoWriteConcernError;\n\nconst Transaction = require('./transactions').Transaction;\n\nconst TxnState = require('./transactions').TxnState;\n\nconst isPromiseLike = require('./utils').isPromiseLike;\n\nconst ReadPreference = require('./topologies/read_preference');\n\nconst maybePromise = require('../utils').maybePromise;\n\nconst isTransactionCommand = require('./transactions').isTransactionCommand;\n\nconst resolveClusterTime = require('./topologies/shared').resolveClusterTime;\n\nconst isSharded = require('./wireprotocol/shared').isSharded;\n\nconst maxWireVersion = require('./utils').maxWireVersion;\n\nconst now = require('./../utils').now;\n\nconst calculateDurationInMs = require('./../utils').calculateDurationInMs;\n\nconst minWireVersionForShardedTransactions = 8;\n\nfunction assertAlive(session, callback) {\n  if (session.serverSession == null) {\n    const error = new MongoError('Cannot use a session that has ended');\n\n    if (typeof callback === 'function') {\n      callback(error, null);\n      return false;\n    }\n\n    throw error;\n  }\n\n  return true;\n}\n/**\n * Options to pass when creating a Client Session\n * @typedef {Object} SessionOptions\n * @property {boolean} [causalConsistency=true] Whether causal consistency should be enabled on this session\n * @property {TransactionOptions} [defaultTransactionOptions] The default TransactionOptions to use for transactions started on this session.\n */\n\n/**\n * A BSON document reflecting the lsid of a {@link ClientSession}\n * @typedef {Object} SessionId\n */\n\n\nconst kServerSession = Symbol('serverSession');\n/**\n * A class representing a client session on the server\n * WARNING: not meant to be instantiated directly.\n * @class\n * @hideconstructor\n */\n\nclass ClientSession extends EventEmitter {\n  /**\n   * Create a client session.\n   * WARNING: not meant to be instantiated directly\n   *\n   * @param {Topology} topology The current client's topology (Internal Class)\n   * @param {ServerSessionPool} sessionPool The server session pool (Internal Class)\n   * @param {SessionOptions} [options] Optional settings\n   * @param {Object} [clientOptions] Optional settings provided when creating a client in the porcelain driver\n   */\n  constructor(topology, sessionPool, options, clientOptions) {\n    super();\n\n    if (topology == null) {\n      throw new Error('ClientSession requires a topology');\n    }\n\n    if (sessionPool == null || !(sessionPool instanceof ServerSessionPool)) {\n      throw new Error('ClientSession requires a ServerSessionPool');\n    }\n\n    options = options || {};\n    clientOptions = clientOptions || {};\n    this.topology = topology;\n    this.sessionPool = sessionPool;\n    this.hasEnded = false;\n    this.clientOptions = clientOptions;\n    this[kServerSession] = undefined;\n    this.supports = {\n      causalConsistency: typeof options.causalConsistency !== 'undefined' ? options.causalConsistency : true\n    };\n    this.clusterTime = options.initialClusterTime;\n    this.operationTime = null;\n    this.explicit = !!options.explicit;\n    this.owner = options.owner;\n    this.defaultTransactionOptions = Object.assign({}, options.defaultTransactionOptions);\n    this.transaction = new Transaction();\n  }\n  /**\n   * The server id associated with this session\n   * @type {SessionId}\n   */\n\n\n  get id() {\n    return this.serverSession.id;\n  }\n\n  get serverSession() {\n    if (this[kServerSession] == null) {\n      this[kServerSession] = this.sessionPool.acquire();\n    }\n\n    return this[kServerSession];\n  }\n  /**\n   * Ends this session on the server\n   *\n   * @param {Object} [options] Optional settings. Currently reserved for future use\n   * @param {Function} [callback] Optional callback for completion of this operation\n   */\n\n\n  endSession(options, callback) {\n    if (typeof options === 'function') callback = options, options = {};\n    options = options || {};\n    const session = this;\n    return maybePromise(this, callback, done => {\n      if (session.hasEnded) {\n        return done();\n      }\n\n      function completeEndSession() {\n        // release the server session back to the pool\n        session.sessionPool.release(session.serverSession);\n        session[kServerSession] = undefined; // mark the session as ended, and emit a signal\n\n        session.hasEnded = true;\n        session.emit('ended', session); // spec indicates that we should ignore all errors for `endSessions`\n\n        done();\n      }\n\n      if (session.serverSession && session.inTransaction()) {\n        session.abortTransaction(err => {\n          if (err) return done(err);\n          completeEndSession();\n        });\n        return;\n      }\n\n      completeEndSession();\n    });\n  }\n  /**\n   * Advances the operationTime for a ClientSession.\n   *\n   * @param {Timestamp} operationTime the `BSON.Timestamp` of the operation type it is desired to advance to\n   */\n\n\n  advanceOperationTime(operationTime) {\n    if (this.operationTime == null) {\n      this.operationTime = operationTime;\n      return;\n    }\n\n    if (operationTime.greaterThan(this.operationTime)) {\n      this.operationTime = operationTime;\n    }\n  }\n  /**\n   * Used to determine if this session equals another\n   * @param {ClientSession} session\n   * @return {boolean} true if the sessions are equal\n   */\n\n\n  equals(session) {\n    if (!(session instanceof ClientSession)) {\n      return false;\n    }\n\n    return this.id.id.buffer.equals(session.id.id.buffer);\n  }\n  /**\n   * Increment the transaction number on the internal ServerSession\n   */\n\n\n  incrementTransactionNumber() {\n    this.serverSession.txnNumber++;\n  }\n  /**\n   * @returns {boolean} whether this session is currently in a transaction or not\n   */\n\n\n  inTransaction() {\n    return this.transaction.isActive;\n  }\n  /**\n   * Starts a new transaction with the given options.\n   *\n   * @param {TransactionOptions} options Options for the transaction\n   */\n\n\n  startTransaction(options) {\n    assertAlive(this);\n\n    if (this.inTransaction()) {\n      throw new MongoError('Transaction already in progress');\n    }\n\n    const topologyMaxWireVersion = maxWireVersion(this.topology);\n\n    if (isSharded(this.topology) && topologyMaxWireVersion != null && topologyMaxWireVersion < minWireVersionForShardedTransactions) {\n      throw new MongoError('Transactions are not supported on sharded clusters in MongoDB < 4.2.');\n    } // increment txnNumber\n\n\n    this.incrementTransactionNumber(); // create transaction state\n\n    this.transaction = new Transaction(Object.assign({}, this.clientOptions, options || this.defaultTransactionOptions));\n    this.transaction.transition(TxnState.STARTING_TRANSACTION);\n  }\n  /**\n   * Commits the currently active transaction in this session.\n   *\n   * @param {Function} [callback] optional callback for completion of this operation\n   * @return {Promise} A promise is returned if no callback is provided\n   */\n\n\n  commitTransaction(callback) {\n    return maybePromise(this, callback, done => endTransaction(this, 'commitTransaction', done));\n  }\n  /**\n   * Aborts the currently active transaction in this session.\n   *\n   * @param {Function} [callback] optional callback for completion of this operation\n   * @return {Promise} A promise is returned if no callback is provided\n   */\n\n\n  abortTransaction(callback) {\n    return maybePromise(this, callback, done => endTransaction(this, 'abortTransaction', done));\n  }\n  /**\n   * This is here to ensure that ClientSession is never serialized to BSON.\n   * @ignore\n   */\n\n\n  toBSON() {\n    throw new Error('ClientSession cannot be serialized to BSON.');\n  }\n  /**\n   * A user provided function to be run within a transaction\n   *\n   * @callback WithTransactionCallback\n   * @param {ClientSession} session The parent session of the transaction running the operation. This should be passed into each operation within the lambda.\n   * @returns {Promise} The resulting Promise of operations run within this transaction\n   */\n\n  /**\n   * Runs a provided lambda within a transaction, retrying either the commit operation\n   * or entire transaction as needed (and when the error permits) to better ensure that\n   * the transaction can complete successfully.\n   *\n   * IMPORTANT: This method requires the user to return a Promise, all lambdas that do not\n   * return a Promise will result in undefined behavior.\n   *\n   * @param {WithTransactionCallback} fn\n   * @param {TransactionOptions} [options] Optional settings for the transaction\n   */\n\n\n  withTransaction(fn, options) {\n    const startTime = now();\n    return attemptTransaction(this, startTime, fn, options);\n  }\n\n}\n\nconst MAX_WITH_TRANSACTION_TIMEOUT = 120000;\nconst UNSATISFIABLE_WRITE_CONCERN_CODE = 100;\nconst UNKNOWN_REPL_WRITE_CONCERN_CODE = 79;\nconst MAX_TIME_MS_EXPIRED_CODE = 50;\nconst NON_DETERMINISTIC_WRITE_CONCERN_ERRORS = new Set(['CannotSatisfyWriteConcern', 'UnknownReplWriteConcern', 'UnsatisfiableWriteConcern']);\n\nfunction hasNotTimedOut(startTime, max) {\n  return calculateDurationInMs(startTime) < max;\n}\n\nfunction isUnknownTransactionCommitResult(err) {\n  return isMaxTimeMSExpiredError(err) || !NON_DETERMINISTIC_WRITE_CONCERN_ERRORS.has(err.codeName) && err.code !== UNSATISFIABLE_WRITE_CONCERN_CODE && err.code !== UNKNOWN_REPL_WRITE_CONCERN_CODE;\n}\n\nfunction isMaxTimeMSExpiredError(err) {\n  if (err == null) return false;\n  return err.code === MAX_TIME_MS_EXPIRED_CODE || err.writeConcernError && err.writeConcernError.code === MAX_TIME_MS_EXPIRED_CODE;\n}\n\nfunction attemptTransactionCommit(session, startTime, fn, options) {\n  return session.commitTransaction().catch(err => {\n    if (err instanceof MongoError && hasNotTimedOut(startTime, MAX_WITH_TRANSACTION_TIMEOUT) && !isMaxTimeMSExpiredError(err)) {\n      if (err.hasErrorLabel('UnknownTransactionCommitResult')) {\n        return attemptTransactionCommit(session, startTime, fn, options);\n      }\n\n      if (err.hasErrorLabel('TransientTransactionError')) {\n        return attemptTransaction(session, startTime, fn, options);\n      }\n    }\n\n    throw err;\n  });\n}\n\nconst USER_EXPLICIT_TXN_END_STATES = new Set([TxnState.NO_TRANSACTION, TxnState.TRANSACTION_COMMITTED, TxnState.TRANSACTION_ABORTED]);\n\nfunction userExplicitlyEndedTransaction(session) {\n  return USER_EXPLICIT_TXN_END_STATES.has(session.transaction.state);\n}\n\nfunction attemptTransaction(session, startTime, fn, options) {\n  session.startTransaction(options);\n  let promise;\n\n  try {\n    promise = fn(session);\n  } catch (err) {\n    promise = Promise.reject(err);\n  }\n\n  if (!isPromiseLike(promise)) {\n    session.abortTransaction();\n    throw new TypeError('Function provided to `withTransaction` must return a Promise');\n  }\n\n  return promise.then(() => {\n    if (userExplicitlyEndedTransaction(session)) {\n      return;\n    }\n\n    return attemptTransactionCommit(session, startTime, fn, options);\n  }).catch(err => {\n    function maybeRetryOrThrow(err) {\n      if (err instanceof MongoError && err.hasErrorLabel('TransientTransactionError') && hasNotTimedOut(startTime, MAX_WITH_TRANSACTION_TIMEOUT)) {\n        return attemptTransaction(session, startTime, fn, options);\n      }\n\n      if (isMaxTimeMSExpiredError(err)) {\n        err.addErrorLabel('UnknownTransactionCommitResult');\n      }\n\n      throw err;\n    }\n\n    if (session.transaction.isActive) {\n      return session.abortTransaction().then(() => maybeRetryOrThrow(err));\n    }\n\n    return maybeRetryOrThrow(err);\n  });\n}\n\nfunction endTransaction(session, commandName, callback) {\n  if (!assertAlive(session, callback)) {\n    // checking result in case callback was called\n    return;\n  } // handle any initial problematic cases\n\n\n  let txnState = session.transaction.state;\n\n  if (txnState === TxnState.NO_TRANSACTION) {\n    callback(new MongoError('No transaction started'));\n    return;\n  }\n\n  if (commandName === 'commitTransaction') {\n    if (txnState === TxnState.STARTING_TRANSACTION || txnState === TxnState.TRANSACTION_COMMITTED_EMPTY) {\n      // the transaction was never started, we can safely exit here\n      session.transaction.transition(TxnState.TRANSACTION_COMMITTED_EMPTY);\n      callback(null, null);\n      return;\n    }\n\n    if (txnState === TxnState.TRANSACTION_ABORTED) {\n      callback(new MongoError('Cannot call commitTransaction after calling abortTransaction'));\n      return;\n    }\n  } else {\n    if (txnState === TxnState.STARTING_TRANSACTION) {\n      // the transaction was never started, we can safely exit here\n      session.transaction.transition(TxnState.TRANSACTION_ABORTED);\n      callback(null, null);\n      return;\n    }\n\n    if (txnState === TxnState.TRANSACTION_ABORTED) {\n      callback(new MongoError('Cannot call abortTransaction twice'));\n      return;\n    }\n\n    if (txnState === TxnState.TRANSACTION_COMMITTED || txnState === TxnState.TRANSACTION_COMMITTED_EMPTY) {\n      callback(new MongoError('Cannot call abortTransaction after calling commitTransaction'));\n      return;\n    }\n  } // construct and send the command\n\n\n  const command = {\n    [commandName]: 1\n  }; // apply a writeConcern if specified\n\n  let writeConcern;\n\n  if (session.transaction.options.writeConcern) {\n    writeConcern = Object.assign({}, session.transaction.options.writeConcern);\n  } else if (session.clientOptions && session.clientOptions.w) {\n    writeConcern = {\n      w: session.clientOptions.w\n    };\n  }\n\n  if (txnState === TxnState.TRANSACTION_COMMITTED) {\n    writeConcern = Object.assign({\n      wtimeout: 10000\n    }, writeConcern, {\n      w: 'majority'\n    });\n  }\n\n  if (writeConcern) {\n    Object.assign(command, {\n      writeConcern\n    });\n  }\n\n  if (commandName === 'commitTransaction' && session.transaction.options.maxTimeMS) {\n    Object.assign(command, {\n      maxTimeMS: session.transaction.options.maxTimeMS\n    });\n  }\n\n  function commandHandler(e, r) {\n    if (commandName === 'commitTransaction') {\n      session.transaction.transition(TxnState.TRANSACTION_COMMITTED);\n\n      if (e && (e instanceof MongoNetworkError || e instanceof MongoWriteConcernError || isRetryableError(e) || isMaxTimeMSExpiredError(e))) {\n        if (isUnknownTransactionCommitResult(e)) {\n          e.addErrorLabel('UnknownTransactionCommitResult'); // per txns spec, must unpin session in this case\n\n          session.transaction.unpinServer();\n        }\n      }\n    } else {\n      session.transaction.transition(TxnState.TRANSACTION_ABORTED);\n    }\n\n    callback(e, r);\n  } // The spec indicates that we should ignore all errors on `abortTransaction`\n\n\n  function transactionError(err) {\n    return commandName === 'commitTransaction' ? err : null;\n  }\n\n  if ( // Assumption here that commandName is \"commitTransaction\" or \"abortTransaction\"\n  session.transaction.recoveryToken && supportsRecoveryToken(session)) {\n    command.recoveryToken = session.transaction.recoveryToken;\n  } // send the command\n\n\n  session.topology.command('admin.$cmd', command, {\n    session\n  }, (err, reply) => {\n    if (err && isRetryableError(err)) {\n      // SPEC-1185: apply majority write concern when retrying commitTransaction\n      if (command.commitTransaction) {\n        // per txns spec, must unpin session in this case\n        session.transaction.unpinServer();\n        command.writeConcern = Object.assign({\n          wtimeout: 10000\n        }, command.writeConcern, {\n          w: 'majority'\n        });\n      }\n\n      return session.topology.command('admin.$cmd', command, {\n        session\n      }, (_err, _reply) => commandHandler(transactionError(_err), _reply));\n    }\n\n    commandHandler(transactionError(err), reply);\n  });\n}\n\nfunction supportsRecoveryToken(session) {\n  const topology = session.topology;\n  return !!topology.s.options.useRecoveryToken;\n}\n/**\n * Reflects the existence of a session on the server. Can be reused by the session pool.\n * WARNING: not meant to be instantiated directly. For internal use only.\n * @ignore\n */\n\n\nclass ServerSession {\n  constructor() {\n    this.id = {\n      id: new Binary(uuidV4(), Binary.SUBTYPE_UUID)\n    };\n    this.lastUse = now();\n    this.txnNumber = 0;\n    this.isDirty = false;\n  }\n  /**\n   * Determines if the server session has timed out.\n   * @ignore\n   * @param {Date} sessionTimeoutMinutes The server's \"logicalSessionTimeoutMinutes\"\n   * @return {boolean} true if the session has timed out.\n   */\n\n\n  hasTimedOut(sessionTimeoutMinutes) {\n    // Take the difference of the lastUse timestamp and now, which will result in a value in\n    // milliseconds, and then convert milliseconds to minutes to compare to `sessionTimeoutMinutes`\n    const idleTimeMinutes = Math.round(calculateDurationInMs(this.lastUse) % 86400000 % 3600000 / 60000);\n    return idleTimeMinutes > sessionTimeoutMinutes - 1;\n  }\n\n}\n/**\n * Maintains a pool of Server Sessions.\n * For internal use only\n * @ignore\n */\n\n\nclass ServerSessionPool {\n  constructor(topology) {\n    if (topology == null) {\n      throw new Error('ServerSessionPool requires a topology');\n    }\n\n    this.topology = topology;\n    this.sessions = [];\n  }\n  /**\n   * Ends all sessions in the session pool.\n   * @ignore\n   */\n\n\n  endAllPooledSessions(callback) {\n    if (this.sessions.length) {\n      this.topology.endSessions(this.sessions.map(session => session.id), () => {\n        this.sessions = [];\n\n        if (typeof callback === 'function') {\n          callback();\n        }\n      });\n      return;\n    }\n\n    if (typeof callback === 'function') {\n      callback();\n    }\n  }\n  /**\n   * Acquire a Server Session from the pool.\n   * Iterates through each session in the pool, removing any stale sessions\n   * along the way. The first non-stale session found is removed from the\n   * pool and returned. If no non-stale session is found, a new ServerSession\n   * is created.\n   * @ignore\n   * @returns {ServerSession}\n   */\n\n\n  acquire() {\n    const sessionTimeoutMinutes = this.topology.logicalSessionTimeoutMinutes;\n\n    while (this.sessions.length) {\n      const session = this.sessions.shift();\n\n      if (!session.hasTimedOut(sessionTimeoutMinutes)) {\n        return session;\n      }\n    }\n\n    return new ServerSession();\n  }\n  /**\n   * Release a session to the session pool\n   * Adds the session back to the session pool if the session has not timed out yet.\n   * This method also removes any stale sessions from the pool.\n   * @ignore\n   * @param {ServerSession} session The session to release to the pool\n   */\n\n\n  release(session) {\n    const sessionTimeoutMinutes = this.topology.logicalSessionTimeoutMinutes;\n\n    while (this.sessions.length) {\n      const pooledSession = this.sessions[this.sessions.length - 1];\n\n      if (pooledSession.hasTimedOut(sessionTimeoutMinutes)) {\n        this.sessions.pop();\n      } else {\n        break;\n      }\n    }\n\n    if (!session.hasTimedOut(sessionTimeoutMinutes)) {\n      if (session.isDirty) {\n        return;\n      } // otherwise, readd this session to the session pool\n\n\n      this.sessions.unshift(session);\n    }\n  }\n\n} // TODO: this should be codified in command construction\n// @see https://github.com/mongodb/specifications/blob/master/source/read-write-concern/read-write-concern.rst#read-concern\n\n\nfunction commandSupportsReadConcern(command, options) {\n  if (command.aggregate || command.count || command.distinct || command.find || command.parallelCollectionScan || command.geoNear || command.geoSearch) {\n    return true;\n  }\n\n  if (command.mapReduce && options && options.out && (options.out.inline === 1 || options.out === 'inline')) {\n    return true;\n  }\n\n  return false;\n}\n/**\n * Optionally decorate a command with sessions specific keys\n *\n * @ignore\n * @param {ClientSession} session the session tracking transaction state\n * @param {Object} command the command to decorate\n * @param {Object} topology the topology for tracking the cluster time\n * @param {Object} [options] Optional settings passed to calling operation\n * @return {MongoError|null} An error, if some error condition was met\n */\n\n\nfunction applySession(session, command, options) {\n  if (session.hasEnded) {\n    // TODO: merge this with `assertAlive`, did not want to throw a try/catch here\n    return new MongoError('Cannot use a session that has ended');\n  } // SPEC-1019: silently ignore explicit session with unacknowledged write for backwards compatibility\n\n\n  if (options && options.writeConcern && options.writeConcern.w === 0) {\n    return;\n  }\n\n  const serverSession = session.serverSession;\n  serverSession.lastUse = now();\n  command.lsid = serverSession.id; // first apply non-transaction-specific sessions data\n\n  const inTransaction = session.inTransaction() || isTransactionCommand(command);\n  const isRetryableWrite = options.willRetryWrite;\n  const shouldApplyReadConcern = commandSupportsReadConcern(command, options);\n\n  if (serverSession.txnNumber && (isRetryableWrite || inTransaction)) {\n    command.txnNumber = BSON.Long.fromNumber(serverSession.txnNumber);\n  } // now attempt to apply transaction-specific sessions data\n\n\n  if (!inTransaction) {\n    if (session.transaction.state !== TxnState.NO_TRANSACTION) {\n      session.transaction.transition(TxnState.NO_TRANSACTION);\n    } // TODO: the following should only be applied to read operation per spec.\n    // for causal consistency\n\n\n    if (session.supports.causalConsistency && session.operationTime && shouldApplyReadConcern) {\n      command.readConcern = command.readConcern || {};\n      Object.assign(command.readConcern, {\n        afterClusterTime: session.operationTime\n      });\n    }\n\n    return;\n  }\n\n  if (options.readPreference && !options.readPreference.equals(ReadPreference.primary)) {\n    return new MongoError(`Read preference in a transaction must be primary, not: ${options.readPreference.mode}`);\n  } // `autocommit` must always be false to differentiate from retryable writes\n\n\n  command.autocommit = false;\n\n  if (session.transaction.state === TxnState.STARTING_TRANSACTION) {\n    session.transaction.transition(TxnState.TRANSACTION_IN_PROGRESS);\n    command.startTransaction = true;\n    const readConcern = session.transaction.options.readConcern || session.clientOptions.readConcern;\n\n    if (readConcern) {\n      command.readConcern = readConcern;\n    }\n\n    if (session.supports.causalConsistency && session.operationTime) {\n      command.readConcern = command.readConcern || {};\n      Object.assign(command.readConcern, {\n        afterClusterTime: session.operationTime\n      });\n    }\n  }\n}\n\nfunction updateSessionFromResponse(session, document) {\n  if (document.$clusterTime) {\n    resolveClusterTime(session, document.$clusterTime);\n  }\n\n  if (document.operationTime && session && session.supports.causalConsistency) {\n    session.advanceOperationTime(document.operationTime);\n  }\n\n  if (document.recoveryToken && session && session.inTransaction()) {\n    session.transaction._recoveryToken = document.recoveryToken;\n  }\n}\n\nmodule.exports = {\n  ClientSession,\n  ServerSession,\n  ServerSessionPool,\n  TxnState,\n  applySession,\n  updateSessionFromResponse,\n  commandSupportsReadConcern\n};","map":{"version":3,"names":["retrieveBSON","require","EventEmitter","BSON","Binary","uuidV4","MongoError","isRetryableError","MongoNetworkError","MongoWriteConcernError","Transaction","TxnState","isPromiseLike","ReadPreference","maybePromise","isTransactionCommand","resolveClusterTime","isSharded","maxWireVersion","now","calculateDurationInMs","minWireVersionForShardedTransactions","assertAlive","session","callback","serverSession","error","kServerSession","Symbol","ClientSession","constructor","topology","sessionPool","options","clientOptions","Error","ServerSessionPool","hasEnded","undefined","supports","causalConsistency","clusterTime","initialClusterTime","operationTime","explicit","owner","defaultTransactionOptions","Object","assign","transaction","id","acquire","endSession","done","completeEndSession","release","emit","inTransaction","abortTransaction","err","advanceOperationTime","greaterThan","equals","buffer","incrementTransactionNumber","txnNumber","isActive","startTransaction","topologyMaxWireVersion","transition","STARTING_TRANSACTION","commitTransaction","endTransaction","toBSON","withTransaction","fn","startTime","attemptTransaction","MAX_WITH_TRANSACTION_TIMEOUT","UNSATISFIABLE_WRITE_CONCERN_CODE","UNKNOWN_REPL_WRITE_CONCERN_CODE","MAX_TIME_MS_EXPIRED_CODE","NON_DETERMINISTIC_WRITE_CONCERN_ERRORS","Set","hasNotTimedOut","max","isUnknownTransactionCommitResult","isMaxTimeMSExpiredError","has","codeName","code","writeConcernError","attemptTransactionCommit","catch","hasErrorLabel","USER_EXPLICIT_TXN_END_STATES","NO_TRANSACTION","TRANSACTION_COMMITTED","TRANSACTION_ABORTED","userExplicitlyEndedTransaction","state","promise","Promise","reject","TypeError","then","maybeRetryOrThrow","addErrorLabel","commandName","txnState","TRANSACTION_COMMITTED_EMPTY","command","writeConcern","w","wtimeout","maxTimeMS","commandHandler","e","r","unpinServer","transactionError","recoveryToken","supportsRecoveryToken","reply","_err","_reply","s","useRecoveryToken","ServerSession","SUBTYPE_UUID","lastUse","isDirty","hasTimedOut","sessionTimeoutMinutes","idleTimeMinutes","Math","round","sessions","endAllPooledSessions","length","endSessions","map","logicalSessionTimeoutMinutes","shift","pooledSession","pop","unshift","commandSupportsReadConcern","aggregate","count","distinct","find","parallelCollectionScan","geoNear","geoSearch","mapReduce","out","inline","applySession","lsid","isRetryableWrite","willRetryWrite","shouldApplyReadConcern","Long","fromNumber","readConcern","afterClusterTime","readPreference","primary","mode","autocommit","TRANSACTION_IN_PROGRESS","updateSessionFromResponse","document","$clusterTime","_recoveryToken","module","exports"],"sources":["C:/Users/Administrator/Desktop/webAPI work/web/dog-website/node_modules/koa-mongo/node_modules/mongodb/lib/core/sessions.js"],"sourcesContent":["'use strict';\n\nconst retrieveBSON = require('./connection/utils').retrieveBSON;\nconst EventEmitter = require('events');\nconst BSON = retrieveBSON();\nconst Binary = BSON.Binary;\nconst uuidV4 = require('./utils').uuidV4;\nconst MongoError = require('./error').MongoError;\nconst isRetryableError = require('././error').isRetryableError;\nconst MongoNetworkError = require('./error').MongoNetworkError;\nconst MongoWriteConcernError = require('./error').MongoWriteConcernError;\nconst Transaction = require('./transactions').Transaction;\nconst TxnState = require('./transactions').TxnState;\nconst isPromiseLike = require('./utils').isPromiseLike;\nconst ReadPreference = require('./topologies/read_preference');\nconst maybePromise = require('../utils').maybePromise;\nconst isTransactionCommand = require('./transactions').isTransactionCommand;\nconst resolveClusterTime = require('./topologies/shared').resolveClusterTime;\nconst isSharded = require('./wireprotocol/shared').isSharded;\nconst maxWireVersion = require('./utils').maxWireVersion;\nconst now = require('./../utils').now;\nconst calculateDurationInMs = require('./../utils').calculateDurationInMs;\nconst minWireVersionForShardedTransactions = 8;\n\nfunction assertAlive(session, callback) {\n  if (session.serverSession == null) {\n    const error = new MongoError('Cannot use a session that has ended');\n    if (typeof callback === 'function') {\n      callback(error, null);\n      return false;\n    }\n\n    throw error;\n  }\n\n  return true;\n}\n\n/**\n * Options to pass when creating a Client Session\n * @typedef {Object} SessionOptions\n * @property {boolean} [causalConsistency=true] Whether causal consistency should be enabled on this session\n * @property {TransactionOptions} [defaultTransactionOptions] The default TransactionOptions to use for transactions started on this session.\n */\n\n/**\n * A BSON document reflecting the lsid of a {@link ClientSession}\n * @typedef {Object} SessionId\n */\n\nconst kServerSession = Symbol('serverSession');\n\n/**\n * A class representing a client session on the server\n * WARNING: not meant to be instantiated directly.\n * @class\n * @hideconstructor\n */\nclass ClientSession extends EventEmitter {\n  /**\n   * Create a client session.\n   * WARNING: not meant to be instantiated directly\n   *\n   * @param {Topology} topology The current client's topology (Internal Class)\n   * @param {ServerSessionPool} sessionPool The server session pool (Internal Class)\n   * @param {SessionOptions} [options] Optional settings\n   * @param {Object} [clientOptions] Optional settings provided when creating a client in the porcelain driver\n   */\n  constructor(topology, sessionPool, options, clientOptions) {\n    super();\n\n    if (topology == null) {\n      throw new Error('ClientSession requires a topology');\n    }\n\n    if (sessionPool == null || !(sessionPool instanceof ServerSessionPool)) {\n      throw new Error('ClientSession requires a ServerSessionPool');\n    }\n\n    options = options || {};\n    clientOptions = clientOptions || {};\n\n    this.topology = topology;\n    this.sessionPool = sessionPool;\n    this.hasEnded = false;\n    this.clientOptions = clientOptions;\n    this[kServerSession] = undefined;\n\n    this.supports = {\n      causalConsistency:\n        typeof options.causalConsistency !== 'undefined' ? options.causalConsistency : true\n    };\n\n    this.clusterTime = options.initialClusterTime;\n\n    this.operationTime = null;\n    this.explicit = !!options.explicit;\n    this.owner = options.owner;\n    this.defaultTransactionOptions = Object.assign({}, options.defaultTransactionOptions);\n    this.transaction = new Transaction();\n  }\n\n  /**\n   * The server id associated with this session\n   * @type {SessionId}\n   */\n  get id() {\n    return this.serverSession.id;\n  }\n\n  get serverSession() {\n    if (this[kServerSession] == null) {\n      this[kServerSession] = this.sessionPool.acquire();\n    }\n\n    return this[kServerSession];\n  }\n\n  /**\n   * Ends this session on the server\n   *\n   * @param {Object} [options] Optional settings. Currently reserved for future use\n   * @param {Function} [callback] Optional callback for completion of this operation\n   */\n  endSession(options, callback) {\n    if (typeof options === 'function') (callback = options), (options = {});\n    options = options || {};\n\n    const session = this;\n    return maybePromise(this, callback, done => {\n      if (session.hasEnded) {\n        return done();\n      }\n\n      function completeEndSession() {\n        // release the server session back to the pool\n        session.sessionPool.release(session.serverSession);\n        session[kServerSession] = undefined;\n\n        // mark the session as ended, and emit a signal\n        session.hasEnded = true;\n        session.emit('ended', session);\n\n        // spec indicates that we should ignore all errors for `endSessions`\n        done();\n      }\n\n      if (session.serverSession && session.inTransaction()) {\n        session.abortTransaction(err => {\n          if (err) return done(err);\n          completeEndSession();\n        });\n\n        return;\n      }\n\n      completeEndSession();\n    });\n  }\n\n  /**\n   * Advances the operationTime for a ClientSession.\n   *\n   * @param {Timestamp} operationTime the `BSON.Timestamp` of the operation type it is desired to advance to\n   */\n  advanceOperationTime(operationTime) {\n    if (this.operationTime == null) {\n      this.operationTime = operationTime;\n      return;\n    }\n\n    if (operationTime.greaterThan(this.operationTime)) {\n      this.operationTime = operationTime;\n    }\n  }\n\n  /**\n   * Used to determine if this session equals another\n   * @param {ClientSession} session\n   * @return {boolean} true if the sessions are equal\n   */\n  equals(session) {\n    if (!(session instanceof ClientSession)) {\n      return false;\n    }\n\n    return this.id.id.buffer.equals(session.id.id.buffer);\n  }\n\n  /**\n   * Increment the transaction number on the internal ServerSession\n   */\n  incrementTransactionNumber() {\n    this.serverSession.txnNumber++;\n  }\n\n  /**\n   * @returns {boolean} whether this session is currently in a transaction or not\n   */\n  inTransaction() {\n    return this.transaction.isActive;\n  }\n\n  /**\n   * Starts a new transaction with the given options.\n   *\n   * @param {TransactionOptions} options Options for the transaction\n   */\n  startTransaction(options) {\n    assertAlive(this);\n    if (this.inTransaction()) {\n      throw new MongoError('Transaction already in progress');\n    }\n\n    const topologyMaxWireVersion = maxWireVersion(this.topology);\n    if (\n      isSharded(this.topology) &&\n      topologyMaxWireVersion != null &&\n      topologyMaxWireVersion < minWireVersionForShardedTransactions\n    ) {\n      throw new MongoError('Transactions are not supported on sharded clusters in MongoDB < 4.2.');\n    }\n\n    // increment txnNumber\n    this.incrementTransactionNumber();\n\n    // create transaction state\n    this.transaction = new Transaction(\n      Object.assign({}, this.clientOptions, options || this.defaultTransactionOptions)\n    );\n\n    this.transaction.transition(TxnState.STARTING_TRANSACTION);\n  }\n\n  /**\n   * Commits the currently active transaction in this session.\n   *\n   * @param {Function} [callback] optional callback for completion of this operation\n   * @return {Promise} A promise is returned if no callback is provided\n   */\n  commitTransaction(callback) {\n    return maybePromise(this, callback, done => endTransaction(this, 'commitTransaction', done));\n  }\n\n  /**\n   * Aborts the currently active transaction in this session.\n   *\n   * @param {Function} [callback] optional callback for completion of this operation\n   * @return {Promise} A promise is returned if no callback is provided\n   */\n  abortTransaction(callback) {\n    return maybePromise(this, callback, done => endTransaction(this, 'abortTransaction', done));\n  }\n\n  /**\n   * This is here to ensure that ClientSession is never serialized to BSON.\n   * @ignore\n   */\n  toBSON() {\n    throw new Error('ClientSession cannot be serialized to BSON.');\n  }\n\n  /**\n   * A user provided function to be run within a transaction\n   *\n   * @callback WithTransactionCallback\n   * @param {ClientSession} session The parent session of the transaction running the operation. This should be passed into each operation within the lambda.\n   * @returns {Promise} The resulting Promise of operations run within this transaction\n   */\n\n  /**\n   * Runs a provided lambda within a transaction, retrying either the commit operation\n   * or entire transaction as needed (and when the error permits) to better ensure that\n   * the transaction can complete successfully.\n   *\n   * IMPORTANT: This method requires the user to return a Promise, all lambdas that do not\n   * return a Promise will result in undefined behavior.\n   *\n   * @param {WithTransactionCallback} fn\n   * @param {TransactionOptions} [options] Optional settings for the transaction\n   */\n  withTransaction(fn, options) {\n    const startTime = now();\n    return attemptTransaction(this, startTime, fn, options);\n  }\n}\n\nconst MAX_WITH_TRANSACTION_TIMEOUT = 120000;\nconst UNSATISFIABLE_WRITE_CONCERN_CODE = 100;\nconst UNKNOWN_REPL_WRITE_CONCERN_CODE = 79;\nconst MAX_TIME_MS_EXPIRED_CODE = 50;\nconst NON_DETERMINISTIC_WRITE_CONCERN_ERRORS = new Set([\n  'CannotSatisfyWriteConcern',\n  'UnknownReplWriteConcern',\n  'UnsatisfiableWriteConcern'\n]);\n\nfunction hasNotTimedOut(startTime, max) {\n  return calculateDurationInMs(startTime) < max;\n}\n\nfunction isUnknownTransactionCommitResult(err) {\n  return (\n    isMaxTimeMSExpiredError(err) ||\n    (!NON_DETERMINISTIC_WRITE_CONCERN_ERRORS.has(err.codeName) &&\n      err.code !== UNSATISFIABLE_WRITE_CONCERN_CODE &&\n      err.code !== UNKNOWN_REPL_WRITE_CONCERN_CODE)\n  );\n}\n\nfunction isMaxTimeMSExpiredError(err) {\n  if (err == null) return false;\n  return (\n    err.code === MAX_TIME_MS_EXPIRED_CODE ||\n    (err.writeConcernError && err.writeConcernError.code === MAX_TIME_MS_EXPIRED_CODE)\n  );\n}\n\nfunction attemptTransactionCommit(session, startTime, fn, options) {\n  return session.commitTransaction().catch(err => {\n    if (\n      err instanceof MongoError &&\n      hasNotTimedOut(startTime, MAX_WITH_TRANSACTION_TIMEOUT) &&\n      !isMaxTimeMSExpiredError(err)\n    ) {\n      if (err.hasErrorLabel('UnknownTransactionCommitResult')) {\n        return attemptTransactionCommit(session, startTime, fn, options);\n      }\n\n      if (err.hasErrorLabel('TransientTransactionError')) {\n        return attemptTransaction(session, startTime, fn, options);\n      }\n    }\n\n    throw err;\n  });\n}\n\nconst USER_EXPLICIT_TXN_END_STATES = new Set([\n  TxnState.NO_TRANSACTION,\n  TxnState.TRANSACTION_COMMITTED,\n  TxnState.TRANSACTION_ABORTED\n]);\n\nfunction userExplicitlyEndedTransaction(session) {\n  return USER_EXPLICIT_TXN_END_STATES.has(session.transaction.state);\n}\n\nfunction attemptTransaction(session, startTime, fn, options) {\n  session.startTransaction(options);\n\n  let promise;\n  try {\n    promise = fn(session);\n  } catch (err) {\n    promise = Promise.reject(err);\n  }\n\n  if (!isPromiseLike(promise)) {\n    session.abortTransaction();\n    throw new TypeError('Function provided to `withTransaction` must return a Promise');\n  }\n\n  return promise\n    .then(() => {\n      if (userExplicitlyEndedTransaction(session)) {\n        return;\n      }\n\n      return attemptTransactionCommit(session, startTime, fn, options);\n    })\n    .catch(err => {\n      function maybeRetryOrThrow(err) {\n        if (\n          err instanceof MongoError &&\n          err.hasErrorLabel('TransientTransactionError') &&\n          hasNotTimedOut(startTime, MAX_WITH_TRANSACTION_TIMEOUT)\n        ) {\n          return attemptTransaction(session, startTime, fn, options);\n        }\n\n        if (isMaxTimeMSExpiredError(err)) {\n          err.addErrorLabel('UnknownTransactionCommitResult');\n        }\n\n        throw err;\n      }\n\n      if (session.transaction.isActive) {\n        return session.abortTransaction().then(() => maybeRetryOrThrow(err));\n      }\n\n      return maybeRetryOrThrow(err);\n    });\n}\n\nfunction endTransaction(session, commandName, callback) {\n  if (!assertAlive(session, callback)) {\n    // checking result in case callback was called\n    return;\n  }\n\n  // handle any initial problematic cases\n  let txnState = session.transaction.state;\n\n  if (txnState === TxnState.NO_TRANSACTION) {\n    callback(new MongoError('No transaction started'));\n    return;\n  }\n\n  if (commandName === 'commitTransaction') {\n    if (\n      txnState === TxnState.STARTING_TRANSACTION ||\n      txnState === TxnState.TRANSACTION_COMMITTED_EMPTY\n    ) {\n      // the transaction was never started, we can safely exit here\n      session.transaction.transition(TxnState.TRANSACTION_COMMITTED_EMPTY);\n      callback(null, null);\n      return;\n    }\n\n    if (txnState === TxnState.TRANSACTION_ABORTED) {\n      callback(new MongoError('Cannot call commitTransaction after calling abortTransaction'));\n      return;\n    }\n  } else {\n    if (txnState === TxnState.STARTING_TRANSACTION) {\n      // the transaction was never started, we can safely exit here\n      session.transaction.transition(TxnState.TRANSACTION_ABORTED);\n      callback(null, null);\n      return;\n    }\n\n    if (txnState === TxnState.TRANSACTION_ABORTED) {\n      callback(new MongoError('Cannot call abortTransaction twice'));\n      return;\n    }\n\n    if (\n      txnState === TxnState.TRANSACTION_COMMITTED ||\n      txnState === TxnState.TRANSACTION_COMMITTED_EMPTY\n    ) {\n      callback(new MongoError('Cannot call abortTransaction after calling commitTransaction'));\n      return;\n    }\n  }\n\n  // construct and send the command\n  const command = { [commandName]: 1 };\n\n  // apply a writeConcern if specified\n  let writeConcern;\n  if (session.transaction.options.writeConcern) {\n    writeConcern = Object.assign({}, session.transaction.options.writeConcern);\n  } else if (session.clientOptions && session.clientOptions.w) {\n    writeConcern = { w: session.clientOptions.w };\n  }\n\n  if (txnState === TxnState.TRANSACTION_COMMITTED) {\n    writeConcern = Object.assign({ wtimeout: 10000 }, writeConcern, { w: 'majority' });\n  }\n\n  if (writeConcern) {\n    Object.assign(command, { writeConcern });\n  }\n\n  if (commandName === 'commitTransaction' && session.transaction.options.maxTimeMS) {\n    Object.assign(command, { maxTimeMS: session.transaction.options.maxTimeMS });\n  }\n\n  function commandHandler(e, r) {\n    if (commandName === 'commitTransaction') {\n      session.transaction.transition(TxnState.TRANSACTION_COMMITTED);\n\n      if (\n        e &&\n        (e instanceof MongoNetworkError ||\n          e instanceof MongoWriteConcernError ||\n          isRetryableError(e) ||\n          isMaxTimeMSExpiredError(e))\n      ) {\n        if (isUnknownTransactionCommitResult(e)) {\n          e.addErrorLabel('UnknownTransactionCommitResult');\n\n          // per txns spec, must unpin session in this case\n          session.transaction.unpinServer();\n        }\n      }\n    } else {\n      session.transaction.transition(TxnState.TRANSACTION_ABORTED);\n    }\n\n    callback(e, r);\n  }\n\n  // The spec indicates that we should ignore all errors on `abortTransaction`\n  function transactionError(err) {\n    return commandName === 'commitTransaction' ? err : null;\n  }\n\n  if (\n    // Assumption here that commandName is \"commitTransaction\" or \"abortTransaction\"\n    session.transaction.recoveryToken &&\n    supportsRecoveryToken(session)\n  ) {\n    command.recoveryToken = session.transaction.recoveryToken;\n  }\n\n  // send the command\n  session.topology.command('admin.$cmd', command, { session }, (err, reply) => {\n    if (err && isRetryableError(err)) {\n      // SPEC-1185: apply majority write concern when retrying commitTransaction\n      if (command.commitTransaction) {\n        // per txns spec, must unpin session in this case\n        session.transaction.unpinServer();\n\n        command.writeConcern = Object.assign({ wtimeout: 10000 }, command.writeConcern, {\n          w: 'majority'\n        });\n      }\n\n      return session.topology.command('admin.$cmd', command, { session }, (_err, _reply) =>\n        commandHandler(transactionError(_err), _reply)\n      );\n    }\n\n    commandHandler(transactionError(err), reply);\n  });\n}\n\nfunction supportsRecoveryToken(session) {\n  const topology = session.topology;\n  return !!topology.s.options.useRecoveryToken;\n}\n\n/**\n * Reflects the existence of a session on the server. Can be reused by the session pool.\n * WARNING: not meant to be instantiated directly. For internal use only.\n * @ignore\n */\nclass ServerSession {\n  constructor() {\n    this.id = { id: new Binary(uuidV4(), Binary.SUBTYPE_UUID) };\n    this.lastUse = now();\n    this.txnNumber = 0;\n    this.isDirty = false;\n  }\n\n  /**\n   * Determines if the server session has timed out.\n   * @ignore\n   * @param {Date} sessionTimeoutMinutes The server's \"logicalSessionTimeoutMinutes\"\n   * @return {boolean} true if the session has timed out.\n   */\n  hasTimedOut(sessionTimeoutMinutes) {\n    // Take the difference of the lastUse timestamp and now, which will result in a value in\n    // milliseconds, and then convert milliseconds to minutes to compare to `sessionTimeoutMinutes`\n    const idleTimeMinutes = Math.round(\n      ((calculateDurationInMs(this.lastUse) % 86400000) % 3600000) / 60000\n    );\n\n    return idleTimeMinutes > sessionTimeoutMinutes - 1;\n  }\n}\n\n/**\n * Maintains a pool of Server Sessions.\n * For internal use only\n * @ignore\n */\nclass ServerSessionPool {\n  constructor(topology) {\n    if (topology == null) {\n      throw new Error('ServerSessionPool requires a topology');\n    }\n\n    this.topology = topology;\n    this.sessions = [];\n  }\n\n  /**\n   * Ends all sessions in the session pool.\n   * @ignore\n   */\n  endAllPooledSessions(callback) {\n    if (this.sessions.length) {\n      this.topology.endSessions(\n        this.sessions.map(session => session.id),\n        () => {\n          this.sessions = [];\n          if (typeof callback === 'function') {\n            callback();\n          }\n        }\n      );\n\n      return;\n    }\n\n    if (typeof callback === 'function') {\n      callback();\n    }\n  }\n\n  /**\n   * Acquire a Server Session from the pool.\n   * Iterates through each session in the pool, removing any stale sessions\n   * along the way. The first non-stale session found is removed from the\n   * pool and returned. If no non-stale session is found, a new ServerSession\n   * is created.\n   * @ignore\n   * @returns {ServerSession}\n   */\n  acquire() {\n    const sessionTimeoutMinutes = this.topology.logicalSessionTimeoutMinutes;\n    while (this.sessions.length) {\n      const session = this.sessions.shift();\n      if (!session.hasTimedOut(sessionTimeoutMinutes)) {\n        return session;\n      }\n    }\n\n    return new ServerSession();\n  }\n\n  /**\n   * Release a session to the session pool\n   * Adds the session back to the session pool if the session has not timed out yet.\n   * This method also removes any stale sessions from the pool.\n   * @ignore\n   * @param {ServerSession} session The session to release to the pool\n   */\n  release(session) {\n    const sessionTimeoutMinutes = this.topology.logicalSessionTimeoutMinutes;\n    while (this.sessions.length) {\n      const pooledSession = this.sessions[this.sessions.length - 1];\n      if (pooledSession.hasTimedOut(sessionTimeoutMinutes)) {\n        this.sessions.pop();\n      } else {\n        break;\n      }\n    }\n\n    if (!session.hasTimedOut(sessionTimeoutMinutes)) {\n      if (session.isDirty) {\n        return;\n      }\n\n      // otherwise, readd this session to the session pool\n      this.sessions.unshift(session);\n    }\n  }\n}\n\n// TODO: this should be codified in command construction\n// @see https://github.com/mongodb/specifications/blob/master/source/read-write-concern/read-write-concern.rst#read-concern\nfunction commandSupportsReadConcern(command, options) {\n  if (\n    command.aggregate ||\n    command.count ||\n    command.distinct ||\n    command.find ||\n    command.parallelCollectionScan ||\n    command.geoNear ||\n    command.geoSearch\n  ) {\n    return true;\n  }\n\n  if (\n    command.mapReduce &&\n    options &&\n    options.out &&\n    (options.out.inline === 1 || options.out === 'inline')\n  ) {\n    return true;\n  }\n\n  return false;\n}\n\n/**\n * Optionally decorate a command with sessions specific keys\n *\n * @ignore\n * @param {ClientSession} session the session tracking transaction state\n * @param {Object} command the command to decorate\n * @param {Object} topology the topology for tracking the cluster time\n * @param {Object} [options] Optional settings passed to calling operation\n * @return {MongoError|null} An error, if some error condition was met\n */\nfunction applySession(session, command, options) {\n  if (session.hasEnded) {\n    // TODO: merge this with `assertAlive`, did not want to throw a try/catch here\n    return new MongoError('Cannot use a session that has ended');\n  }\n\n  // SPEC-1019: silently ignore explicit session with unacknowledged write for backwards compatibility\n  if (options && options.writeConcern && options.writeConcern.w === 0) {\n    return;\n  }\n\n  const serverSession = session.serverSession;\n  serverSession.lastUse = now();\n  command.lsid = serverSession.id;\n\n  // first apply non-transaction-specific sessions data\n  const inTransaction = session.inTransaction() || isTransactionCommand(command);\n  const isRetryableWrite = options.willRetryWrite;\n  const shouldApplyReadConcern = commandSupportsReadConcern(command, options);\n\n  if (serverSession.txnNumber && (isRetryableWrite || inTransaction)) {\n    command.txnNumber = BSON.Long.fromNumber(serverSession.txnNumber);\n  }\n\n  // now attempt to apply transaction-specific sessions data\n  if (!inTransaction) {\n    if (session.transaction.state !== TxnState.NO_TRANSACTION) {\n      session.transaction.transition(TxnState.NO_TRANSACTION);\n    }\n\n    // TODO: the following should only be applied to read operation per spec.\n    // for causal consistency\n    if (session.supports.causalConsistency && session.operationTime && shouldApplyReadConcern) {\n      command.readConcern = command.readConcern || {};\n      Object.assign(command.readConcern, { afterClusterTime: session.operationTime });\n    }\n\n    return;\n  }\n\n  if (options.readPreference && !options.readPreference.equals(ReadPreference.primary)) {\n    return new MongoError(\n      `Read preference in a transaction must be primary, not: ${options.readPreference.mode}`\n    );\n  }\n\n  // `autocommit` must always be false to differentiate from retryable writes\n  command.autocommit = false;\n\n  if (session.transaction.state === TxnState.STARTING_TRANSACTION) {\n    session.transaction.transition(TxnState.TRANSACTION_IN_PROGRESS);\n    command.startTransaction = true;\n\n    const readConcern =\n      session.transaction.options.readConcern || session.clientOptions.readConcern;\n    if (readConcern) {\n      command.readConcern = readConcern;\n    }\n\n    if (session.supports.causalConsistency && session.operationTime) {\n      command.readConcern = command.readConcern || {};\n      Object.assign(command.readConcern, { afterClusterTime: session.operationTime });\n    }\n  }\n}\n\nfunction updateSessionFromResponse(session, document) {\n  if (document.$clusterTime) {\n    resolveClusterTime(session, document.$clusterTime);\n  }\n\n  if (document.operationTime && session && session.supports.causalConsistency) {\n    session.advanceOperationTime(document.operationTime);\n  }\n\n  if (document.recoveryToken && session && session.inTransaction()) {\n    session.transaction._recoveryToken = document.recoveryToken;\n  }\n}\n\nmodule.exports = {\n  ClientSession,\n  ServerSession,\n  ServerSessionPool,\n  TxnState,\n  applySession,\n  updateSessionFromResponse,\n  commandSupportsReadConcern\n};\n"],"mappings":"AAAA;;AAEA,MAAMA,YAAY,GAAGC,OAAO,CAAC,oBAAD,CAAP,CAA8BD,YAAnD;;AACA,MAAME,YAAY,GAAGD,OAAO,CAAC,QAAD,CAA5B;;AACA,MAAME,IAAI,GAAGH,YAAY,EAAzB;AACA,MAAMI,MAAM,GAAGD,IAAI,CAACC,MAApB;;AACA,MAAMC,MAAM,GAAGJ,OAAO,CAAC,SAAD,CAAP,CAAmBI,MAAlC;;AACA,MAAMC,UAAU,GAAGL,OAAO,CAAC,SAAD,CAAP,CAAmBK,UAAtC;;AACA,MAAMC,gBAAgB,GAAGN,OAAO,CAAC,WAAD,CAAP,CAAqBM,gBAA9C;;AACA,MAAMC,iBAAiB,GAAGP,OAAO,CAAC,SAAD,CAAP,CAAmBO,iBAA7C;;AACA,MAAMC,sBAAsB,GAAGR,OAAO,CAAC,SAAD,CAAP,CAAmBQ,sBAAlD;;AACA,MAAMC,WAAW,GAAGT,OAAO,CAAC,gBAAD,CAAP,CAA0BS,WAA9C;;AACA,MAAMC,QAAQ,GAAGV,OAAO,CAAC,gBAAD,CAAP,CAA0BU,QAA3C;;AACA,MAAMC,aAAa,GAAGX,OAAO,CAAC,SAAD,CAAP,CAAmBW,aAAzC;;AACA,MAAMC,cAAc,GAAGZ,OAAO,CAAC,8BAAD,CAA9B;;AACA,MAAMa,YAAY,GAAGb,OAAO,CAAC,UAAD,CAAP,CAAoBa,YAAzC;;AACA,MAAMC,oBAAoB,GAAGd,OAAO,CAAC,gBAAD,CAAP,CAA0Bc,oBAAvD;;AACA,MAAMC,kBAAkB,GAAGf,OAAO,CAAC,qBAAD,CAAP,CAA+Be,kBAA1D;;AACA,MAAMC,SAAS,GAAGhB,OAAO,CAAC,uBAAD,CAAP,CAAiCgB,SAAnD;;AACA,MAAMC,cAAc,GAAGjB,OAAO,CAAC,SAAD,CAAP,CAAmBiB,cAA1C;;AACA,MAAMC,GAAG,GAAGlB,OAAO,CAAC,YAAD,CAAP,CAAsBkB,GAAlC;;AACA,MAAMC,qBAAqB,GAAGnB,OAAO,CAAC,YAAD,CAAP,CAAsBmB,qBAApD;;AACA,MAAMC,oCAAoC,GAAG,CAA7C;;AAEA,SAASC,WAAT,CAAqBC,OAArB,EAA8BC,QAA9B,EAAwC;EACtC,IAAID,OAAO,CAACE,aAAR,IAAyB,IAA7B,EAAmC;IACjC,MAAMC,KAAK,GAAG,IAAIpB,UAAJ,CAAe,qCAAf,CAAd;;IACA,IAAI,OAAOkB,QAAP,KAAoB,UAAxB,EAAoC;MAClCA,QAAQ,CAACE,KAAD,EAAQ,IAAR,CAAR;MACA,OAAO,KAAP;IACD;;IAED,MAAMA,KAAN;EACD;;EAED,OAAO,IAAP;AACD;AAED;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAEA,MAAMC,cAAc,GAAGC,MAAM,CAAC,eAAD,CAA7B;AAEA;AACA;AACA;AACA;AACA;AACA;;AACA,MAAMC,aAAN,SAA4B3B,YAA5B,CAAyC;EACvC;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE4B,WAAW,CAACC,QAAD,EAAWC,WAAX,EAAwBC,OAAxB,EAAiCC,aAAjC,EAAgD;IACzD;;IAEA,IAAIH,QAAQ,IAAI,IAAhB,EAAsB;MACpB,MAAM,IAAII,KAAJ,CAAU,mCAAV,CAAN;IACD;;IAED,IAAIH,WAAW,IAAI,IAAf,IAAuB,EAAEA,WAAW,YAAYI,iBAAzB,CAA3B,EAAwE;MACtE,MAAM,IAAID,KAAJ,CAAU,4CAAV,CAAN;IACD;;IAEDF,OAAO,GAAGA,OAAO,IAAI,EAArB;IACAC,aAAa,GAAGA,aAAa,IAAI,EAAjC;IAEA,KAAKH,QAAL,GAAgBA,QAAhB;IACA,KAAKC,WAAL,GAAmBA,WAAnB;IACA,KAAKK,QAAL,GAAgB,KAAhB;IACA,KAAKH,aAAL,GAAqBA,aAArB;IACA,KAAKP,cAAL,IAAuBW,SAAvB;IAEA,KAAKC,QAAL,GAAgB;MACdC,iBAAiB,EACf,OAAOP,OAAO,CAACO,iBAAf,KAAqC,WAArC,GAAmDP,OAAO,CAACO,iBAA3D,GAA+E;IAFnE,CAAhB;IAKA,KAAKC,WAAL,GAAmBR,OAAO,CAACS,kBAA3B;IAEA,KAAKC,aAAL,GAAqB,IAArB;IACA,KAAKC,QAAL,GAAgB,CAAC,CAACX,OAAO,CAACW,QAA1B;IACA,KAAKC,KAAL,GAAaZ,OAAO,CAACY,KAArB;IACA,KAAKC,yBAAL,GAAiCC,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBf,OAAO,CAACa,yBAA1B,CAAjC;IACA,KAAKG,WAAL,GAAmB,IAAIvC,WAAJ,EAAnB;EACD;EAED;AACF;AACA;AACA;;;EACQ,IAAFwC,EAAE,GAAG;IACP,OAAO,KAAKzB,aAAL,CAAmByB,EAA1B;EACD;;EAEgB,IAAbzB,aAAa,GAAG;IAClB,IAAI,KAAKE,cAAL,KAAwB,IAA5B,EAAkC;MAChC,KAAKA,cAAL,IAAuB,KAAKK,WAAL,CAAiBmB,OAAjB,EAAvB;IACD;;IAED,OAAO,KAAKxB,cAAL,CAAP;EACD;EAED;AACF;AACA;AACA;AACA;AACA;;;EACEyB,UAAU,CAACnB,OAAD,EAAUT,QAAV,EAAoB;IAC5B,IAAI,OAAOS,OAAP,KAAmB,UAAvB,EAAoCT,QAAQ,GAAGS,OAAZ,EAAuBA,OAAO,GAAG,EAAjC;IACnCA,OAAO,GAAGA,OAAO,IAAI,EAArB;IAEA,MAAMV,OAAO,GAAG,IAAhB;IACA,OAAOT,YAAY,CAAC,IAAD,EAAOU,QAAP,EAAiB6B,IAAI,IAAI;MAC1C,IAAI9B,OAAO,CAACc,QAAZ,EAAsB;QACpB,OAAOgB,IAAI,EAAX;MACD;;MAED,SAASC,kBAAT,GAA8B;QAC5B;QACA/B,OAAO,CAACS,WAAR,CAAoBuB,OAApB,CAA4BhC,OAAO,CAACE,aAApC;QACAF,OAAO,CAACI,cAAD,CAAP,GAA0BW,SAA1B,CAH4B,CAK5B;;QACAf,OAAO,CAACc,QAAR,GAAmB,IAAnB;QACAd,OAAO,CAACiC,IAAR,CAAa,OAAb,EAAsBjC,OAAtB,EAP4B,CAS5B;;QACA8B,IAAI;MACL;;MAED,IAAI9B,OAAO,CAACE,aAAR,IAAyBF,OAAO,CAACkC,aAAR,EAA7B,EAAsD;QACpDlC,OAAO,CAACmC,gBAAR,CAAyBC,GAAG,IAAI;UAC9B,IAAIA,GAAJ,EAAS,OAAON,IAAI,CAACM,GAAD,CAAX;UACTL,kBAAkB;QACnB,CAHD;QAKA;MACD;;MAEDA,kBAAkB;IACnB,CA5BkB,CAAnB;EA6BD;EAED;AACF;AACA;AACA;AACA;;;EACEM,oBAAoB,CAACjB,aAAD,EAAgB;IAClC,IAAI,KAAKA,aAAL,IAAsB,IAA1B,EAAgC;MAC9B,KAAKA,aAAL,GAAqBA,aAArB;MACA;IACD;;IAED,IAAIA,aAAa,CAACkB,WAAd,CAA0B,KAAKlB,aAA/B,CAAJ,EAAmD;MACjD,KAAKA,aAAL,GAAqBA,aAArB;IACD;EACF;EAED;AACF;AACA;AACA;AACA;;;EACEmB,MAAM,CAACvC,OAAD,EAAU;IACd,IAAI,EAAEA,OAAO,YAAYM,aAArB,CAAJ,EAAyC;MACvC,OAAO,KAAP;IACD;;IAED,OAAO,KAAKqB,EAAL,CAAQA,EAAR,CAAWa,MAAX,CAAkBD,MAAlB,CAAyBvC,OAAO,CAAC2B,EAAR,CAAWA,EAAX,CAAca,MAAvC,CAAP;EACD;EAED;AACF;AACA;;;EACEC,0BAA0B,GAAG;IAC3B,KAAKvC,aAAL,CAAmBwC,SAAnB;EACD;EAED;AACF;AACA;;;EACER,aAAa,GAAG;IACd,OAAO,KAAKR,WAAL,CAAiBiB,QAAxB;EACD;EAED;AACF;AACA;AACA;AACA;;;EACEC,gBAAgB,CAAClC,OAAD,EAAU;IACxBX,WAAW,CAAC,IAAD,CAAX;;IACA,IAAI,KAAKmC,aAAL,EAAJ,EAA0B;MACxB,MAAM,IAAInD,UAAJ,CAAe,iCAAf,CAAN;IACD;;IAED,MAAM8D,sBAAsB,GAAGlD,cAAc,CAAC,KAAKa,QAAN,CAA7C;;IACA,IACEd,SAAS,CAAC,KAAKc,QAAN,CAAT,IACAqC,sBAAsB,IAAI,IAD1B,IAEAA,sBAAsB,GAAG/C,oCAH3B,EAIE;MACA,MAAM,IAAIf,UAAJ,CAAe,sEAAf,CAAN;IACD,CAbuB,CAexB;;;IACA,KAAK0D,0BAAL,GAhBwB,CAkBxB;;IACA,KAAKf,WAAL,GAAmB,IAAIvC,WAAJ,CACjBqC,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkB,KAAKd,aAAvB,EAAsCD,OAAO,IAAI,KAAKa,yBAAtD,CADiB,CAAnB;IAIA,KAAKG,WAAL,CAAiBoB,UAAjB,CAA4B1D,QAAQ,CAAC2D,oBAArC;EACD;EAED;AACF;AACA;AACA;AACA;AACA;;;EACEC,iBAAiB,CAAC/C,QAAD,EAAW;IAC1B,OAAOV,YAAY,CAAC,IAAD,EAAOU,QAAP,EAAiB6B,IAAI,IAAImB,cAAc,CAAC,IAAD,EAAO,mBAAP,EAA4BnB,IAA5B,CAAvC,CAAnB;EACD;EAED;AACF;AACA;AACA;AACA;AACA;;;EACEK,gBAAgB,CAAClC,QAAD,EAAW;IACzB,OAAOV,YAAY,CAAC,IAAD,EAAOU,QAAP,EAAiB6B,IAAI,IAAImB,cAAc,CAAC,IAAD,EAAO,kBAAP,EAA2BnB,IAA3B,CAAvC,CAAnB;EACD;EAED;AACF;AACA;AACA;;;EACEoB,MAAM,GAAG;IACP,MAAM,IAAItC,KAAJ,CAAU,6CAAV,CAAN;EACD;EAED;AACF;AACA;AACA;AACA;AACA;AACA;;EAEE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EACEuC,eAAe,CAACC,EAAD,EAAK1C,OAAL,EAAc;IAC3B,MAAM2C,SAAS,GAAGzD,GAAG,EAArB;IACA,OAAO0D,kBAAkB,CAAC,IAAD,EAAOD,SAAP,EAAkBD,EAAlB,EAAsB1C,OAAtB,CAAzB;EACD;;AAlOsC;;AAqOzC,MAAM6C,4BAA4B,GAAG,MAArC;AACA,MAAMC,gCAAgC,GAAG,GAAzC;AACA,MAAMC,+BAA+B,GAAG,EAAxC;AACA,MAAMC,wBAAwB,GAAG,EAAjC;AACA,MAAMC,sCAAsC,GAAG,IAAIC,GAAJ,CAAQ,CACrD,2BADqD,EAErD,yBAFqD,EAGrD,2BAHqD,CAAR,CAA/C;;AAMA,SAASC,cAAT,CAAwBR,SAAxB,EAAmCS,GAAnC,EAAwC;EACtC,OAAOjE,qBAAqB,CAACwD,SAAD,CAArB,GAAmCS,GAA1C;AACD;;AAED,SAASC,gCAAT,CAA0C3B,GAA1C,EAA+C;EAC7C,OACE4B,uBAAuB,CAAC5B,GAAD,CAAvB,IACC,CAACuB,sCAAsC,CAACM,GAAvC,CAA2C7B,GAAG,CAAC8B,QAA/C,CAAD,IACC9B,GAAG,CAAC+B,IAAJ,KAAaX,gCADd,IAECpB,GAAG,CAAC+B,IAAJ,KAAaV,+BAJjB;AAMD;;AAED,SAASO,uBAAT,CAAiC5B,GAAjC,EAAsC;EACpC,IAAIA,GAAG,IAAI,IAAX,EAAiB,OAAO,KAAP;EACjB,OACEA,GAAG,CAAC+B,IAAJ,KAAaT,wBAAb,IACCtB,GAAG,CAACgC,iBAAJ,IAAyBhC,GAAG,CAACgC,iBAAJ,CAAsBD,IAAtB,KAA+BT,wBAF3D;AAID;;AAED,SAASW,wBAAT,CAAkCrE,OAAlC,EAA2CqD,SAA3C,EAAsDD,EAAtD,EAA0D1C,OAA1D,EAAmE;EACjE,OAAOV,OAAO,CAACgD,iBAAR,GAA4BsB,KAA5B,CAAkClC,GAAG,IAAI;IAC9C,IACEA,GAAG,YAAYrD,UAAf,IACA8E,cAAc,CAACR,SAAD,EAAYE,4BAAZ,CADd,IAEA,CAACS,uBAAuB,CAAC5B,GAAD,CAH1B,EAIE;MACA,IAAIA,GAAG,CAACmC,aAAJ,CAAkB,gCAAlB,CAAJ,EAAyD;QACvD,OAAOF,wBAAwB,CAACrE,OAAD,EAAUqD,SAAV,EAAqBD,EAArB,EAAyB1C,OAAzB,CAA/B;MACD;;MAED,IAAI0B,GAAG,CAACmC,aAAJ,CAAkB,2BAAlB,CAAJ,EAAoD;QAClD,OAAOjB,kBAAkB,CAACtD,OAAD,EAAUqD,SAAV,EAAqBD,EAArB,EAAyB1C,OAAzB,CAAzB;MACD;IACF;;IAED,MAAM0B,GAAN;EACD,CAhBM,CAAP;AAiBD;;AAED,MAAMoC,4BAA4B,GAAG,IAAIZ,GAAJ,CAAQ,CAC3CxE,QAAQ,CAACqF,cADkC,EAE3CrF,QAAQ,CAACsF,qBAFkC,EAG3CtF,QAAQ,CAACuF,mBAHkC,CAAR,CAArC;;AAMA,SAASC,8BAAT,CAAwC5E,OAAxC,EAAiD;EAC/C,OAAOwE,4BAA4B,CAACP,GAA7B,CAAiCjE,OAAO,CAAC0B,WAAR,CAAoBmD,KAArD,CAAP;AACD;;AAED,SAASvB,kBAAT,CAA4BtD,OAA5B,EAAqCqD,SAArC,EAAgDD,EAAhD,EAAoD1C,OAApD,EAA6D;EAC3DV,OAAO,CAAC4C,gBAAR,CAAyBlC,OAAzB;EAEA,IAAIoE,OAAJ;;EACA,IAAI;IACFA,OAAO,GAAG1B,EAAE,CAACpD,OAAD,CAAZ;EACD,CAFD,CAEE,OAAOoC,GAAP,EAAY;IACZ0C,OAAO,GAAGC,OAAO,CAACC,MAAR,CAAe5C,GAAf,CAAV;EACD;;EAED,IAAI,CAAC/C,aAAa,CAACyF,OAAD,CAAlB,EAA6B;IAC3B9E,OAAO,CAACmC,gBAAR;IACA,MAAM,IAAI8C,SAAJ,CAAc,8DAAd,CAAN;EACD;;EAED,OAAOH,OAAO,CACXI,IADI,CACC,MAAM;IACV,IAAIN,8BAA8B,CAAC5E,OAAD,CAAlC,EAA6C;MAC3C;IACD;;IAED,OAAOqE,wBAAwB,CAACrE,OAAD,EAAUqD,SAAV,EAAqBD,EAArB,EAAyB1C,OAAzB,CAA/B;EACD,CAPI,EAQJ4D,KARI,CAQElC,GAAG,IAAI;IACZ,SAAS+C,iBAAT,CAA2B/C,GAA3B,EAAgC;MAC9B,IACEA,GAAG,YAAYrD,UAAf,IACAqD,GAAG,CAACmC,aAAJ,CAAkB,2BAAlB,CADA,IAEAV,cAAc,CAACR,SAAD,EAAYE,4BAAZ,CAHhB,EAIE;QACA,OAAOD,kBAAkB,CAACtD,OAAD,EAAUqD,SAAV,EAAqBD,EAArB,EAAyB1C,OAAzB,CAAzB;MACD;;MAED,IAAIsD,uBAAuB,CAAC5B,GAAD,CAA3B,EAAkC;QAChCA,GAAG,CAACgD,aAAJ,CAAkB,gCAAlB;MACD;;MAED,MAAMhD,GAAN;IACD;;IAED,IAAIpC,OAAO,CAAC0B,WAAR,CAAoBiB,QAAxB,EAAkC;MAChC,OAAO3C,OAAO,CAACmC,gBAAR,GAA2B+C,IAA3B,CAAgC,MAAMC,iBAAiB,CAAC/C,GAAD,CAAvD,CAAP;IACD;;IAED,OAAO+C,iBAAiB,CAAC/C,GAAD,CAAxB;EACD,CA9BI,CAAP;AA+BD;;AAED,SAASa,cAAT,CAAwBjD,OAAxB,EAAiCqF,WAAjC,EAA8CpF,QAA9C,EAAwD;EACtD,IAAI,CAACF,WAAW,CAACC,OAAD,EAAUC,QAAV,CAAhB,EAAqC;IACnC;IACA;EACD,CAJqD,CAMtD;;;EACA,IAAIqF,QAAQ,GAAGtF,OAAO,CAAC0B,WAAR,CAAoBmD,KAAnC;;EAEA,IAAIS,QAAQ,KAAKlG,QAAQ,CAACqF,cAA1B,EAA0C;IACxCxE,QAAQ,CAAC,IAAIlB,UAAJ,CAAe,wBAAf,CAAD,CAAR;IACA;EACD;;EAED,IAAIsG,WAAW,KAAK,mBAApB,EAAyC;IACvC,IACEC,QAAQ,KAAKlG,QAAQ,CAAC2D,oBAAtB,IACAuC,QAAQ,KAAKlG,QAAQ,CAACmG,2BAFxB,EAGE;MACA;MACAvF,OAAO,CAAC0B,WAAR,CAAoBoB,UAApB,CAA+B1D,QAAQ,CAACmG,2BAAxC;MACAtF,QAAQ,CAAC,IAAD,EAAO,IAAP,CAAR;MACA;IACD;;IAED,IAAIqF,QAAQ,KAAKlG,QAAQ,CAACuF,mBAA1B,EAA+C;MAC7C1E,QAAQ,CAAC,IAAIlB,UAAJ,CAAe,8DAAf,CAAD,CAAR;MACA;IACD;EACF,CAfD,MAeO;IACL,IAAIuG,QAAQ,KAAKlG,QAAQ,CAAC2D,oBAA1B,EAAgD;MAC9C;MACA/C,OAAO,CAAC0B,WAAR,CAAoBoB,UAApB,CAA+B1D,QAAQ,CAACuF,mBAAxC;MACA1E,QAAQ,CAAC,IAAD,EAAO,IAAP,CAAR;MACA;IACD;;IAED,IAAIqF,QAAQ,KAAKlG,QAAQ,CAACuF,mBAA1B,EAA+C;MAC7C1E,QAAQ,CAAC,IAAIlB,UAAJ,CAAe,oCAAf,CAAD,CAAR;MACA;IACD;;IAED,IACEuG,QAAQ,KAAKlG,QAAQ,CAACsF,qBAAtB,IACAY,QAAQ,KAAKlG,QAAQ,CAACmG,2BAFxB,EAGE;MACAtF,QAAQ,CAAC,IAAIlB,UAAJ,CAAe,8DAAf,CAAD,CAAR;MACA;IACD;EACF,CAjDqD,CAmDtD;;;EACA,MAAMyG,OAAO,GAAG;IAAE,CAACH,WAAD,GAAe;EAAjB,CAAhB,CApDsD,CAsDtD;;EACA,IAAII,YAAJ;;EACA,IAAIzF,OAAO,CAAC0B,WAAR,CAAoBhB,OAApB,CAA4B+E,YAAhC,EAA8C;IAC5CA,YAAY,GAAGjE,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBzB,OAAO,CAAC0B,WAAR,CAAoBhB,OAApB,CAA4B+E,YAA9C,CAAf;EACD,CAFD,MAEO,IAAIzF,OAAO,CAACW,aAAR,IAAyBX,OAAO,CAACW,aAAR,CAAsB+E,CAAnD,EAAsD;IAC3DD,YAAY,GAAG;MAAEC,CAAC,EAAE1F,OAAO,CAACW,aAAR,CAAsB+E;IAA3B,CAAf;EACD;;EAED,IAAIJ,QAAQ,KAAKlG,QAAQ,CAACsF,qBAA1B,EAAiD;IAC/Ce,YAAY,GAAGjE,MAAM,CAACC,MAAP,CAAc;MAAEkE,QAAQ,EAAE;IAAZ,CAAd,EAAmCF,YAAnC,EAAiD;MAAEC,CAAC,EAAE;IAAL,CAAjD,CAAf;EACD;;EAED,IAAID,YAAJ,EAAkB;IAChBjE,MAAM,CAACC,MAAP,CAAc+D,OAAd,EAAuB;MAAEC;IAAF,CAAvB;EACD;;EAED,IAAIJ,WAAW,KAAK,mBAAhB,IAAuCrF,OAAO,CAAC0B,WAAR,CAAoBhB,OAApB,CAA4BkF,SAAvE,EAAkF;IAChFpE,MAAM,CAACC,MAAP,CAAc+D,OAAd,EAAuB;MAAEI,SAAS,EAAE5F,OAAO,CAAC0B,WAAR,CAAoBhB,OAApB,CAA4BkF;IAAzC,CAAvB;EACD;;EAED,SAASC,cAAT,CAAwBC,CAAxB,EAA2BC,CAA3B,EAA8B;IAC5B,IAAIV,WAAW,KAAK,mBAApB,EAAyC;MACvCrF,OAAO,CAAC0B,WAAR,CAAoBoB,UAApB,CAA+B1D,QAAQ,CAACsF,qBAAxC;;MAEA,IACEoB,CAAC,KACAA,CAAC,YAAY7G,iBAAb,IACC6G,CAAC,YAAY5G,sBADd,IAECF,gBAAgB,CAAC8G,CAAD,CAFjB,IAGC9B,uBAAuB,CAAC8B,CAAD,CAJxB,CADH,EAME;QACA,IAAI/B,gCAAgC,CAAC+B,CAAD,CAApC,EAAyC;UACvCA,CAAC,CAACV,aAAF,CAAgB,gCAAhB,EADuC,CAGvC;;UACApF,OAAO,CAAC0B,WAAR,CAAoBsE,WAApB;QACD;MACF;IACF,CAjBD,MAiBO;MACLhG,OAAO,CAAC0B,WAAR,CAAoBoB,UAApB,CAA+B1D,QAAQ,CAACuF,mBAAxC;IACD;;IAED1E,QAAQ,CAAC6F,CAAD,EAAIC,CAAJ,CAAR;EACD,CAjGqD,CAmGtD;;;EACA,SAASE,gBAAT,CAA0B7D,GAA1B,EAA+B;IAC7B,OAAOiD,WAAW,KAAK,mBAAhB,GAAsCjD,GAAtC,GAA4C,IAAnD;EACD;;EAED,KACE;EACApC,OAAO,CAAC0B,WAAR,CAAoBwE,aAApB,IACAC,qBAAqB,CAACnG,OAAD,CAHvB,EAIE;IACAwF,OAAO,CAACU,aAAR,GAAwBlG,OAAO,CAAC0B,WAAR,CAAoBwE,aAA5C;EACD,CA9GqD,CAgHtD;;;EACAlG,OAAO,CAACQ,QAAR,CAAiBgF,OAAjB,CAAyB,YAAzB,EAAuCA,OAAvC,EAAgD;IAAExF;EAAF,CAAhD,EAA6D,CAACoC,GAAD,EAAMgE,KAAN,KAAgB;IAC3E,IAAIhE,GAAG,IAAIpD,gBAAgB,CAACoD,GAAD,CAA3B,EAAkC;MAChC;MACA,IAAIoD,OAAO,CAACxC,iBAAZ,EAA+B;QAC7B;QACAhD,OAAO,CAAC0B,WAAR,CAAoBsE,WAApB;QAEAR,OAAO,CAACC,YAAR,GAAuBjE,MAAM,CAACC,MAAP,CAAc;UAAEkE,QAAQ,EAAE;QAAZ,CAAd,EAAmCH,OAAO,CAACC,YAA3C,EAAyD;UAC9EC,CAAC,EAAE;QAD2E,CAAzD,CAAvB;MAGD;;MAED,OAAO1F,OAAO,CAACQ,QAAR,CAAiBgF,OAAjB,CAAyB,YAAzB,EAAuCA,OAAvC,EAAgD;QAAExF;MAAF,CAAhD,EAA6D,CAACqG,IAAD,EAAOC,MAAP,KAClET,cAAc,CAACI,gBAAgB,CAACI,IAAD,CAAjB,EAAyBC,MAAzB,CADT,CAAP;IAGD;;IAEDT,cAAc,CAACI,gBAAgB,CAAC7D,GAAD,CAAjB,EAAwBgE,KAAxB,CAAd;EACD,CAlBD;AAmBD;;AAED,SAASD,qBAAT,CAA+BnG,OAA/B,EAAwC;EACtC,MAAMQ,QAAQ,GAAGR,OAAO,CAACQ,QAAzB;EACA,OAAO,CAAC,CAACA,QAAQ,CAAC+F,CAAT,CAAW7F,OAAX,CAAmB8F,gBAA5B;AACD;AAED;AACA;AACA;AACA;AACA;;;AACA,MAAMC,aAAN,CAAoB;EAClBlG,WAAW,GAAG;IACZ,KAAKoB,EAAL,GAAU;MAAEA,EAAE,EAAE,IAAI9C,MAAJ,CAAWC,MAAM,EAAjB,EAAqBD,MAAM,CAAC6H,YAA5B;IAAN,CAAV;IACA,KAAKC,OAAL,GAAe/G,GAAG,EAAlB;IACA,KAAK8C,SAAL,GAAiB,CAAjB;IACA,KAAKkE,OAAL,GAAe,KAAf;EACD;EAED;AACF;AACA;AACA;AACA;AACA;;;EACEC,WAAW,CAACC,qBAAD,EAAwB;IACjC;IACA;IACA,MAAMC,eAAe,GAAGC,IAAI,CAACC,KAAL,CACpBpH,qBAAqB,CAAC,KAAK8G,OAAN,CAArB,GAAsC,QAAvC,GAAmD,OAApD,GAA+D,KADzC,CAAxB;IAIA,OAAOI,eAAe,GAAGD,qBAAqB,GAAG,CAAjD;EACD;;AAtBiB;AAyBpB;AACA;AACA;AACA;AACA;;;AACA,MAAMjG,iBAAN,CAAwB;EACtBN,WAAW,CAACC,QAAD,EAAW;IACpB,IAAIA,QAAQ,IAAI,IAAhB,EAAsB;MACpB,MAAM,IAAII,KAAJ,CAAU,uCAAV,CAAN;IACD;;IAED,KAAKJ,QAAL,GAAgBA,QAAhB;IACA,KAAK0G,QAAL,GAAgB,EAAhB;EACD;EAED;AACF;AACA;AACA;;;EACEC,oBAAoB,CAAClH,QAAD,EAAW;IAC7B,IAAI,KAAKiH,QAAL,CAAcE,MAAlB,EAA0B;MACxB,KAAK5G,QAAL,CAAc6G,WAAd,CACE,KAAKH,QAAL,CAAcI,GAAd,CAAkBtH,OAAO,IAAIA,OAAO,CAAC2B,EAArC,CADF,EAEE,MAAM;QACJ,KAAKuF,QAAL,GAAgB,EAAhB;;QACA,IAAI,OAAOjH,QAAP,KAAoB,UAAxB,EAAoC;UAClCA,QAAQ;QACT;MACF,CAPH;MAUA;IACD;;IAED,IAAI,OAAOA,QAAP,KAAoB,UAAxB,EAAoC;MAClCA,QAAQ;IACT;EACF;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EACE2B,OAAO,GAAG;IACR,MAAMkF,qBAAqB,GAAG,KAAKtG,QAAL,CAAc+G,4BAA5C;;IACA,OAAO,KAAKL,QAAL,CAAcE,MAArB,EAA6B;MAC3B,MAAMpH,OAAO,GAAG,KAAKkH,QAAL,CAAcM,KAAd,EAAhB;;MACA,IAAI,CAACxH,OAAO,CAAC6G,WAAR,CAAoBC,qBAApB,CAAL,EAAiD;QAC/C,OAAO9G,OAAP;MACD;IACF;;IAED,OAAO,IAAIyG,aAAJ,EAAP;EACD;EAED;AACF;AACA;AACA;AACA;AACA;AACA;;;EACEzE,OAAO,CAAChC,OAAD,EAAU;IACf,MAAM8G,qBAAqB,GAAG,KAAKtG,QAAL,CAAc+G,4BAA5C;;IACA,OAAO,KAAKL,QAAL,CAAcE,MAArB,EAA6B;MAC3B,MAAMK,aAAa,GAAG,KAAKP,QAAL,CAAc,KAAKA,QAAL,CAAcE,MAAd,GAAuB,CAArC,CAAtB;;MACA,IAAIK,aAAa,CAACZ,WAAd,CAA0BC,qBAA1B,CAAJ,EAAsD;QACpD,KAAKI,QAAL,CAAcQ,GAAd;MACD,CAFD,MAEO;QACL;MACD;IACF;;IAED,IAAI,CAAC1H,OAAO,CAAC6G,WAAR,CAAoBC,qBAApB,CAAL,EAAiD;MAC/C,IAAI9G,OAAO,CAAC4G,OAAZ,EAAqB;QACnB;MACD,CAH8C,CAK/C;;;MACA,KAAKM,QAAL,CAAcS,OAAd,CAAsB3H,OAAtB;IACD;EACF;;AAjFqB,C,CAoFxB;AACA;;;AACA,SAAS4H,0BAAT,CAAoCpC,OAApC,EAA6C9E,OAA7C,EAAsD;EACpD,IACE8E,OAAO,CAACqC,SAAR,IACArC,OAAO,CAACsC,KADR,IAEAtC,OAAO,CAACuC,QAFR,IAGAvC,OAAO,CAACwC,IAHR,IAIAxC,OAAO,CAACyC,sBAJR,IAKAzC,OAAO,CAAC0C,OALR,IAMA1C,OAAO,CAAC2C,SAPV,EAQE;IACA,OAAO,IAAP;EACD;;EAED,IACE3C,OAAO,CAAC4C,SAAR,IACA1H,OADA,IAEAA,OAAO,CAAC2H,GAFR,KAGC3H,OAAO,CAAC2H,GAAR,CAAYC,MAAZ,KAAuB,CAAvB,IAA4B5H,OAAO,CAAC2H,GAAR,KAAgB,QAH7C,CADF,EAKE;IACA,OAAO,IAAP;EACD;;EAED,OAAO,KAAP;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASE,YAAT,CAAsBvI,OAAtB,EAA+BwF,OAA/B,EAAwC9E,OAAxC,EAAiD;EAC/C,IAAIV,OAAO,CAACc,QAAZ,EAAsB;IACpB;IACA,OAAO,IAAI/B,UAAJ,CAAe,qCAAf,CAAP;EACD,CAJ8C,CAM/C;;;EACA,IAAI2B,OAAO,IAAIA,OAAO,CAAC+E,YAAnB,IAAmC/E,OAAO,CAAC+E,YAAR,CAAqBC,CAArB,KAA2B,CAAlE,EAAqE;IACnE;EACD;;EAED,MAAMxF,aAAa,GAAGF,OAAO,CAACE,aAA9B;EACAA,aAAa,CAACyG,OAAd,GAAwB/G,GAAG,EAA3B;EACA4F,OAAO,CAACgD,IAAR,GAAetI,aAAa,CAACyB,EAA7B,CAb+C,CAe/C;;EACA,MAAMO,aAAa,GAAGlC,OAAO,CAACkC,aAAR,MAA2B1C,oBAAoB,CAACgG,OAAD,CAArE;EACA,MAAMiD,gBAAgB,GAAG/H,OAAO,CAACgI,cAAjC;EACA,MAAMC,sBAAsB,GAAGf,0BAA0B,CAACpC,OAAD,EAAU9E,OAAV,CAAzD;;EAEA,IAAIR,aAAa,CAACwC,SAAd,KAA4B+F,gBAAgB,IAAIvG,aAAhD,CAAJ,EAAoE;IAClEsD,OAAO,CAAC9C,SAAR,GAAoB9D,IAAI,CAACgK,IAAL,CAAUC,UAAV,CAAqB3I,aAAa,CAACwC,SAAnC,CAApB;EACD,CAtB8C,CAwB/C;;;EACA,IAAI,CAACR,aAAL,EAAoB;IAClB,IAAIlC,OAAO,CAAC0B,WAAR,CAAoBmD,KAApB,KAA8BzF,QAAQ,CAACqF,cAA3C,EAA2D;MACzDzE,OAAO,CAAC0B,WAAR,CAAoBoB,UAApB,CAA+B1D,QAAQ,CAACqF,cAAxC;IACD,CAHiB,CAKlB;IACA;;;IACA,IAAIzE,OAAO,CAACgB,QAAR,CAAiBC,iBAAjB,IAAsCjB,OAAO,CAACoB,aAA9C,IAA+DuH,sBAAnE,EAA2F;MACzFnD,OAAO,CAACsD,WAAR,GAAsBtD,OAAO,CAACsD,WAAR,IAAuB,EAA7C;MACAtH,MAAM,CAACC,MAAP,CAAc+D,OAAO,CAACsD,WAAtB,EAAmC;QAAEC,gBAAgB,EAAE/I,OAAO,CAACoB;MAA5B,CAAnC;IACD;;IAED;EACD;;EAED,IAAIV,OAAO,CAACsI,cAAR,IAA0B,CAACtI,OAAO,CAACsI,cAAR,CAAuBzG,MAAvB,CAA8BjD,cAAc,CAAC2J,OAA7C,CAA/B,EAAsF;IACpF,OAAO,IAAIlK,UAAJ,CACJ,0DAAyD2B,OAAO,CAACsI,cAAR,CAAuBE,IAAK,EADjF,CAAP;EAGD,CA5C8C,CA8C/C;;;EACA1D,OAAO,CAAC2D,UAAR,GAAqB,KAArB;;EAEA,IAAInJ,OAAO,CAAC0B,WAAR,CAAoBmD,KAApB,KAA8BzF,QAAQ,CAAC2D,oBAA3C,EAAiE;IAC/D/C,OAAO,CAAC0B,WAAR,CAAoBoB,UAApB,CAA+B1D,QAAQ,CAACgK,uBAAxC;IACA5D,OAAO,CAAC5C,gBAAR,GAA2B,IAA3B;IAEA,MAAMkG,WAAW,GACf9I,OAAO,CAAC0B,WAAR,CAAoBhB,OAApB,CAA4BoI,WAA5B,IAA2C9I,OAAO,CAACW,aAAR,CAAsBmI,WADnE;;IAEA,IAAIA,WAAJ,EAAiB;MACftD,OAAO,CAACsD,WAAR,GAAsBA,WAAtB;IACD;;IAED,IAAI9I,OAAO,CAACgB,QAAR,CAAiBC,iBAAjB,IAAsCjB,OAAO,CAACoB,aAAlD,EAAiE;MAC/DoE,OAAO,CAACsD,WAAR,GAAsBtD,OAAO,CAACsD,WAAR,IAAuB,EAA7C;MACAtH,MAAM,CAACC,MAAP,CAAc+D,OAAO,CAACsD,WAAtB,EAAmC;QAAEC,gBAAgB,EAAE/I,OAAO,CAACoB;MAA5B,CAAnC;IACD;EACF;AACF;;AAED,SAASiI,yBAAT,CAAmCrJ,OAAnC,EAA4CsJ,QAA5C,EAAsD;EACpD,IAAIA,QAAQ,CAACC,YAAb,EAA2B;IACzB9J,kBAAkB,CAACO,OAAD,EAAUsJ,QAAQ,CAACC,YAAnB,CAAlB;EACD;;EAED,IAAID,QAAQ,CAAClI,aAAT,IAA0BpB,OAA1B,IAAqCA,OAAO,CAACgB,QAAR,CAAiBC,iBAA1D,EAA6E;IAC3EjB,OAAO,CAACqC,oBAAR,CAA6BiH,QAAQ,CAAClI,aAAtC;EACD;;EAED,IAAIkI,QAAQ,CAACpD,aAAT,IAA0BlG,OAA1B,IAAqCA,OAAO,CAACkC,aAAR,EAAzC,EAAkE;IAChElC,OAAO,CAAC0B,WAAR,CAAoB8H,cAApB,GAAqCF,QAAQ,CAACpD,aAA9C;EACD;AACF;;AAEDuD,MAAM,CAACC,OAAP,GAAiB;EACfpJ,aADe;EAEfmG,aAFe;EAGf5F,iBAHe;EAIfzB,QAJe;EAKfmJ,YALe;EAMfc,yBANe;EAOfzB;AAPe,CAAjB"},"metadata":{},"sourceType":"script"}