{"ast":null,"code":"'use strict';\n\nconst net = require('net');\n\nconst tls = require('tls');\n\nconst Connection = require('./connection');\n\nconst MongoError = require('../error').MongoError;\n\nconst MongoNetworkError = require('../error').MongoNetworkError;\n\nconst MongoNetworkTimeoutError = require('../error').MongoNetworkTimeoutError;\n\nconst defaultAuthProviders = require('../auth/defaultAuthProviders').defaultAuthProviders;\n\nconst AuthContext = require('../auth/auth_provider').AuthContext;\n\nconst WIRE_CONSTANTS = require('../wireprotocol/constants');\n\nconst makeClientMetadata = require('../utils').makeClientMetadata;\n\nconst MAX_SUPPORTED_WIRE_VERSION = WIRE_CONSTANTS.MAX_SUPPORTED_WIRE_VERSION;\nconst MAX_SUPPORTED_SERVER_VERSION = WIRE_CONSTANTS.MAX_SUPPORTED_SERVER_VERSION;\nconst MIN_SUPPORTED_WIRE_VERSION = WIRE_CONSTANTS.MIN_SUPPORTED_WIRE_VERSION;\nconst MIN_SUPPORTED_SERVER_VERSION = WIRE_CONSTANTS.MIN_SUPPORTED_SERVER_VERSION;\nlet AUTH_PROVIDERS;\n\nfunction connect(options, cancellationToken, callback) {\n  if (typeof cancellationToken === 'function') {\n    callback = cancellationToken;\n    cancellationToken = undefined;\n  }\n\n  const ConnectionType = options && options.connectionType ? options.connectionType : Connection;\n\n  if (AUTH_PROVIDERS == null) {\n    AUTH_PROVIDERS = defaultAuthProviders(options.bson);\n  }\n\n  const family = options.family !== void 0 ? options.family : 0;\n  makeConnection(family, options, cancellationToken, (err, socket) => {\n    if (err) {\n      callback(err, socket); // in the error case, `socket` is the originating error event name\n\n      return;\n    }\n\n    performInitialHandshake(new ConnectionType(socket, options), options, callback);\n  });\n}\n\nfunction isModernConnectionType(conn) {\n  return !(conn instanceof Connection);\n}\n\nfunction checkSupportedServer(ismaster, options) {\n  const serverVersionHighEnough = ismaster && typeof ismaster.maxWireVersion === 'number' && ismaster.maxWireVersion >= MIN_SUPPORTED_WIRE_VERSION;\n  const serverVersionLowEnough = ismaster && typeof ismaster.minWireVersion === 'number' && ismaster.minWireVersion <= MAX_SUPPORTED_WIRE_VERSION;\n\n  if (serverVersionHighEnough) {\n    if (serverVersionLowEnough) {\n      return null;\n    }\n\n    const message = `Server at ${options.host}:${options.port} reports minimum wire version ${ismaster.minWireVersion}, but this version of the Node.js Driver requires at most ${MAX_SUPPORTED_WIRE_VERSION} (MongoDB ${MAX_SUPPORTED_SERVER_VERSION})`;\n    return new MongoError(message);\n  }\n\n  const message = `Server at ${options.host}:${options.port} reports maximum wire version ${ismaster.maxWireVersion || 0}, but this version of the Node.js Driver requires at least ${MIN_SUPPORTED_WIRE_VERSION} (MongoDB ${MIN_SUPPORTED_SERVER_VERSION})`;\n  return new MongoError(message);\n}\n\nfunction performInitialHandshake(conn, options, _callback) {\n  const callback = function (err, ret) {\n    if (err && conn) {\n      conn.destroy();\n    }\n\n    _callback(err, ret);\n  };\n\n  const credentials = options.credentials;\n\n  if (credentials) {\n    if (!credentials.mechanism.match(/DEFAULT/i) && !AUTH_PROVIDERS[credentials.mechanism]) {\n      callback(new MongoError(`authMechanism '${credentials.mechanism}' not supported`));\n      return;\n    }\n  }\n\n  const authContext = new AuthContext(conn, credentials, options);\n  prepareHandshakeDocument(authContext, (err, handshakeDoc) => {\n    if (err) {\n      return callback(err);\n    }\n\n    const handshakeOptions = Object.assign({}, options);\n\n    if (options.connectTimeoutMS || options.connectionTimeout) {\n      // The handshake technically is a monitoring check, so its socket timeout should be connectTimeoutMS\n      handshakeOptions.socketTimeout = options.connectTimeoutMS || options.connectionTimeout;\n    }\n\n    const start = new Date().getTime();\n    conn.command('admin.$cmd', handshakeDoc, handshakeOptions, (err, result) => {\n      if (err) {\n        callback(err);\n        return;\n      }\n\n      const response = result.result;\n\n      if (response.ok === 0) {\n        callback(new MongoError(response));\n        return;\n      }\n\n      const supportedServerErr = checkSupportedServer(response, options);\n\n      if (supportedServerErr) {\n        callback(supportedServerErr);\n        return;\n      }\n\n      if (!isModernConnectionType(conn)) {\n        // resolve compression\n        if (response.compression) {\n          const agreedCompressors = handshakeDoc.compression.filter(compressor => response.compression.indexOf(compressor) !== -1);\n\n          if (agreedCompressors.length) {\n            conn.agreedCompressor = agreedCompressors[0];\n          }\n\n          if (options.compression && options.compression.zlibCompressionLevel) {\n            conn.zlibCompressionLevel = options.compression.zlibCompressionLevel;\n          }\n        }\n      } // NOTE: This is metadata attached to the connection while porting away from\n      //       handshake being done in the `Server` class. Likely, it should be\n      //       relocated, or at very least restructured.\n\n\n      conn.ismaster = response;\n      conn.lastIsMasterMS = new Date().getTime() - start;\n\n      if (!response.arbiterOnly && credentials) {\n        // store the response on auth context\n        Object.assign(authContext, {\n          response\n        });\n        const resolvedCredentials = credentials.resolveAuthMechanism(response);\n        const authProvider = AUTH_PROVIDERS[resolvedCredentials.mechanism];\n        authProvider.auth(authContext, err => {\n          if (err) return callback(err);\n          callback(undefined, conn);\n        });\n        return;\n      }\n\n      callback(undefined, conn);\n    });\n  });\n}\n\nfunction prepareHandshakeDocument(authContext, callback) {\n  const options = authContext.options;\n  const compressors = options.compression && options.compression.compressors ? options.compression.compressors : [];\n  const handshakeDoc = {\n    ismaster: true,\n    client: options.metadata || makeClientMetadata(options),\n    compression: compressors\n  };\n  const credentials = authContext.credentials;\n\n  if (credentials) {\n    if (credentials.mechanism.match(/DEFAULT/i) && credentials.username) {\n      Object.assign(handshakeDoc, {\n        saslSupportedMechs: `${credentials.source}.${credentials.username}`\n      });\n      AUTH_PROVIDERS['scram-sha-256'].prepare(handshakeDoc, authContext, callback);\n      return;\n    }\n\n    const authProvider = AUTH_PROVIDERS[credentials.mechanism];\n    authProvider.prepare(handshakeDoc, authContext, callback);\n    return;\n  }\n\n  callback(undefined, handshakeDoc);\n}\n\nconst LEGAL_SSL_SOCKET_OPTIONS = ['pfx', 'key', 'passphrase', 'cert', 'ca', 'ciphers', 'NPNProtocols', 'ALPNProtocols', 'servername', 'ecdhCurve', 'secureProtocol', 'secureContext', 'session', 'minDHSize', 'crl', 'rejectUnauthorized'];\n\nfunction parseConnectOptions(family, options) {\n  const host = typeof options.host === 'string' ? options.host : 'localhost';\n\n  if (host.indexOf('/') !== -1) {\n    return {\n      path: host\n    };\n  }\n\n  const result = {\n    family,\n    host,\n    port: typeof options.port === 'number' ? options.port : 27017,\n    rejectUnauthorized: false\n  };\n  return result;\n}\n\nfunction parseSslOptions(family, options) {\n  const result = parseConnectOptions(family, options); // Merge in valid SSL options\n\n  for (const name in options) {\n    if (options[name] != null && LEGAL_SSL_SOCKET_OPTIONS.indexOf(name) !== -1) {\n      result[name] = options[name];\n    }\n  } // Override checkServerIdentity behavior\n\n\n  if (options.checkServerIdentity === false) {\n    // Skip the identiy check by retuning undefined as per node documents\n    // https://nodejs.org/api/tls.html#tls_tls_connect_options_callback\n    result.checkServerIdentity = function () {\n      return undefined;\n    };\n  } else if (typeof options.checkServerIdentity === 'function') {\n    result.checkServerIdentity = options.checkServerIdentity;\n  } // Set default sni servername to be the same as host\n\n\n  if (result.servername == null) {\n    result.servername = result.host;\n  }\n\n  return result;\n}\n\nconst SOCKET_ERROR_EVENTS = new Set(['error', 'close', 'timeout', 'parseError']);\n\nfunction makeConnection(family, options, cancellationToken, _callback) {\n  const useSsl = typeof options.ssl === 'boolean' ? options.ssl : false;\n  const keepAlive = typeof options.keepAlive === 'boolean' ? options.keepAlive : true;\n  let keepAliveInitialDelay = typeof options.keepAliveInitialDelay === 'number' ? options.keepAliveInitialDelay : 120000;\n  const noDelay = typeof options.noDelay === 'boolean' ? options.noDelay : true;\n  const connectionTimeout = typeof options.connectionTimeout === 'number' ? options.connectionTimeout : typeof options.connectTimeoutMS === 'number' ? options.connectTimeoutMS : 30000;\n  const socketTimeout = typeof options.socketTimeout === 'number' ? options.socketTimeout : 0;\n  const rejectUnauthorized = typeof options.rejectUnauthorized === 'boolean' ? options.rejectUnauthorized : true;\n\n  if (keepAliveInitialDelay > socketTimeout) {\n    keepAliveInitialDelay = Math.round(socketTimeout / 2);\n  }\n\n  let socket;\n\n  const callback = function (err, ret) {\n    if (err && socket) {\n      socket.destroy();\n    }\n\n    _callback(err, ret);\n  };\n\n  try {\n    if (useSsl) {\n      socket = tls.connect(parseSslOptions(family, options));\n\n      if (typeof socket.disableRenegotiation === 'function') {\n        socket.disableRenegotiation();\n      }\n    } else {\n      socket = net.createConnection(parseConnectOptions(family, options));\n    }\n  } catch (err) {\n    return callback(err);\n  }\n\n  socket.setKeepAlive(keepAlive, keepAliveInitialDelay);\n  socket.setTimeout(connectionTimeout);\n  socket.setNoDelay(noDelay);\n  const connectEvent = useSsl ? 'secureConnect' : 'connect';\n  let cancellationHandler;\n\n  function errorHandler(eventName) {\n    return err => {\n      SOCKET_ERROR_EVENTS.forEach(event => socket.removeAllListeners(event));\n\n      if (cancellationHandler) {\n        cancellationToken.removeListener('cancel', cancellationHandler);\n      }\n\n      socket.removeListener(connectEvent, connectHandler);\n      callback(connectionFailureError(eventName, err));\n    };\n  }\n\n  function connectHandler() {\n    SOCKET_ERROR_EVENTS.forEach(event => socket.removeAllListeners(event));\n\n    if (cancellationHandler) {\n      cancellationToken.removeListener('cancel', cancellationHandler);\n    }\n\n    if (socket.authorizationError && rejectUnauthorized) {\n      return callback(socket.authorizationError);\n    }\n\n    socket.setTimeout(socketTimeout);\n    callback(null, socket);\n  }\n\n  SOCKET_ERROR_EVENTS.forEach(event => socket.once(event, errorHandler(event)));\n\n  if (cancellationToken) {\n    cancellationHandler = errorHandler('cancel');\n    cancellationToken.once('cancel', cancellationHandler);\n  }\n\n  socket.once(connectEvent, connectHandler);\n}\n\nfunction connectionFailureError(type, err) {\n  switch (type) {\n    case 'error':\n      return new MongoNetworkError(err);\n\n    case 'timeout':\n      return new MongoNetworkTimeoutError(`connection timed out`);\n\n    case 'close':\n      return new MongoNetworkError(`connection closed`);\n\n    case 'cancel':\n      return new MongoNetworkError(`connection establishment was cancelled`);\n\n    default:\n      return new MongoNetworkError(`unknown network error`);\n  }\n}\n\nmodule.exports = connect;","map":{"version":3,"names":["net","require","tls","Connection","MongoError","MongoNetworkError","MongoNetworkTimeoutError","defaultAuthProviders","AuthContext","WIRE_CONSTANTS","makeClientMetadata","MAX_SUPPORTED_WIRE_VERSION","MAX_SUPPORTED_SERVER_VERSION","MIN_SUPPORTED_WIRE_VERSION","MIN_SUPPORTED_SERVER_VERSION","AUTH_PROVIDERS","connect","options","cancellationToken","callback","undefined","ConnectionType","connectionType","bson","family","makeConnection","err","socket","performInitialHandshake","isModernConnectionType","conn","checkSupportedServer","ismaster","serverVersionHighEnough","maxWireVersion","serverVersionLowEnough","minWireVersion","message","host","port","_callback","ret","destroy","credentials","mechanism","match","authContext","prepareHandshakeDocument","handshakeDoc","handshakeOptions","Object","assign","connectTimeoutMS","connectionTimeout","socketTimeout","start","Date","getTime","command","result","response","ok","supportedServerErr","compression","agreedCompressors","filter","compressor","indexOf","length","agreedCompressor","zlibCompressionLevel","lastIsMasterMS","arbiterOnly","resolvedCredentials","resolveAuthMechanism","authProvider","auth","compressors","client","metadata","username","saslSupportedMechs","source","prepare","LEGAL_SSL_SOCKET_OPTIONS","parseConnectOptions","path","rejectUnauthorized","parseSslOptions","name","checkServerIdentity","servername","SOCKET_ERROR_EVENTS","Set","useSsl","ssl","keepAlive","keepAliveInitialDelay","noDelay","Math","round","disableRenegotiation","createConnection","setKeepAlive","setTimeout","setNoDelay","connectEvent","cancellationHandler","errorHandler","eventName","forEach","event","removeAllListeners","removeListener","connectHandler","connectionFailureError","authorizationError","once","type","module","exports"],"sources":["C:/Users/Administrator/Desktop/webAPI work/web/dog-website/node_modules/koa-mongo/node_modules/mongodb/lib/core/connection/connect.js"],"sourcesContent":["'use strict';\nconst net = require('net');\nconst tls = require('tls');\nconst Connection = require('./connection');\nconst MongoError = require('../error').MongoError;\nconst MongoNetworkError = require('../error').MongoNetworkError;\nconst MongoNetworkTimeoutError = require('../error').MongoNetworkTimeoutError;\nconst defaultAuthProviders = require('../auth/defaultAuthProviders').defaultAuthProviders;\nconst AuthContext = require('../auth/auth_provider').AuthContext;\nconst WIRE_CONSTANTS = require('../wireprotocol/constants');\nconst makeClientMetadata = require('../utils').makeClientMetadata;\nconst MAX_SUPPORTED_WIRE_VERSION = WIRE_CONSTANTS.MAX_SUPPORTED_WIRE_VERSION;\nconst MAX_SUPPORTED_SERVER_VERSION = WIRE_CONSTANTS.MAX_SUPPORTED_SERVER_VERSION;\nconst MIN_SUPPORTED_WIRE_VERSION = WIRE_CONSTANTS.MIN_SUPPORTED_WIRE_VERSION;\nconst MIN_SUPPORTED_SERVER_VERSION = WIRE_CONSTANTS.MIN_SUPPORTED_SERVER_VERSION;\nlet AUTH_PROVIDERS;\n\nfunction connect(options, cancellationToken, callback) {\n  if (typeof cancellationToken === 'function') {\n    callback = cancellationToken;\n    cancellationToken = undefined;\n  }\n\n  const ConnectionType = options && options.connectionType ? options.connectionType : Connection;\n  if (AUTH_PROVIDERS == null) {\n    AUTH_PROVIDERS = defaultAuthProviders(options.bson);\n  }\n\n  const family = options.family !== void 0 ? options.family : 0;\n  makeConnection(family, options, cancellationToken, (err, socket) => {\n    if (err) {\n      callback(err, socket); // in the error case, `socket` is the originating error event name\n      return;\n    }\n\n    performInitialHandshake(new ConnectionType(socket, options), options, callback);\n  });\n}\n\nfunction isModernConnectionType(conn) {\n  return !(conn instanceof Connection);\n}\n\nfunction checkSupportedServer(ismaster, options) {\n  const serverVersionHighEnough =\n    ismaster &&\n    typeof ismaster.maxWireVersion === 'number' &&\n    ismaster.maxWireVersion >= MIN_SUPPORTED_WIRE_VERSION;\n  const serverVersionLowEnough =\n    ismaster &&\n    typeof ismaster.minWireVersion === 'number' &&\n    ismaster.minWireVersion <= MAX_SUPPORTED_WIRE_VERSION;\n\n  if (serverVersionHighEnough) {\n    if (serverVersionLowEnough) {\n      return null;\n    }\n\n    const message = `Server at ${options.host}:${options.port} reports minimum wire version ${ismaster.minWireVersion}, but this version of the Node.js Driver requires at most ${MAX_SUPPORTED_WIRE_VERSION} (MongoDB ${MAX_SUPPORTED_SERVER_VERSION})`;\n    return new MongoError(message);\n  }\n\n  const message = `Server at ${options.host}:${\n    options.port\n  } reports maximum wire version ${ismaster.maxWireVersion ||\n    0}, but this version of the Node.js Driver requires at least ${MIN_SUPPORTED_WIRE_VERSION} (MongoDB ${MIN_SUPPORTED_SERVER_VERSION})`;\n  return new MongoError(message);\n}\n\nfunction performInitialHandshake(conn, options, _callback) {\n  const callback = function(err, ret) {\n    if (err && conn) {\n      conn.destroy();\n    }\n    _callback(err, ret);\n  };\n\n  const credentials = options.credentials;\n  if (credentials) {\n    if (!credentials.mechanism.match(/DEFAULT/i) && !AUTH_PROVIDERS[credentials.mechanism]) {\n      callback(new MongoError(`authMechanism '${credentials.mechanism}' not supported`));\n      return;\n    }\n  }\n\n  const authContext = new AuthContext(conn, credentials, options);\n  prepareHandshakeDocument(authContext, (err, handshakeDoc) => {\n    if (err) {\n      return callback(err);\n    }\n\n    const handshakeOptions = Object.assign({}, options);\n    if (options.connectTimeoutMS || options.connectionTimeout) {\n      // The handshake technically is a monitoring check, so its socket timeout should be connectTimeoutMS\n      handshakeOptions.socketTimeout = options.connectTimeoutMS || options.connectionTimeout;\n    }\n\n    const start = new Date().getTime();\n    conn.command('admin.$cmd', handshakeDoc, handshakeOptions, (err, result) => {\n      if (err) {\n        callback(err);\n        return;\n      }\n\n      const response = result.result;\n      if (response.ok === 0) {\n        callback(new MongoError(response));\n        return;\n      }\n\n      const supportedServerErr = checkSupportedServer(response, options);\n      if (supportedServerErr) {\n        callback(supportedServerErr);\n        return;\n      }\n\n      if (!isModernConnectionType(conn)) {\n        // resolve compression\n        if (response.compression) {\n          const agreedCompressors = handshakeDoc.compression.filter(\n            compressor => response.compression.indexOf(compressor) !== -1\n          );\n\n          if (agreedCompressors.length) {\n            conn.agreedCompressor = agreedCompressors[0];\n          }\n\n          if (options.compression && options.compression.zlibCompressionLevel) {\n            conn.zlibCompressionLevel = options.compression.zlibCompressionLevel;\n          }\n        }\n      }\n\n      // NOTE: This is metadata attached to the connection while porting away from\n      //       handshake being done in the `Server` class. Likely, it should be\n      //       relocated, or at very least restructured.\n      conn.ismaster = response;\n      conn.lastIsMasterMS = new Date().getTime() - start;\n\n      if (!response.arbiterOnly && credentials) {\n        // store the response on auth context\n        Object.assign(authContext, { response });\n\n        const resolvedCredentials = credentials.resolveAuthMechanism(response);\n        const authProvider = AUTH_PROVIDERS[resolvedCredentials.mechanism];\n        authProvider.auth(authContext, err => {\n          if (err) return callback(err);\n          callback(undefined, conn);\n        });\n\n        return;\n      }\n\n      callback(undefined, conn);\n    });\n  });\n}\n\nfunction prepareHandshakeDocument(authContext, callback) {\n  const options = authContext.options;\n  const compressors =\n    options.compression && options.compression.compressors ? options.compression.compressors : [];\n\n  const handshakeDoc = {\n    ismaster: true,\n    client: options.metadata || makeClientMetadata(options),\n    compression: compressors\n  };\n\n  const credentials = authContext.credentials;\n  if (credentials) {\n    if (credentials.mechanism.match(/DEFAULT/i) && credentials.username) {\n      Object.assign(handshakeDoc, {\n        saslSupportedMechs: `${credentials.source}.${credentials.username}`\n      });\n\n      AUTH_PROVIDERS['scram-sha-256'].prepare(handshakeDoc, authContext, callback);\n      return;\n    }\n\n    const authProvider = AUTH_PROVIDERS[credentials.mechanism];\n    authProvider.prepare(handshakeDoc, authContext, callback);\n    return;\n  }\n\n  callback(undefined, handshakeDoc);\n}\n\nconst LEGAL_SSL_SOCKET_OPTIONS = [\n  'pfx',\n  'key',\n  'passphrase',\n  'cert',\n  'ca',\n  'ciphers',\n  'NPNProtocols',\n  'ALPNProtocols',\n  'servername',\n  'ecdhCurve',\n  'secureProtocol',\n  'secureContext',\n  'session',\n  'minDHSize',\n  'crl',\n  'rejectUnauthorized'\n];\n\nfunction parseConnectOptions(family, options) {\n  const host = typeof options.host === 'string' ? options.host : 'localhost';\n  if (host.indexOf('/') !== -1) {\n    return { path: host };\n  }\n\n  const result = {\n    family,\n    host,\n    port: typeof options.port === 'number' ? options.port : 27017,\n    rejectUnauthorized: false\n  };\n\n  return result;\n}\n\nfunction parseSslOptions(family, options) {\n  const result = parseConnectOptions(family, options);\n\n  // Merge in valid SSL options\n  for (const name in options) {\n    if (options[name] != null && LEGAL_SSL_SOCKET_OPTIONS.indexOf(name) !== -1) {\n      result[name] = options[name];\n    }\n  }\n\n  // Override checkServerIdentity behavior\n  if (options.checkServerIdentity === false) {\n    // Skip the identiy check by retuning undefined as per node documents\n    // https://nodejs.org/api/tls.html#tls_tls_connect_options_callback\n    result.checkServerIdentity = function() {\n      return undefined;\n    };\n  } else if (typeof options.checkServerIdentity === 'function') {\n    result.checkServerIdentity = options.checkServerIdentity;\n  }\n\n  // Set default sni servername to be the same as host\n  if (result.servername == null) {\n    result.servername = result.host;\n  }\n\n  return result;\n}\n\nconst SOCKET_ERROR_EVENTS = new Set(['error', 'close', 'timeout', 'parseError']);\nfunction makeConnection(family, options, cancellationToken, _callback) {\n  const useSsl = typeof options.ssl === 'boolean' ? options.ssl : false;\n  const keepAlive = typeof options.keepAlive === 'boolean' ? options.keepAlive : true;\n  let keepAliveInitialDelay =\n    typeof options.keepAliveInitialDelay === 'number' ? options.keepAliveInitialDelay : 120000;\n  const noDelay = typeof options.noDelay === 'boolean' ? options.noDelay : true;\n  const connectionTimeout =\n    typeof options.connectionTimeout === 'number'\n      ? options.connectionTimeout\n      : typeof options.connectTimeoutMS === 'number'\n      ? options.connectTimeoutMS\n      : 30000;\n  const socketTimeout = typeof options.socketTimeout === 'number' ? options.socketTimeout : 0;\n  const rejectUnauthorized =\n    typeof options.rejectUnauthorized === 'boolean' ? options.rejectUnauthorized : true;\n\n  if (keepAliveInitialDelay > socketTimeout) {\n    keepAliveInitialDelay = Math.round(socketTimeout / 2);\n  }\n\n  let socket;\n  const callback = function(err, ret) {\n    if (err && socket) {\n      socket.destroy();\n    }\n\n    _callback(err, ret);\n  };\n\n  try {\n    if (useSsl) {\n      socket = tls.connect(parseSslOptions(family, options));\n      if (typeof socket.disableRenegotiation === 'function') {\n        socket.disableRenegotiation();\n      }\n    } else {\n      socket = net.createConnection(parseConnectOptions(family, options));\n    }\n  } catch (err) {\n    return callback(err);\n  }\n\n  socket.setKeepAlive(keepAlive, keepAliveInitialDelay);\n  socket.setTimeout(connectionTimeout);\n  socket.setNoDelay(noDelay);\n\n  const connectEvent = useSsl ? 'secureConnect' : 'connect';\n  let cancellationHandler;\n  function errorHandler(eventName) {\n    return err => {\n      SOCKET_ERROR_EVENTS.forEach(event => socket.removeAllListeners(event));\n      if (cancellationHandler) {\n        cancellationToken.removeListener('cancel', cancellationHandler);\n      }\n\n      socket.removeListener(connectEvent, connectHandler);\n      callback(connectionFailureError(eventName, err));\n    };\n  }\n\n  function connectHandler() {\n    SOCKET_ERROR_EVENTS.forEach(event => socket.removeAllListeners(event));\n    if (cancellationHandler) {\n      cancellationToken.removeListener('cancel', cancellationHandler);\n    }\n\n    if (socket.authorizationError && rejectUnauthorized) {\n      return callback(socket.authorizationError);\n    }\n\n    socket.setTimeout(socketTimeout);\n    callback(null, socket);\n  }\n\n  SOCKET_ERROR_EVENTS.forEach(event => socket.once(event, errorHandler(event)));\n  if (cancellationToken) {\n    cancellationHandler = errorHandler('cancel');\n    cancellationToken.once('cancel', cancellationHandler);\n  }\n\n  socket.once(connectEvent, connectHandler);\n}\n\nfunction connectionFailureError(type, err) {\n  switch (type) {\n    case 'error':\n      return new MongoNetworkError(err);\n    case 'timeout':\n      return new MongoNetworkTimeoutError(`connection timed out`);\n    case 'close':\n      return new MongoNetworkError(`connection closed`);\n    case 'cancel':\n      return new MongoNetworkError(`connection establishment was cancelled`);\n    default:\n      return new MongoNetworkError(`unknown network error`);\n  }\n}\n\nmodule.exports = connect;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}