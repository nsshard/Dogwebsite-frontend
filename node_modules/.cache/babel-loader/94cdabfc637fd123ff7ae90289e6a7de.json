{"ast":null,"code":"'use strict';\n\nconst crypto = require('crypto');\n\nconst Buffer = require('safe-buffer').Buffer;\n\nconst retrieveBSON = require('../connection/utils').retrieveBSON;\n\nconst MongoError = require('../error').MongoError;\n\nconst AuthProvider = require('./auth_provider').AuthProvider;\n\nconst BSON = retrieveBSON();\nconst Binary = BSON.Binary;\nlet saslprep;\n\ntry {\n  saslprep = require('saslprep');\n} catch (e) {// don't do anything;\n}\n\nclass ScramSHA extends AuthProvider {\n  constructor(bson, cryptoMethod) {\n    super(bson);\n    this.cryptoMethod = cryptoMethod || 'sha1';\n  }\n\n  prepare(handshakeDoc, authContext, callback) {\n    const cryptoMethod = this.cryptoMethod;\n\n    if (cryptoMethod === 'sha256' && saslprep == null) {\n      console.warn('Warning: no saslprep library specified. Passwords will not be sanitized');\n    }\n\n    crypto.randomBytes(24, (err, nonce) => {\n      if (err) {\n        return callback(err);\n      } // store the nonce for later use\n\n\n      Object.assign(authContext, {\n        nonce\n      });\n      const credentials = authContext.credentials;\n      const request = Object.assign({}, handshakeDoc, {\n        speculativeAuthenticate: Object.assign(makeFirstMessage(cryptoMethod, credentials, nonce), {\n          db: credentials.source\n        })\n      });\n      callback(undefined, request);\n    });\n  }\n\n  auth(authContext, callback) {\n    const response = authContext.response;\n\n    if (response && response.speculativeAuthenticate) {\n      continueScramConversation(this.cryptoMethod, response.speculativeAuthenticate, authContext, callback);\n      return;\n    }\n\n    executeScram(this.cryptoMethod, authContext, callback);\n  }\n\n}\n\nfunction cleanUsername(username) {\n  return username.replace('=', '=3D').replace(',', '=2C');\n}\n\nfunction clientFirstMessageBare(username, nonce) {\n  // NOTE: This is done b/c Javascript uses UTF-16, but the server is hashing in UTF-8.\n  // Since the username is not sasl-prep-d, we need to do this here.\n  return Buffer.concat([Buffer.from('n=', 'utf8'), Buffer.from(username, 'utf8'), Buffer.from(',r=', 'utf8'), Buffer.from(nonce.toString('base64'), 'utf8')]);\n}\n\nfunction makeFirstMessage(cryptoMethod, credentials, nonce) {\n  const username = cleanUsername(credentials.username);\n  const mechanism = cryptoMethod === 'sha1' ? 'SCRAM-SHA-1' : 'SCRAM-SHA-256'; // NOTE: This is done b/c Javascript uses UTF-16, but the server is hashing in UTF-8.\n  // Since the username is not sasl-prep-d, we need to do this here.\n\n  return {\n    saslStart: 1,\n    mechanism,\n    payload: new Binary(Buffer.concat([Buffer.from('n,,', 'utf8'), clientFirstMessageBare(username, nonce)])),\n    autoAuthorize: 1,\n    options: {\n      skipEmptyExchange: true\n    }\n  };\n}\n\nfunction executeScram(cryptoMethod, authContext, callback) {\n  const connection = authContext.connection;\n  const credentials = authContext.credentials;\n  const nonce = authContext.nonce;\n  const db = credentials.source;\n  const saslStartCmd = makeFirstMessage(cryptoMethod, credentials, nonce);\n  connection.command(`${db}.$cmd`, saslStartCmd, (_err, result) => {\n    const err = resolveError(_err, result);\n\n    if (err) {\n      return callback(err);\n    }\n\n    continueScramConversation(cryptoMethod, result.result, authContext, callback);\n  });\n}\n\nfunction continueScramConversation(cryptoMethod, response, authContext, callback) {\n  const connection = authContext.connection;\n  const credentials = authContext.credentials;\n  const nonce = authContext.nonce;\n  const db = credentials.source;\n  const username = cleanUsername(credentials.username);\n  const password = credentials.password;\n  let processedPassword;\n\n  if (cryptoMethod === 'sha256') {\n    processedPassword = saslprep ? saslprep(password) : password;\n  } else {\n    try {\n      processedPassword = passwordDigest(username, password);\n    } catch (e) {\n      return callback(e);\n    }\n  }\n\n  const payload = Buffer.isBuffer(response.payload) ? new Binary(response.payload) : response.payload;\n  const dict = parsePayload(payload.value());\n  const iterations = parseInt(dict.i, 10);\n\n  if (iterations && iterations < 4096) {\n    callback(new MongoError(`Server returned an invalid iteration count ${iterations}`), false);\n    return;\n  }\n\n  const salt = dict.s;\n  const rnonce = dict.r;\n\n  if (rnonce.startsWith('nonce')) {\n    callback(new MongoError(`Server returned an invalid nonce: ${rnonce}`), false);\n    return;\n  } // Set up start of proof\n\n\n  const withoutProof = `c=biws,r=${rnonce}`;\n  const saltedPassword = HI(processedPassword, Buffer.from(salt, 'base64'), iterations, cryptoMethod);\n  const clientKey = HMAC(cryptoMethod, saltedPassword, 'Client Key');\n  const serverKey = HMAC(cryptoMethod, saltedPassword, 'Server Key');\n  const storedKey = H(cryptoMethod, clientKey);\n  const authMessage = [clientFirstMessageBare(username, nonce), payload.value().toString('base64'), withoutProof].join(',');\n  const clientSignature = HMAC(cryptoMethod, storedKey, authMessage);\n  const clientProof = `p=${xor(clientKey, clientSignature)}`;\n  const clientFinal = [withoutProof, clientProof].join(',');\n  const serverSignature = HMAC(cryptoMethod, serverKey, authMessage);\n  const saslContinueCmd = {\n    saslContinue: 1,\n    conversationId: response.conversationId,\n    payload: new Binary(Buffer.from(clientFinal))\n  };\n  connection.command(`${db}.$cmd`, saslContinueCmd, (_err, result) => {\n    const err = resolveError(_err, result);\n\n    if (err) {\n      return callback(err);\n    }\n\n    const r = result.result;\n    const parsedResponse = parsePayload(r.payload.value());\n\n    if (!compareDigest(Buffer.from(parsedResponse.v, 'base64'), serverSignature)) {\n      callback(new MongoError('Server returned an invalid signature'));\n      return;\n    }\n\n    if (!r || r.done !== false) {\n      return callback(err, r);\n    }\n\n    const retrySaslContinueCmd = {\n      saslContinue: 1,\n      conversationId: r.conversationId,\n      payload: Buffer.alloc(0)\n    };\n    connection.command(`${db}.$cmd`, retrySaslContinueCmd, callback);\n  });\n}\n\nfunction parsePayload(payload) {\n  const dict = {};\n  const parts = payload.split(',');\n\n  for (let i = 0; i < parts.length; i++) {\n    const valueParts = parts[i].split('=');\n    dict[valueParts[0]] = valueParts[1];\n  }\n\n  return dict;\n}\n\nfunction passwordDigest(username, password) {\n  if (typeof username !== 'string') {\n    throw new MongoError('username must be a string');\n  }\n\n  if (typeof password !== 'string') {\n    throw new MongoError('password must be a string');\n  }\n\n  if (password.length === 0) {\n    throw new MongoError('password cannot be empty');\n  }\n\n  const md5 = crypto.createHash('md5');\n  md5.update(`${username}:mongo:${password}`, 'utf8');\n  return md5.digest('hex');\n} // XOR two buffers\n\n\nfunction xor(a, b) {\n  if (!Buffer.isBuffer(a)) {\n    a = Buffer.from(a);\n  }\n\n  if (!Buffer.isBuffer(b)) {\n    b = Buffer.from(b);\n  }\n\n  const length = Math.max(a.length, b.length);\n  const res = [];\n\n  for (let i = 0; i < length; i += 1) {\n    res.push(a[i] ^ b[i]);\n  }\n\n  return Buffer.from(res).toString('base64');\n}\n\nfunction H(method, text) {\n  return crypto.createHash(method).update(text).digest();\n}\n\nfunction HMAC(method, key, text) {\n  return crypto.createHmac(method, key).update(text).digest();\n}\n\nlet _hiCache = {};\nlet _hiCacheCount = 0;\n\nfunction _hiCachePurge() {\n  _hiCache = {};\n  _hiCacheCount = 0;\n}\n\nconst hiLengthMap = {\n  sha256: 32,\n  sha1: 20\n};\n\nfunction HI(data, salt, iterations, cryptoMethod) {\n  // omit the work if already generated\n  const key = [data, salt.toString('base64'), iterations].join('_');\n\n  if (_hiCache[key] !== undefined) {\n    return _hiCache[key];\n  } // generate the salt\n\n\n  const saltedData = crypto.pbkdf2Sync(data, salt, iterations, hiLengthMap[cryptoMethod], cryptoMethod); // cache a copy to speed up the next lookup, but prevent unbounded cache growth\n\n  if (_hiCacheCount >= 200) {\n    _hiCachePurge();\n  }\n\n  _hiCache[key] = saltedData;\n  _hiCacheCount += 1;\n  return saltedData;\n}\n\nfunction compareDigest(lhs, rhs) {\n  if (lhs.length !== rhs.length) {\n    return false;\n  }\n\n  if (typeof crypto.timingSafeEqual === 'function') {\n    return crypto.timingSafeEqual(lhs, rhs);\n  }\n\n  let result = 0;\n\n  for (let i = 0; i < lhs.length; i++) {\n    result |= lhs[i] ^ rhs[i];\n  }\n\n  return result === 0;\n}\n\nfunction resolveError(err, result) {\n  if (err) return err;\n  const r = result.result;\n  if (r.$err || r.errmsg) return new MongoError(r);\n}\n\nclass ScramSHA1 extends ScramSHA {\n  constructor(bson) {\n    super(bson, 'sha1');\n  }\n\n}\n\nclass ScramSHA256 extends ScramSHA {\n  constructor(bson) {\n    super(bson, 'sha256');\n  }\n\n}\n\nmodule.exports = {\n  ScramSHA1,\n  ScramSHA256\n};","map":{"version":3,"names":["crypto","require","Buffer","retrieveBSON","MongoError","AuthProvider","BSON","Binary","saslprep","e","ScramSHA","constructor","bson","cryptoMethod","prepare","handshakeDoc","authContext","callback","console","warn","randomBytes","err","nonce","Object","assign","credentials","request","speculativeAuthenticate","makeFirstMessage","db","source","undefined","auth","response","continueScramConversation","executeScram","cleanUsername","username","replace","clientFirstMessageBare","concat","from","toString","mechanism","saslStart","payload","autoAuthorize","options","skipEmptyExchange","connection","saslStartCmd","command","_err","result","resolveError","password","processedPassword","passwordDigest","isBuffer","dict","parsePayload","value","iterations","parseInt","i","salt","s","rnonce","r","startsWith","withoutProof","saltedPassword","HI","clientKey","HMAC","serverKey","storedKey","H","authMessage","join","clientSignature","clientProof","xor","clientFinal","serverSignature","saslContinueCmd","saslContinue","conversationId","parsedResponse","compareDigest","v","done","retrySaslContinueCmd","alloc","parts","split","length","valueParts","md5","createHash","update","digest","a","b","Math","max","res","push","method","text","key","createHmac","_hiCache","_hiCacheCount","_hiCachePurge","hiLengthMap","sha256","sha1","data","saltedData","pbkdf2Sync","lhs","rhs","timingSafeEqual","$err","errmsg","ScramSHA1","ScramSHA256","module","exports"],"sources":["C:/Users/Administrator/Desktop/webAPI work/web/dog-website/node_modules/koa-mongo/node_modules/mongodb/lib/core/auth/scram.js"],"sourcesContent":["'use strict';\nconst crypto = require('crypto');\nconst Buffer = require('safe-buffer').Buffer;\nconst retrieveBSON = require('../connection/utils').retrieveBSON;\nconst MongoError = require('../error').MongoError;\nconst AuthProvider = require('./auth_provider').AuthProvider;\n\nconst BSON = retrieveBSON();\nconst Binary = BSON.Binary;\n\nlet saslprep;\ntry {\n  saslprep = require('saslprep');\n} catch (e) {\n  // don't do anything;\n}\n\nclass ScramSHA extends AuthProvider {\n  constructor(bson, cryptoMethod) {\n    super(bson);\n    this.cryptoMethod = cryptoMethod || 'sha1';\n  }\n\n  prepare(handshakeDoc, authContext, callback) {\n    const cryptoMethod = this.cryptoMethod;\n    if (cryptoMethod === 'sha256' && saslprep == null) {\n      console.warn('Warning: no saslprep library specified. Passwords will not be sanitized');\n    }\n\n    crypto.randomBytes(24, (err, nonce) => {\n      if (err) {\n        return callback(err);\n      }\n\n      // store the nonce for later use\n      Object.assign(authContext, { nonce });\n\n      const credentials = authContext.credentials;\n      const request = Object.assign({}, handshakeDoc, {\n        speculativeAuthenticate: Object.assign(makeFirstMessage(cryptoMethod, credentials, nonce), {\n          db: credentials.source\n        })\n      });\n\n      callback(undefined, request);\n    });\n  }\n\n  auth(authContext, callback) {\n    const response = authContext.response;\n    if (response && response.speculativeAuthenticate) {\n      continueScramConversation(\n        this.cryptoMethod,\n        response.speculativeAuthenticate,\n        authContext,\n        callback\n      );\n\n      return;\n    }\n\n    executeScram(this.cryptoMethod, authContext, callback);\n  }\n}\n\nfunction cleanUsername(username) {\n  return username.replace('=', '=3D').replace(',', '=2C');\n}\n\nfunction clientFirstMessageBare(username, nonce) {\n  // NOTE: This is done b/c Javascript uses UTF-16, but the server is hashing in UTF-8.\n  // Since the username is not sasl-prep-d, we need to do this here.\n  return Buffer.concat([\n    Buffer.from('n=', 'utf8'),\n    Buffer.from(username, 'utf8'),\n    Buffer.from(',r=', 'utf8'),\n    Buffer.from(nonce.toString('base64'), 'utf8')\n  ]);\n}\n\nfunction makeFirstMessage(cryptoMethod, credentials, nonce) {\n  const username = cleanUsername(credentials.username);\n  const mechanism = cryptoMethod === 'sha1' ? 'SCRAM-SHA-1' : 'SCRAM-SHA-256';\n\n  // NOTE: This is done b/c Javascript uses UTF-16, but the server is hashing in UTF-8.\n  // Since the username is not sasl-prep-d, we need to do this here.\n  return {\n    saslStart: 1,\n    mechanism,\n    payload: new Binary(\n      Buffer.concat([Buffer.from('n,,', 'utf8'), clientFirstMessageBare(username, nonce)])\n    ),\n    autoAuthorize: 1,\n    options: { skipEmptyExchange: true }\n  };\n}\n\nfunction executeScram(cryptoMethod, authContext, callback) {\n  const connection = authContext.connection;\n  const credentials = authContext.credentials;\n  const nonce = authContext.nonce;\n  const db = credentials.source;\n\n  const saslStartCmd = makeFirstMessage(cryptoMethod, credentials, nonce);\n  connection.command(`${db}.$cmd`, saslStartCmd, (_err, result) => {\n    const err = resolveError(_err, result);\n    if (err) {\n      return callback(err);\n    }\n\n    continueScramConversation(cryptoMethod, result.result, authContext, callback);\n  });\n}\n\nfunction continueScramConversation(cryptoMethod, response, authContext, callback) {\n  const connection = authContext.connection;\n  const credentials = authContext.credentials;\n  const nonce = authContext.nonce;\n\n  const db = credentials.source;\n  const username = cleanUsername(credentials.username);\n  const password = credentials.password;\n\n  let processedPassword;\n  if (cryptoMethod === 'sha256') {\n    processedPassword = saslprep ? saslprep(password) : password;\n  } else {\n    try {\n      processedPassword = passwordDigest(username, password);\n    } catch (e) {\n      return callback(e);\n    }\n  }\n\n  const payload = Buffer.isBuffer(response.payload)\n    ? new Binary(response.payload)\n    : response.payload;\n  const dict = parsePayload(payload.value());\n\n  const iterations = parseInt(dict.i, 10);\n  if (iterations && iterations < 4096) {\n    callback(new MongoError(`Server returned an invalid iteration count ${iterations}`), false);\n    return;\n  }\n\n  const salt = dict.s;\n  const rnonce = dict.r;\n  if (rnonce.startsWith('nonce')) {\n    callback(new MongoError(`Server returned an invalid nonce: ${rnonce}`), false);\n    return;\n  }\n\n  // Set up start of proof\n  const withoutProof = `c=biws,r=${rnonce}`;\n  const saltedPassword = HI(\n    processedPassword,\n    Buffer.from(salt, 'base64'),\n    iterations,\n    cryptoMethod\n  );\n\n  const clientKey = HMAC(cryptoMethod, saltedPassword, 'Client Key');\n  const serverKey = HMAC(cryptoMethod, saltedPassword, 'Server Key');\n  const storedKey = H(cryptoMethod, clientKey);\n  const authMessage = [\n    clientFirstMessageBare(username, nonce),\n    payload.value().toString('base64'),\n    withoutProof\n  ].join(',');\n\n  const clientSignature = HMAC(cryptoMethod, storedKey, authMessage);\n  const clientProof = `p=${xor(clientKey, clientSignature)}`;\n  const clientFinal = [withoutProof, clientProof].join(',');\n\n  const serverSignature = HMAC(cryptoMethod, serverKey, authMessage);\n  const saslContinueCmd = {\n    saslContinue: 1,\n    conversationId: response.conversationId,\n    payload: new Binary(Buffer.from(clientFinal))\n  };\n\n  connection.command(`${db}.$cmd`, saslContinueCmd, (_err, result) => {\n    const err = resolveError(_err, result);\n    if (err) {\n      return callback(err);\n    }\n\n    const r = result.result;\n    const parsedResponse = parsePayload(r.payload.value());\n    if (!compareDigest(Buffer.from(parsedResponse.v, 'base64'), serverSignature)) {\n      callback(new MongoError('Server returned an invalid signature'));\n      return;\n    }\n\n    if (!r || r.done !== false) {\n      return callback(err, r);\n    }\n\n    const retrySaslContinueCmd = {\n      saslContinue: 1,\n      conversationId: r.conversationId,\n      payload: Buffer.alloc(0)\n    };\n\n    connection.command(`${db}.$cmd`, retrySaslContinueCmd, callback);\n  });\n}\n\nfunction parsePayload(payload) {\n  const dict = {};\n  const parts = payload.split(',');\n  for (let i = 0; i < parts.length; i++) {\n    const valueParts = parts[i].split('=');\n    dict[valueParts[0]] = valueParts[1];\n  }\n\n  return dict;\n}\n\nfunction passwordDigest(username, password) {\n  if (typeof username !== 'string') {\n    throw new MongoError('username must be a string');\n  }\n\n  if (typeof password !== 'string') {\n    throw new MongoError('password must be a string');\n  }\n\n  if (password.length === 0) {\n    throw new MongoError('password cannot be empty');\n  }\n\n  const md5 = crypto.createHash('md5');\n  md5.update(`${username}:mongo:${password}`, 'utf8');\n  return md5.digest('hex');\n}\n\n// XOR two buffers\nfunction xor(a, b) {\n  if (!Buffer.isBuffer(a)) {\n    a = Buffer.from(a);\n  }\n\n  if (!Buffer.isBuffer(b)) {\n    b = Buffer.from(b);\n  }\n\n  const length = Math.max(a.length, b.length);\n  const res = [];\n\n  for (let i = 0; i < length; i += 1) {\n    res.push(a[i] ^ b[i]);\n  }\n\n  return Buffer.from(res).toString('base64');\n}\n\nfunction H(method, text) {\n  return crypto\n    .createHash(method)\n    .update(text)\n    .digest();\n}\n\nfunction HMAC(method, key, text) {\n  return crypto\n    .createHmac(method, key)\n    .update(text)\n    .digest();\n}\n\nlet _hiCache = {};\nlet _hiCacheCount = 0;\nfunction _hiCachePurge() {\n  _hiCache = {};\n  _hiCacheCount = 0;\n}\n\nconst hiLengthMap = {\n  sha256: 32,\n  sha1: 20\n};\n\nfunction HI(data, salt, iterations, cryptoMethod) {\n  // omit the work if already generated\n  const key = [data, salt.toString('base64'), iterations].join('_');\n  if (_hiCache[key] !== undefined) {\n    return _hiCache[key];\n  }\n\n  // generate the salt\n  const saltedData = crypto.pbkdf2Sync(\n    data,\n    salt,\n    iterations,\n    hiLengthMap[cryptoMethod],\n    cryptoMethod\n  );\n\n  // cache a copy to speed up the next lookup, but prevent unbounded cache growth\n  if (_hiCacheCount >= 200) {\n    _hiCachePurge();\n  }\n\n  _hiCache[key] = saltedData;\n  _hiCacheCount += 1;\n  return saltedData;\n}\n\nfunction compareDigest(lhs, rhs) {\n  if (lhs.length !== rhs.length) {\n    return false;\n  }\n\n  if (typeof crypto.timingSafeEqual === 'function') {\n    return crypto.timingSafeEqual(lhs, rhs);\n  }\n\n  let result = 0;\n  for (let i = 0; i < lhs.length; i++) {\n    result |= lhs[i] ^ rhs[i];\n  }\n\n  return result === 0;\n}\n\nfunction resolveError(err, result) {\n  if (err) return err;\n\n  const r = result.result;\n  if (r.$err || r.errmsg) return new MongoError(r);\n}\n\nclass ScramSHA1 extends ScramSHA {\n  constructor(bson) {\n    super(bson, 'sha1');\n  }\n}\n\nclass ScramSHA256 extends ScramSHA {\n  constructor(bson) {\n    super(bson, 'sha256');\n  }\n}\n\nmodule.exports = { ScramSHA1, ScramSHA256 };\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}