{"ast":null,"code":"'use strict';\n\nconst EventEmitter = require('events');\n\nconst MessageStream = require('./message_stream');\n\nconst MongoError = require('../core/error').MongoError;\n\nconst MongoNetworkError = require('../core/error').MongoNetworkError;\n\nconst MongoNetworkTimeoutError = require('../core/error').MongoNetworkTimeoutError;\n\nconst MongoWriteConcernError = require('../core/error').MongoWriteConcernError;\n\nconst CommandResult = require('../core/connection/command_result');\n\nconst StreamDescription = require('./stream_description').StreamDescription;\n\nconst wp = require('../core/wireprotocol');\n\nconst apm = require('../core/connection/apm');\n\nconst updateSessionFromResponse = require('../core/sessions').updateSessionFromResponse;\n\nconst uuidV4 = require('../core/utils').uuidV4;\n\nconst now = require('../utils').now;\n\nconst calculateDurationInMs = require('../utils').calculateDurationInMs;\n\nconst kStream = Symbol('stream');\nconst kQueue = Symbol('queue');\nconst kMessageStream = Symbol('messageStream');\nconst kGeneration = Symbol('generation');\nconst kLastUseTime = Symbol('lastUseTime');\nconst kClusterTime = Symbol('clusterTime');\nconst kDescription = Symbol('description');\nconst kIsMaster = Symbol('ismaster');\nconst kAutoEncrypter = Symbol('autoEncrypter');\n\nclass Connection extends EventEmitter {\n  constructor(stream, options) {\n    super(options);\n    this.id = options.id;\n    this.address = streamIdentifier(stream);\n    this.bson = options.bson;\n    this.socketTimeout = typeof options.socketTimeout === 'number' ? options.socketTimeout : 0;\n    this.host = options.host || 'localhost';\n    this.port = options.port || 27017;\n    this.monitorCommands = typeof options.monitorCommands === 'boolean' ? options.monitorCommands : false;\n    this.closed = false;\n    this.destroyed = false;\n    this[kDescription] = new StreamDescription(this.address, options);\n    this[kGeneration] = options.generation;\n    this[kLastUseTime] = now(); // retain a reference to an `AutoEncrypter` if present\n\n    if (options.autoEncrypter) {\n      this[kAutoEncrypter] = options.autoEncrypter;\n    } // setup parser stream and message handling\n\n\n    this[kQueue] = new Map();\n    this[kMessageStream] = new MessageStream(options);\n    this[kMessageStream].on('message', messageHandler(this));\n    this[kStream] = stream;\n    stream.on('error', () => {\n      /* ignore errors, listen to `close` instead */\n    });\n    stream.on('close', () => {\n      if (this.closed) {\n        return;\n      }\n\n      this.closed = true;\n      this[kQueue].forEach(op => op.cb(new MongoNetworkError(`connection ${this.id} to ${this.address} closed`)));\n      this[kQueue].clear();\n      this.emit('close');\n    });\n    stream.on('timeout', () => {\n      if (this.closed) {\n        return;\n      }\n\n      stream.destroy();\n      this.closed = true;\n      this[kQueue].forEach(op => op.cb(new MongoNetworkTimeoutError(`connection ${this.id} to ${this.address} timed out`, {\n        beforeHandshake: this[kIsMaster] == null\n      })));\n      this[kQueue].clear();\n      this.emit('close');\n    }); // hook the message stream up to the passed in stream\n\n    stream.pipe(this[kMessageStream]);\n    this[kMessageStream].pipe(stream);\n  }\n\n  get description() {\n    return this[kDescription];\n  }\n\n  get ismaster() {\n    return this[kIsMaster];\n  } // the `connect` method stores the result of the handshake ismaster on the connection\n\n\n  set ismaster(response) {\n    this[kDescription].receiveResponse(response); // TODO: remove this, and only use the `StreamDescription` in the future\n\n    this[kIsMaster] = response;\n  }\n\n  get generation() {\n    return this[kGeneration] || 0;\n  }\n\n  get idleTime() {\n    return calculateDurationInMs(this[kLastUseTime]);\n  }\n\n  get clusterTime() {\n    return this[kClusterTime];\n  }\n\n  get stream() {\n    return this[kStream];\n  }\n\n  markAvailable() {\n    this[kLastUseTime] = now();\n  }\n\n  destroy(options, callback) {\n    if (typeof options === 'function') {\n      callback = options;\n      options = {};\n    }\n\n    options = Object.assign({\n      force: false\n    }, options);\n\n    if (this[kStream] == null || this.destroyed) {\n      this.destroyed = true;\n\n      if (typeof callback === 'function') {\n        callback();\n      }\n\n      return;\n    }\n\n    if (options.force) {\n      this[kStream].destroy();\n      this.destroyed = true;\n\n      if (typeof callback === 'function') {\n        callback();\n      }\n\n      return;\n    }\n\n    this[kStream].end(err => {\n      this.destroyed = true;\n\n      if (typeof callback === 'function') {\n        callback(err);\n      }\n    });\n  } // Wire protocol methods\n\n\n  command(ns, cmd, options, callback) {\n    wp.command(makeServerTrampoline(this), ns, cmd, options, callback);\n  }\n\n  query(ns, cmd, cursorState, options, callback) {\n    wp.query(makeServerTrampoline(this), ns, cmd, cursorState, options, callback);\n  }\n\n  getMore(ns, cursorState, batchSize, options, callback) {\n    wp.getMore(makeServerTrampoline(this), ns, cursorState, batchSize, options, callback);\n  }\n\n  killCursors(ns, cursorState, callback) {\n    wp.killCursors(makeServerTrampoline(this), ns, cursorState, callback);\n  }\n\n  insert(ns, ops, options, callback) {\n    wp.insert(makeServerTrampoline(this), ns, ops, options, callback);\n  }\n\n  update(ns, ops, options, callback) {\n    wp.update(makeServerTrampoline(this), ns, ops, options, callback);\n  }\n\n  remove(ns, ops, options, callback) {\n    wp.remove(makeServerTrampoline(this), ns, ops, options, callback);\n  }\n\n} /// This lets us emulate a legacy `Server` instance so we can work with the existing wire\n/// protocol methods. Eventually, the operation executor will return a `Connection` to execute\n/// against.\n\n\nfunction makeServerTrampoline(connection) {\n  const server = {\n    description: connection.description,\n    clusterTime: connection[kClusterTime],\n    s: {\n      bson: connection.bson,\n      pool: {\n        write: write.bind(connection),\n        isConnected: () => true\n      }\n    }\n  };\n\n  if (connection[kAutoEncrypter]) {\n    server.autoEncrypter = connection[kAutoEncrypter];\n  }\n\n  return server;\n}\n\nfunction messageHandler(conn) {\n  return function messageHandler(message) {\n    // always emit the message, in case we are streaming\n    conn.emit('message', message);\n\n    if (!conn[kQueue].has(message.responseTo)) {\n      return;\n    }\n\n    const operationDescription = conn[kQueue].get(message.responseTo);\n    const callback = operationDescription.cb; // SERVER-45775: For exhaust responses we should be able to use the same requestId to\n    // track response, however the server currently synthetically produces remote requests\n    // making the `responseTo` change on each response\n\n    conn[kQueue].delete(message.responseTo);\n\n    if (message.moreToCome) {\n      // requeue the callback for next synthetic request\n      conn[kQueue].set(message.requestId, operationDescription);\n    } else if (operationDescription.socketTimeoutOverride) {\n      conn[kStream].setTimeout(conn.socketTimeout);\n    }\n\n    try {\n      // Pass in the entire description because it has BSON parsing options\n      message.parse(operationDescription);\n    } catch (err) {\n      callback(new MongoError(err));\n      return;\n    }\n\n    if (message.documents[0]) {\n      const document = message.documents[0];\n      const session = operationDescription.session;\n\n      if (session) {\n        updateSessionFromResponse(session, document);\n      }\n\n      if (document.$clusterTime) {\n        conn[kClusterTime] = document.$clusterTime;\n        conn.emit('clusterTimeReceived', document.$clusterTime);\n      }\n\n      if (operationDescription.command) {\n        if (document.writeConcernError) {\n          callback(new MongoWriteConcernError(document.writeConcernError, document));\n          return;\n        }\n\n        if (document.ok === 0 || document.$err || document.errmsg || document.code) {\n          callback(new MongoError(document));\n          return;\n        }\n      }\n    } // NODE-2382: reenable in our glorious non-leaky abstraction future\n    // callback(null, operationDescription.fullResult ? message : message.documents[0]);\n\n\n    callback(undefined, new CommandResult(operationDescription.fullResult ? message : message.documents[0], conn, message));\n  };\n}\n\nfunction streamIdentifier(stream) {\n  if (typeof stream.address === 'function') {\n    return `${stream.remoteAddress}:${stream.remotePort}`;\n  }\n\n  return uuidV4().toString('hex');\n} // Not meant to be called directly, the wire protocol methods call this assuming it is a `Pool` instance\n\n\nfunction write(command, options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n  }\n\n  options = options || {};\n  const operationDescription = {\n    requestId: command.requestId,\n    cb: callback,\n    session: options.session,\n    fullResult: typeof options.fullResult === 'boolean' ? options.fullResult : false,\n    noResponse: typeof options.noResponse === 'boolean' ? options.noResponse : false,\n    documentsReturnedIn: options.documentsReturnedIn,\n    command: !!options.command,\n    // for BSON parsing\n    promoteLongs: typeof options.promoteLongs === 'boolean' ? options.promoteLongs : true,\n    promoteValues: typeof options.promoteValues === 'boolean' ? options.promoteValues : true,\n    promoteBuffers: typeof options.promoteBuffers === 'boolean' ? options.promoteBuffers : false,\n    raw: typeof options.raw === 'boolean' ? options.raw : false\n  };\n\n  if (this[kDescription] && this[kDescription].compressor) {\n    operationDescription.agreedCompressor = this[kDescription].compressor;\n\n    if (this[kDescription].zlibCompressionLevel) {\n      operationDescription.zlibCompressionLevel = this[kDescription].zlibCompressionLevel;\n    }\n  }\n\n  if (typeof options.socketTimeout === 'number') {\n    operationDescription.socketTimeoutOverride = true;\n    this[kStream].setTimeout(options.socketTimeout);\n  } // if command monitoring is enabled we need to modify the callback here\n\n\n  if (this.monitorCommands) {\n    this.emit('commandStarted', new apm.CommandStartedEvent(this, command));\n    operationDescription.started = now();\n\n    operationDescription.cb = (err, reply) => {\n      if (err) {\n        this.emit('commandFailed', new apm.CommandFailedEvent(this, command, err, operationDescription.started));\n      } else {\n        if (reply && reply.result && (reply.result.ok === 0 || reply.result.$err)) {\n          this.emit('commandFailed', new apm.CommandFailedEvent(this, command, reply.result, operationDescription.started));\n        } else {\n          this.emit('commandSucceeded', new apm.CommandSucceededEvent(this, command, reply, operationDescription.started));\n        }\n      }\n\n      if (typeof callback === 'function') {\n        callback(err, reply);\n      }\n    };\n  }\n\n  if (!operationDescription.noResponse) {\n    this[kQueue].set(operationDescription.requestId, operationDescription);\n  }\n\n  try {\n    this[kMessageStream].writeCommand(command, operationDescription);\n  } catch (e) {\n    if (!operationDescription.noResponse) {\n      this[kQueue].delete(operationDescription.requestId);\n      operationDescription.cb(e);\n      return;\n    }\n  }\n\n  if (operationDescription.noResponse) {\n    operationDescription.cb();\n  }\n}\n\nmodule.exports = {\n  Connection\n};","map":{"version":3,"names":["EventEmitter","require","MessageStream","MongoError","MongoNetworkError","MongoNetworkTimeoutError","MongoWriteConcernError","CommandResult","StreamDescription","wp","apm","updateSessionFromResponse","uuidV4","now","calculateDurationInMs","kStream","Symbol","kQueue","kMessageStream","kGeneration","kLastUseTime","kClusterTime","kDescription","kIsMaster","kAutoEncrypter","Connection","constructor","stream","options","id","address","streamIdentifier","bson","socketTimeout","host","port","monitorCommands","closed","destroyed","generation","autoEncrypter","Map","on","messageHandler","forEach","op","cb","clear","emit","destroy","beforeHandshake","pipe","description","ismaster","response","receiveResponse","idleTime","clusterTime","markAvailable","callback","Object","assign","force","end","err","command","ns","cmd","makeServerTrampoline","query","cursorState","getMore","batchSize","killCursors","insert","ops","update","remove","connection","server","s","pool","write","bind","isConnected","conn","message","has","responseTo","operationDescription","get","delete","moreToCome","set","requestId","socketTimeoutOverride","setTimeout","parse","documents","document","session","$clusterTime","writeConcernError","ok","$err","errmsg","code","undefined","fullResult","remoteAddress","remotePort","toString","noResponse","documentsReturnedIn","promoteLongs","promoteValues","promoteBuffers","raw","compressor","agreedCompressor","zlibCompressionLevel","CommandStartedEvent","started","reply","CommandFailedEvent","result","CommandSucceededEvent","writeCommand","e","module","exports"],"sources":["C:/Users/Administrator/Desktop/webAPI work/web/dog-website/node_modules/koa-mongo/node_modules/mongodb/lib/cmap/connection.js"],"sourcesContent":["'use strict';\n\nconst EventEmitter = require('events');\nconst MessageStream = require('./message_stream');\nconst MongoError = require('../core/error').MongoError;\nconst MongoNetworkError = require('../core/error').MongoNetworkError;\nconst MongoNetworkTimeoutError = require('../core/error').MongoNetworkTimeoutError;\nconst MongoWriteConcernError = require('../core/error').MongoWriteConcernError;\nconst CommandResult = require('../core/connection/command_result');\nconst StreamDescription = require('./stream_description').StreamDescription;\nconst wp = require('../core/wireprotocol');\nconst apm = require('../core/connection/apm');\nconst updateSessionFromResponse = require('../core/sessions').updateSessionFromResponse;\nconst uuidV4 = require('../core/utils').uuidV4;\nconst now = require('../utils').now;\nconst calculateDurationInMs = require('../utils').calculateDurationInMs;\n\nconst kStream = Symbol('stream');\nconst kQueue = Symbol('queue');\nconst kMessageStream = Symbol('messageStream');\nconst kGeneration = Symbol('generation');\nconst kLastUseTime = Symbol('lastUseTime');\nconst kClusterTime = Symbol('clusterTime');\nconst kDescription = Symbol('description');\nconst kIsMaster = Symbol('ismaster');\nconst kAutoEncrypter = Symbol('autoEncrypter');\n\nclass Connection extends EventEmitter {\n  constructor(stream, options) {\n    super(options);\n\n    this.id = options.id;\n    this.address = streamIdentifier(stream);\n    this.bson = options.bson;\n    this.socketTimeout = typeof options.socketTimeout === 'number' ? options.socketTimeout : 0;\n    this.host = options.host || 'localhost';\n    this.port = options.port || 27017;\n    this.monitorCommands =\n      typeof options.monitorCommands === 'boolean' ? options.monitorCommands : false;\n    this.closed = false;\n    this.destroyed = false;\n\n    this[kDescription] = new StreamDescription(this.address, options);\n    this[kGeneration] = options.generation;\n    this[kLastUseTime] = now();\n\n    // retain a reference to an `AutoEncrypter` if present\n    if (options.autoEncrypter) {\n      this[kAutoEncrypter] = options.autoEncrypter;\n    }\n\n    // setup parser stream and message handling\n    this[kQueue] = new Map();\n    this[kMessageStream] = new MessageStream(options);\n    this[kMessageStream].on('message', messageHandler(this));\n    this[kStream] = stream;\n    stream.on('error', () => {\n      /* ignore errors, listen to `close` instead */\n    });\n\n    stream.on('close', () => {\n      if (this.closed) {\n        return;\n      }\n\n      this.closed = true;\n      this[kQueue].forEach(op =>\n        op.cb(new MongoNetworkError(`connection ${this.id} to ${this.address} closed`))\n      );\n      this[kQueue].clear();\n\n      this.emit('close');\n    });\n\n    stream.on('timeout', () => {\n      if (this.closed) {\n        return;\n      }\n\n      stream.destroy();\n      this.closed = true;\n      this[kQueue].forEach(op =>\n        op.cb(\n          new MongoNetworkTimeoutError(`connection ${this.id} to ${this.address} timed out`, {\n            beforeHandshake: this[kIsMaster] == null\n          })\n        )\n      );\n\n      this[kQueue].clear();\n      this.emit('close');\n    });\n\n    // hook the message stream up to the passed in stream\n    stream.pipe(this[kMessageStream]);\n    this[kMessageStream].pipe(stream);\n  }\n\n  get description() {\n    return this[kDescription];\n  }\n\n  get ismaster() {\n    return this[kIsMaster];\n  }\n\n  // the `connect` method stores the result of the handshake ismaster on the connection\n  set ismaster(response) {\n    this[kDescription].receiveResponse(response);\n\n    // TODO: remove this, and only use the `StreamDescription` in the future\n    this[kIsMaster] = response;\n  }\n\n  get generation() {\n    return this[kGeneration] || 0;\n  }\n\n  get idleTime() {\n    return calculateDurationInMs(this[kLastUseTime]);\n  }\n\n  get clusterTime() {\n    return this[kClusterTime];\n  }\n\n  get stream() {\n    return this[kStream];\n  }\n\n  markAvailable() {\n    this[kLastUseTime] = now();\n  }\n\n  destroy(options, callback) {\n    if (typeof options === 'function') {\n      callback = options;\n      options = {};\n    }\n\n    options = Object.assign({ force: false }, options);\n    if (this[kStream] == null || this.destroyed) {\n      this.destroyed = true;\n      if (typeof callback === 'function') {\n        callback();\n      }\n\n      return;\n    }\n\n    if (options.force) {\n      this[kStream].destroy();\n      this.destroyed = true;\n      if (typeof callback === 'function') {\n        callback();\n      }\n\n      return;\n    }\n\n    this[kStream].end(err => {\n      this.destroyed = true;\n      if (typeof callback === 'function') {\n        callback(err);\n      }\n    });\n  }\n\n  // Wire protocol methods\n  command(ns, cmd, options, callback) {\n    wp.command(makeServerTrampoline(this), ns, cmd, options, callback);\n  }\n\n  query(ns, cmd, cursorState, options, callback) {\n    wp.query(makeServerTrampoline(this), ns, cmd, cursorState, options, callback);\n  }\n\n  getMore(ns, cursorState, batchSize, options, callback) {\n    wp.getMore(makeServerTrampoline(this), ns, cursorState, batchSize, options, callback);\n  }\n\n  killCursors(ns, cursorState, callback) {\n    wp.killCursors(makeServerTrampoline(this), ns, cursorState, callback);\n  }\n\n  insert(ns, ops, options, callback) {\n    wp.insert(makeServerTrampoline(this), ns, ops, options, callback);\n  }\n\n  update(ns, ops, options, callback) {\n    wp.update(makeServerTrampoline(this), ns, ops, options, callback);\n  }\n\n  remove(ns, ops, options, callback) {\n    wp.remove(makeServerTrampoline(this), ns, ops, options, callback);\n  }\n}\n\n/// This lets us emulate a legacy `Server` instance so we can work with the existing wire\n/// protocol methods. Eventually, the operation executor will return a `Connection` to execute\n/// against.\nfunction makeServerTrampoline(connection) {\n  const server = {\n    description: connection.description,\n    clusterTime: connection[kClusterTime],\n    s: {\n      bson: connection.bson,\n      pool: { write: write.bind(connection), isConnected: () => true }\n    }\n  };\n\n  if (connection[kAutoEncrypter]) {\n    server.autoEncrypter = connection[kAutoEncrypter];\n  }\n\n  return server;\n}\n\nfunction messageHandler(conn) {\n  return function messageHandler(message) {\n    // always emit the message, in case we are streaming\n    conn.emit('message', message);\n    if (!conn[kQueue].has(message.responseTo)) {\n      return;\n    }\n\n    const operationDescription = conn[kQueue].get(message.responseTo);\n    const callback = operationDescription.cb;\n\n    // SERVER-45775: For exhaust responses we should be able to use the same requestId to\n    // track response, however the server currently synthetically produces remote requests\n    // making the `responseTo` change on each response\n    conn[kQueue].delete(message.responseTo);\n    if (message.moreToCome) {\n      // requeue the callback for next synthetic request\n      conn[kQueue].set(message.requestId, operationDescription);\n    } else if (operationDescription.socketTimeoutOverride) {\n      conn[kStream].setTimeout(conn.socketTimeout);\n    }\n\n    try {\n      // Pass in the entire description because it has BSON parsing options\n      message.parse(operationDescription);\n    } catch (err) {\n      callback(new MongoError(err));\n      return;\n    }\n\n    if (message.documents[0]) {\n      const document = message.documents[0];\n      const session = operationDescription.session;\n      if (session) {\n        updateSessionFromResponse(session, document);\n      }\n\n      if (document.$clusterTime) {\n        conn[kClusterTime] = document.$clusterTime;\n        conn.emit('clusterTimeReceived', document.$clusterTime);\n      }\n\n      if (operationDescription.command) {\n        if (document.writeConcernError) {\n          callback(new MongoWriteConcernError(document.writeConcernError, document));\n          return;\n        }\n\n        if (document.ok === 0 || document.$err || document.errmsg || document.code) {\n          callback(new MongoError(document));\n          return;\n        }\n      }\n    }\n\n    // NODE-2382: reenable in our glorious non-leaky abstraction future\n    // callback(null, operationDescription.fullResult ? message : message.documents[0]);\n\n    callback(\n      undefined,\n      new CommandResult(\n        operationDescription.fullResult ? message : message.documents[0],\n        conn,\n        message\n      )\n    );\n  };\n}\n\nfunction streamIdentifier(stream) {\n  if (typeof stream.address === 'function') {\n    return `${stream.remoteAddress}:${stream.remotePort}`;\n  }\n\n  return uuidV4().toString('hex');\n}\n\n// Not meant to be called directly, the wire protocol methods call this assuming it is a `Pool` instance\nfunction write(command, options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n  }\n\n  options = options || {};\n  const operationDescription = {\n    requestId: command.requestId,\n    cb: callback,\n    session: options.session,\n    fullResult: typeof options.fullResult === 'boolean' ? options.fullResult : false,\n    noResponse: typeof options.noResponse === 'boolean' ? options.noResponse : false,\n    documentsReturnedIn: options.documentsReturnedIn,\n    command: !!options.command,\n\n    // for BSON parsing\n    promoteLongs: typeof options.promoteLongs === 'boolean' ? options.promoteLongs : true,\n    promoteValues: typeof options.promoteValues === 'boolean' ? options.promoteValues : true,\n    promoteBuffers: typeof options.promoteBuffers === 'boolean' ? options.promoteBuffers : false,\n    raw: typeof options.raw === 'boolean' ? options.raw : false\n  };\n\n  if (this[kDescription] && this[kDescription].compressor) {\n    operationDescription.agreedCompressor = this[kDescription].compressor;\n\n    if (this[kDescription].zlibCompressionLevel) {\n      operationDescription.zlibCompressionLevel = this[kDescription].zlibCompressionLevel;\n    }\n  }\n\n  if (typeof options.socketTimeout === 'number') {\n    operationDescription.socketTimeoutOverride = true;\n    this[kStream].setTimeout(options.socketTimeout);\n  }\n\n  // if command monitoring is enabled we need to modify the callback here\n  if (this.monitorCommands) {\n    this.emit('commandStarted', new apm.CommandStartedEvent(this, command));\n\n    operationDescription.started = now();\n    operationDescription.cb = (err, reply) => {\n      if (err) {\n        this.emit(\n          'commandFailed',\n          new apm.CommandFailedEvent(this, command, err, operationDescription.started)\n        );\n      } else {\n        if (reply && reply.result && (reply.result.ok === 0 || reply.result.$err)) {\n          this.emit(\n            'commandFailed',\n            new apm.CommandFailedEvent(this, command, reply.result, operationDescription.started)\n          );\n        } else {\n          this.emit(\n            'commandSucceeded',\n            new apm.CommandSucceededEvent(this, command, reply, operationDescription.started)\n          );\n        }\n      }\n\n      if (typeof callback === 'function') {\n        callback(err, reply);\n      }\n    };\n  }\n\n  if (!operationDescription.noResponse) {\n    this[kQueue].set(operationDescription.requestId, operationDescription);\n  }\n\n  try {\n    this[kMessageStream].writeCommand(command, operationDescription);\n  } catch (e) {\n    if (!operationDescription.noResponse) {\n      this[kQueue].delete(operationDescription.requestId);\n      operationDescription.cb(e);\n      return;\n    }\n  }\n\n  if (operationDescription.noResponse) {\n    operationDescription.cb();\n  }\n}\n\nmodule.exports = {\n  Connection\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}