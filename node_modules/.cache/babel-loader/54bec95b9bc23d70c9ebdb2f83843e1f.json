{"ast":null,"code":"'use strict';\n\nconst EventEmitter = require('events').EventEmitter;\n\nconst crypto = require('crypto');\n\nconst debugOptions = require('./utils').debugOptions;\n\nconst parseHeader = require('../wireprotocol/shared').parseHeader;\n\nconst decompress = require('../wireprotocol/compression').decompress;\n\nconst Response = require('./commands').Response;\n\nconst BinMsg = require('./msg').BinMsg;\n\nconst MongoNetworkError = require('../error').MongoNetworkError;\n\nconst MongoNetworkTimeoutError = require('../error').MongoNetworkTimeoutError;\n\nconst MongoError = require('../error').MongoError;\n\nconst Logger = require('./logger');\n\nconst OP_COMPRESSED = require('../wireprotocol/shared').opcodes.OP_COMPRESSED;\n\nconst OP_MSG = require('../wireprotocol/shared').opcodes.OP_MSG;\n\nconst MESSAGE_HEADER_SIZE = require('../wireprotocol/shared').MESSAGE_HEADER_SIZE;\n\nconst Buffer = require('safe-buffer').Buffer;\n\nconst Query = require('./commands').Query;\n\nconst CommandResult = require('./command_result');\n\nlet _id = 0;\nconst DEFAULT_MAX_BSON_MESSAGE_SIZE = 1024 * 1024 * 16 * 4;\nconst DEBUG_FIELDS = ['host', 'port', 'size', 'keepAlive', 'keepAliveInitialDelay', 'noDelay', 'connectionTimeout', 'socketTimeout', 'ssl', 'ca', 'crl', 'cert', 'rejectUnauthorized', 'promoteLongs', 'promoteValues', 'promoteBuffers', 'checkServerIdentity'];\nlet connectionAccountingSpy = undefined;\nlet connectionAccounting = false;\nlet connections = {};\n/**\n * A class representing a single connection to a MongoDB server\n *\n * @fires Connection#connect\n * @fires Connection#close\n * @fires Connection#error\n * @fires Connection#timeout\n * @fires Connection#parseError\n * @fires Connection#message\n */\n\nclass Connection extends EventEmitter {\n  /**\n   * Creates a new Connection instance\n   *\n   * **NOTE**: Internal class, do not instantiate directly\n   *\n   * @param {Socket} socket The socket this connection wraps\n   * @param {Object} options Various settings\n   * @param {object} options.bson An implementation of bson serialize and deserialize\n   * @param {string} [options.host='localhost'] The host the socket is connected to\n   * @param {number} [options.port=27017] The port used for the socket connection\n   * @param {boolean} [options.keepAlive=true] TCP Connection keep alive enabled\n   * @param {number} [options.keepAliveInitialDelay=120000] Initial delay before TCP keep alive enabled\n   * @param {number} [options.connectionTimeout=30000] TCP Connection timeout setting\n   * @param {number} [options.socketTimeout=0] TCP Socket timeout setting\n   * @param {boolean} [options.promoteLongs] Convert Long values from the db into Numbers if they fit into 53 bits\n   * @param {boolean} [options.promoteValues] Promotes BSON values to native types where possible, set to false to only receive wrapper types.\n   * @param {boolean} [options.promoteBuffers] Promotes Binary BSON values to native Node Buffers.\n   * @param {number} [options.maxBsonMessageSize=0x4000000] Largest possible size of a BSON message (for legacy purposes)\n   */\n  constructor(socket, options) {\n    super();\n    options = options || {};\n\n    if (!options.bson) {\n      throw new TypeError('must pass in valid bson parser');\n    }\n\n    this.id = _id++;\n    this.options = options;\n    this.logger = Logger('Connection', options);\n    this.bson = options.bson;\n    this.tag = options.tag;\n    this.maxBsonMessageSize = options.maxBsonMessageSize || DEFAULT_MAX_BSON_MESSAGE_SIZE;\n    this.port = options.port || 27017;\n    this.host = options.host || 'localhost';\n    this.socketTimeout = typeof options.socketTimeout === 'number' ? options.socketTimeout : 0; // These values are inspected directly in tests, but maybe not necessary to keep around\n\n    this.keepAlive = typeof options.keepAlive === 'boolean' ? options.keepAlive : true;\n    this.keepAliveInitialDelay = typeof options.keepAliveInitialDelay === 'number' ? options.keepAliveInitialDelay : 120000;\n    this.connectionTimeout = typeof options.connectionTimeout === 'number' ? options.connectionTimeout : 30000;\n\n    if (this.keepAliveInitialDelay > this.socketTimeout) {\n      this.keepAliveInitialDelay = Math.round(this.socketTimeout / 2);\n    } // Debug information\n\n\n    if (this.logger.isDebug()) {\n      this.logger.debug(`creating connection ${this.id} with options [${JSON.stringify(debugOptions(DEBUG_FIELDS, options))}]`);\n    } // Response options\n\n\n    this.responseOptions = {\n      promoteLongs: typeof options.promoteLongs === 'boolean' ? options.promoteLongs : true,\n      promoteValues: typeof options.promoteValues === 'boolean' ? options.promoteValues : true,\n      promoteBuffers: typeof options.promoteBuffers === 'boolean' ? options.promoteBuffers : false\n    }; // Flushing\n\n    this.flushing = false;\n    this.queue = []; // Internal state\n\n    this.writeStream = null;\n    this.destroyed = false;\n    this.timedOut = false; // Create hash method\n\n    const hash = crypto.createHash('sha1');\n    hash.update(this.address);\n    this.hashedName = hash.digest('hex'); // All operations in flight on the connection\n\n    this.workItems = []; // setup socket\n\n    this.socket = socket;\n    this.socket.once('error', errorHandler(this));\n    this.socket.once('timeout', timeoutHandler(this));\n    this.socket.once('close', closeHandler(this));\n    this.socket.on('data', dataHandler(this));\n\n    if (connectionAccounting) {\n      addConnection(this.id, this);\n    }\n  }\n\n  setSocketTimeout(value) {\n    if (this.socket) {\n      this.socket.setTimeout(value);\n    }\n  }\n\n  resetSocketTimeout() {\n    if (this.socket) {\n      this.socket.setTimeout(this.socketTimeout);\n    }\n  }\n\n  static enableConnectionAccounting(spy) {\n    if (spy) {\n      connectionAccountingSpy = spy;\n    }\n\n    connectionAccounting = true;\n    connections = {};\n  }\n\n  static disableConnectionAccounting() {\n    connectionAccounting = false;\n    connectionAccountingSpy = undefined;\n  }\n\n  static connections() {\n    return connections;\n  }\n\n  get address() {\n    return `${this.host}:${this.port}`;\n  }\n  /**\n   * Unref this connection\n   * @method\n   * @return {boolean}\n   */\n\n\n  unref() {\n    if (this.socket == null) {\n      this.once('connect', () => this.socket.unref());\n      return;\n    }\n\n    this.socket.unref();\n  }\n  /**\n   * Flush all work Items on this connection\n   *\n   * @param {*} err The error to propagate to the flushed work items\n   */\n\n\n  flush(err) {\n    while (this.workItems.length > 0) {\n      const workItem = this.workItems.shift();\n\n      if (workItem.cb) {\n        workItem.cb(err);\n      }\n    }\n  }\n  /**\n   * Destroy connection\n   * @method\n   */\n\n\n  destroy(options, callback) {\n    if (typeof options === 'function') {\n      callback = options;\n      options = {};\n    }\n\n    options = Object.assign({\n      force: false\n    }, options);\n\n    if (connectionAccounting) {\n      deleteConnection(this.id);\n    }\n\n    if (this.socket == null) {\n      this.destroyed = true;\n      return;\n    }\n\n    if (options.force || this.timedOut) {\n      this.socket.destroy();\n      this.destroyed = true;\n      if (typeof callback === 'function') callback(null, null);\n      return;\n    }\n\n    this.socket.end(err => {\n      this.destroyed = true;\n      if (typeof callback === 'function') callback(err, null);\n    });\n  }\n  /**\n   * Write to connection\n   * @method\n   * @param {Command} command Command to write out need to implement toBin and toBinUnified\n   */\n\n\n  write(buffer) {\n    // Debug Log\n    if (this.logger.isDebug()) {\n      if (!Array.isArray(buffer)) {\n        this.logger.debug(`writing buffer [${buffer.toString('hex')}] to ${this.address}`);\n      } else {\n        for (let i = 0; i < buffer.length; i++) this.logger.debug(`writing buffer [${buffer[i].toString('hex')}] to ${this.address}`);\n      }\n    } // Double check that the connection is not destroyed\n\n\n    if (this.socket.destroyed === false) {\n      // Write out the command\n      if (!Array.isArray(buffer)) {\n        this.socket.write(buffer, 'binary');\n        return true;\n      } // Iterate over all buffers and write them in order to the socket\n\n\n      for (let i = 0; i < buffer.length; i++) {\n        this.socket.write(buffer[i], 'binary');\n      }\n\n      return true;\n    } // Connection is destroyed return write failed\n\n\n    return false;\n  }\n  /**\n   * Return id of connection as a string\n   * @method\n   * @return {string}\n   */\n\n\n  toString() {\n    return '' + this.id;\n  }\n  /**\n   * Return json object of connection\n   * @method\n   * @return {object}\n   */\n\n\n  toJSON() {\n    return {\n      id: this.id,\n      host: this.host,\n      port: this.port\n    };\n  }\n  /**\n   * Is the connection connected\n   * @method\n   * @return {boolean}\n   */\n\n\n  isConnected() {\n    if (this.destroyed) return false;\n    return !this.socket.destroyed && this.socket.writable;\n  }\n  /**\n   * @ignore\n   */\n\n\n  command(ns, command, options, callback) {\n    if (typeof options === 'function') callback = options, options = {};\n    const conn = this;\n    const socketTimeout = typeof options.socketTimeout === 'number' ? options.socketTimeout : 0;\n    const bson = conn.options.bson;\n    const query = new Query(bson, ns, command, {\n      numberToSkip: 0,\n      numberToReturn: 1\n    });\n\n    const noop = () => {};\n\n    function _callback(err, result) {\n      callback(err, result);\n      callback = noop;\n    }\n\n    function errorHandler(err) {\n      conn.resetSocketTimeout();\n      CONNECTION_ERROR_EVENTS.forEach(eventName => conn.removeListener(eventName, errorHandler));\n      conn.removeListener('message', messageHandler);\n\n      if (err == null) {\n        err = new MongoError(`runCommand failed for connection to '${conn.address}'`);\n      } // ignore all future errors\n\n\n      conn.on('error', noop);\n\n      _callback(err);\n    }\n\n    function messageHandler(msg) {\n      if (msg.responseTo !== query.requestId) {\n        return;\n      }\n\n      conn.resetSocketTimeout();\n      CONNECTION_ERROR_EVENTS.forEach(eventName => conn.removeListener(eventName, errorHandler));\n      conn.removeListener('message', messageHandler);\n      msg.parse({\n        promoteValues: true\n      });\n      const response = msg.documents[0];\n\n      if (response.ok === 0 || response.$err || response.errmsg || response.code) {\n        _callback(new MongoError(response));\n\n        return;\n      }\n\n      _callback(undefined, new CommandResult(response, this, msg));\n    }\n\n    conn.setSocketTimeout(socketTimeout);\n    CONNECTION_ERROR_EVENTS.forEach(eventName => conn.once(eventName, errorHandler));\n    conn.on('message', messageHandler);\n    conn.write(query.toBin());\n  }\n\n}\n\nconst CONNECTION_ERROR_EVENTS = ['error', 'close', 'timeout', 'parseError'];\n\nfunction deleteConnection(id) {\n  // console.log(\"=== deleted connection \" + id + \" :: \" + (connections[id] ? connections[id].port : ''))\n  delete connections[id];\n\n  if (connectionAccountingSpy) {\n    connectionAccountingSpy.deleteConnection(id);\n  }\n}\n\nfunction addConnection(id, connection) {\n  // console.log(\"=== added connection \" + id + \" :: \" + connection.port)\n  connections[id] = connection;\n\n  if (connectionAccountingSpy) {\n    connectionAccountingSpy.addConnection(id, connection);\n  }\n} //\n// Connection handlers\n\n\nfunction errorHandler(conn) {\n  return function (err) {\n    if (connectionAccounting) deleteConnection(conn.id); // Debug information\n\n    if (conn.logger.isDebug()) {\n      conn.logger.debug(`connection ${conn.id} for [${conn.address}] errored out with [${JSON.stringify(err)}]`);\n    }\n\n    conn.emit('error', new MongoNetworkError(err), conn);\n  };\n}\n\nfunction timeoutHandler(conn) {\n  return function () {\n    if (connectionAccounting) deleteConnection(conn.id);\n\n    if (conn.logger.isDebug()) {\n      conn.logger.debug(`connection ${conn.id} for [${conn.address}] timed out`);\n    }\n\n    conn.timedOut = true;\n    conn.emit('timeout', new MongoNetworkTimeoutError(`connection ${conn.id} to ${conn.address} timed out`, {\n      beforeHandshake: conn.ismaster == null\n    }), conn);\n  };\n}\n\nfunction closeHandler(conn) {\n  return function (hadError) {\n    if (connectionAccounting) deleteConnection(conn.id);\n\n    if (conn.logger.isDebug()) {\n      conn.logger.debug(`connection ${conn.id} with for [${conn.address}] closed`);\n    }\n\n    if (!hadError) {\n      conn.emit('close', new MongoNetworkError(`connection ${conn.id} to ${conn.address} closed`), conn);\n    }\n  };\n} // Handle a message once it is received\n\n\nfunction processMessage(conn, message) {\n  const msgHeader = parseHeader(message);\n\n  if (msgHeader.opCode !== OP_COMPRESSED) {\n    const ResponseConstructor = msgHeader.opCode === OP_MSG ? BinMsg : Response;\n    conn.emit('message', new ResponseConstructor(conn.bson, message, msgHeader, message.slice(MESSAGE_HEADER_SIZE), conn.responseOptions), conn);\n    return;\n  }\n\n  msgHeader.fromCompressed = true;\n  let index = MESSAGE_HEADER_SIZE;\n  msgHeader.opCode = message.readInt32LE(index);\n  index += 4;\n  msgHeader.length = message.readInt32LE(index);\n  index += 4;\n  const compressorID = message[index];\n  index++;\n  decompress(compressorID, message.slice(index), (err, decompressedMsgBody) => {\n    if (err) {\n      conn.emit('error', err);\n      return;\n    }\n\n    if (decompressedMsgBody.length !== msgHeader.length) {\n      conn.emit('error', new MongoError('Decompressing a compressed message from the server failed. The message is corrupt.'));\n      return;\n    }\n\n    const ResponseConstructor = msgHeader.opCode === OP_MSG ? BinMsg : Response;\n    conn.emit('message', new ResponseConstructor(conn.bson, message, msgHeader, decompressedMsgBody, conn.responseOptions), conn);\n  });\n}\n\nfunction dataHandler(conn) {\n  return function (data) {\n    // Parse until we are done with the data\n    while (data.length > 0) {\n      // If we still have bytes to read on the current message\n      if (conn.bytesRead > 0 && conn.sizeOfMessage > 0) {\n        // Calculate the amount of remaining bytes\n        const remainingBytesToRead = conn.sizeOfMessage - conn.bytesRead; // Check if the current chunk contains the rest of the message\n\n        if (remainingBytesToRead > data.length) {\n          // Copy the new data into the exiting buffer (should have been allocated when we know the message size)\n          data.copy(conn.buffer, conn.bytesRead); // Adjust the number of bytes read so it point to the correct index in the buffer\n\n          conn.bytesRead = conn.bytesRead + data.length; // Reset state of buffer\n\n          data = Buffer.alloc(0);\n        } else {\n          // Copy the missing part of the data into our current buffer\n          data.copy(conn.buffer, conn.bytesRead, 0, remainingBytesToRead); // Slice the overflow into a new buffer that we will then re-parse\n\n          data = data.slice(remainingBytesToRead); // Emit current complete message\n\n          const emitBuffer = conn.buffer; // Reset state of buffer\n\n          conn.buffer = null;\n          conn.sizeOfMessage = 0;\n          conn.bytesRead = 0;\n          conn.stubBuffer = null;\n          processMessage(conn, emitBuffer);\n        }\n      } else {\n        // Stub buffer is kept in case we don't get enough bytes to determine the\n        // size of the message (< 4 bytes)\n        if (conn.stubBuffer != null && conn.stubBuffer.length > 0) {\n          // If we have enough bytes to determine the message size let's do it\n          if (conn.stubBuffer.length + data.length > 4) {\n            // Prepad the data\n            const newData = Buffer.alloc(conn.stubBuffer.length + data.length);\n            conn.stubBuffer.copy(newData, 0);\n            data.copy(newData, conn.stubBuffer.length); // Reassign for parsing\n\n            data = newData; // Reset state of buffer\n\n            conn.buffer = null;\n            conn.sizeOfMessage = 0;\n            conn.bytesRead = 0;\n            conn.stubBuffer = null;\n          } else {\n            // Add the the bytes to the stub buffer\n            const newStubBuffer = Buffer.alloc(conn.stubBuffer.length + data.length); // Copy existing stub buffer\n\n            conn.stubBuffer.copy(newStubBuffer, 0); // Copy missing part of the data\n\n            data.copy(newStubBuffer, conn.stubBuffer.length); // Exit parsing loop\n\n            data = Buffer.alloc(0);\n          }\n        } else {\n          if (data.length > 4) {\n            // Retrieve the message size\n            const sizeOfMessage = data[0] | data[1] << 8 | data[2] << 16 | data[3] << 24; // If we have a negative sizeOfMessage emit error and return\n\n            if (sizeOfMessage < 0 || sizeOfMessage > conn.maxBsonMessageSize) {\n              const errorObject = {\n                err: 'socketHandler',\n                trace: '',\n                bin: conn.buffer,\n                parseState: {\n                  sizeOfMessage: sizeOfMessage,\n                  bytesRead: conn.bytesRead,\n                  stubBuffer: conn.stubBuffer\n                }\n              }; // We got a parse Error fire it off then keep going\n\n              conn.emit('parseError', errorObject, conn);\n              return;\n            } // Ensure that the size of message is larger than 0 and less than the max allowed\n\n\n            if (sizeOfMessage > 4 && sizeOfMessage < conn.maxBsonMessageSize && sizeOfMessage > data.length) {\n              conn.buffer = Buffer.alloc(sizeOfMessage); // Copy all the data into the buffer\n\n              data.copy(conn.buffer, 0); // Update bytes read\n\n              conn.bytesRead = data.length; // Update sizeOfMessage\n\n              conn.sizeOfMessage = sizeOfMessage; // Ensure stub buffer is null\n\n              conn.stubBuffer = null; // Exit parsing loop\n\n              data = Buffer.alloc(0);\n            } else if (sizeOfMessage > 4 && sizeOfMessage < conn.maxBsonMessageSize && sizeOfMessage === data.length) {\n              const emitBuffer = data; // Reset state of buffer\n\n              conn.buffer = null;\n              conn.sizeOfMessage = 0;\n              conn.bytesRead = 0;\n              conn.stubBuffer = null; // Exit parsing loop\n\n              data = Buffer.alloc(0); // Emit the message\n\n              processMessage(conn, emitBuffer);\n            } else if (sizeOfMessage <= 4 || sizeOfMessage > conn.maxBsonMessageSize) {\n              const errorObject = {\n                err: 'socketHandler',\n                trace: null,\n                bin: data,\n                parseState: {\n                  sizeOfMessage: sizeOfMessage,\n                  bytesRead: 0,\n                  buffer: null,\n                  stubBuffer: null\n                }\n              }; // We got a parse Error fire it off then keep going\n\n              conn.emit('parseError', errorObject, conn); // Clear out the state of the parser\n\n              conn.buffer = null;\n              conn.sizeOfMessage = 0;\n              conn.bytesRead = 0;\n              conn.stubBuffer = null; // Exit parsing loop\n\n              data = Buffer.alloc(0);\n            } else {\n              const emitBuffer = data.slice(0, sizeOfMessage); // Reset state of buffer\n\n              conn.buffer = null;\n              conn.sizeOfMessage = 0;\n              conn.bytesRead = 0;\n              conn.stubBuffer = null; // Copy rest of message\n\n              data = data.slice(sizeOfMessage); // Emit the message\n\n              processMessage(conn, emitBuffer);\n            }\n          } else {\n            // Create a buffer that contains the space for the non-complete message\n            conn.stubBuffer = Buffer.alloc(data.length); // Copy the data to the stub buffer\n\n            data.copy(conn.stubBuffer, 0); // Exit parsing loop\n\n            data = Buffer.alloc(0);\n          }\n        }\n      }\n    }\n  };\n}\n/**\n * A server connect event, used to verify that the connection is up and running\n *\n * @event Connection#connect\n * @type {Connection}\n */\n\n/**\n * The server connection closed, all pool connections closed\n *\n * @event Connection#close\n * @type {Connection}\n */\n\n/**\n * The server connection caused an error, all pool connections closed\n *\n * @event Connection#error\n * @type {Connection}\n */\n\n/**\n * The server connection timed out, all pool connections closed\n *\n * @event Connection#timeout\n * @type {Connection}\n */\n\n/**\n * The driver experienced an invalid message, all pool connections closed\n *\n * @event Connection#parseError\n * @type {Connection}\n */\n\n/**\n * An event emitted each time the connection receives a parsed message from the wire\n *\n * @event Connection#message\n * @type {Connection}\n */\n\n\nmodule.exports = Connection;","map":{"version":3,"names":["EventEmitter","require","crypto","debugOptions","parseHeader","decompress","Response","BinMsg","MongoNetworkError","MongoNetworkTimeoutError","MongoError","Logger","OP_COMPRESSED","opcodes","OP_MSG","MESSAGE_HEADER_SIZE","Buffer","Query","CommandResult","_id","DEFAULT_MAX_BSON_MESSAGE_SIZE","DEBUG_FIELDS","connectionAccountingSpy","undefined","connectionAccounting","connections","Connection","constructor","socket","options","bson","TypeError","id","logger","tag","maxBsonMessageSize","port","host","socketTimeout","keepAlive","keepAliveInitialDelay","connectionTimeout","Math","round","isDebug","debug","JSON","stringify","responseOptions","promoteLongs","promoteValues","promoteBuffers","flushing","queue","writeStream","destroyed","timedOut","hash","createHash","update","address","hashedName","digest","workItems","once","errorHandler","timeoutHandler","closeHandler","on","dataHandler","addConnection","setSocketTimeout","value","setTimeout","resetSocketTimeout","enableConnectionAccounting","spy","disableConnectionAccounting","unref","flush","err","length","workItem","shift","cb","destroy","callback","Object","assign","force","deleteConnection","end","write","buffer","Array","isArray","toString","i","toJSON","isConnected","writable","command","ns","conn","query","numberToSkip","numberToReturn","noop","_callback","result","CONNECTION_ERROR_EVENTS","forEach","eventName","removeListener","messageHandler","msg","responseTo","requestId","parse","response","documents","ok","$err","errmsg","code","toBin","connection","emit","beforeHandshake","ismaster","hadError","processMessage","message","msgHeader","opCode","ResponseConstructor","slice","fromCompressed","index","readInt32LE","compressorID","decompressedMsgBody","data","bytesRead","sizeOfMessage","remainingBytesToRead","copy","alloc","emitBuffer","stubBuffer","newData","newStubBuffer","errorObject","trace","bin","parseState","module","exports"],"sources":["C:/Users/Administrator/Desktop/webAPI work/web/dog-website/node_modules/koa-mongo/node_modules/mongodb/lib/core/connection/connection.js"],"sourcesContent":["'use strict';\n\nconst EventEmitter = require('events').EventEmitter;\nconst crypto = require('crypto');\nconst debugOptions = require('./utils').debugOptions;\nconst parseHeader = require('../wireprotocol/shared').parseHeader;\nconst decompress = require('../wireprotocol/compression').decompress;\nconst Response = require('./commands').Response;\nconst BinMsg = require('./msg').BinMsg;\nconst MongoNetworkError = require('../error').MongoNetworkError;\nconst MongoNetworkTimeoutError = require('../error').MongoNetworkTimeoutError;\nconst MongoError = require('../error').MongoError;\nconst Logger = require('./logger');\nconst OP_COMPRESSED = require('../wireprotocol/shared').opcodes.OP_COMPRESSED;\nconst OP_MSG = require('../wireprotocol/shared').opcodes.OP_MSG;\nconst MESSAGE_HEADER_SIZE = require('../wireprotocol/shared').MESSAGE_HEADER_SIZE;\nconst Buffer = require('safe-buffer').Buffer;\nconst Query = require('./commands').Query;\nconst CommandResult = require('./command_result');\n\nlet _id = 0;\n\nconst DEFAULT_MAX_BSON_MESSAGE_SIZE = 1024 * 1024 * 16 * 4;\nconst DEBUG_FIELDS = [\n  'host',\n  'port',\n  'size',\n  'keepAlive',\n  'keepAliveInitialDelay',\n  'noDelay',\n  'connectionTimeout',\n  'socketTimeout',\n  'ssl',\n  'ca',\n  'crl',\n  'cert',\n  'rejectUnauthorized',\n  'promoteLongs',\n  'promoteValues',\n  'promoteBuffers',\n  'checkServerIdentity'\n];\n\nlet connectionAccountingSpy = undefined;\nlet connectionAccounting = false;\nlet connections = {};\n\n/**\n * A class representing a single connection to a MongoDB server\n *\n * @fires Connection#connect\n * @fires Connection#close\n * @fires Connection#error\n * @fires Connection#timeout\n * @fires Connection#parseError\n * @fires Connection#message\n */\nclass Connection extends EventEmitter {\n  /**\n   * Creates a new Connection instance\n   *\n   * **NOTE**: Internal class, do not instantiate directly\n   *\n   * @param {Socket} socket The socket this connection wraps\n   * @param {Object} options Various settings\n   * @param {object} options.bson An implementation of bson serialize and deserialize\n   * @param {string} [options.host='localhost'] The host the socket is connected to\n   * @param {number} [options.port=27017] The port used for the socket connection\n   * @param {boolean} [options.keepAlive=true] TCP Connection keep alive enabled\n   * @param {number} [options.keepAliveInitialDelay=120000] Initial delay before TCP keep alive enabled\n   * @param {number} [options.connectionTimeout=30000] TCP Connection timeout setting\n   * @param {number} [options.socketTimeout=0] TCP Socket timeout setting\n   * @param {boolean} [options.promoteLongs] Convert Long values from the db into Numbers if they fit into 53 bits\n   * @param {boolean} [options.promoteValues] Promotes BSON values to native types where possible, set to false to only receive wrapper types.\n   * @param {boolean} [options.promoteBuffers] Promotes Binary BSON values to native Node Buffers.\n   * @param {number} [options.maxBsonMessageSize=0x4000000] Largest possible size of a BSON message (for legacy purposes)\n   */\n  constructor(socket, options) {\n    super();\n\n    options = options || {};\n    if (!options.bson) {\n      throw new TypeError('must pass in valid bson parser');\n    }\n\n    this.id = _id++;\n    this.options = options;\n    this.logger = Logger('Connection', options);\n    this.bson = options.bson;\n    this.tag = options.tag;\n    this.maxBsonMessageSize = options.maxBsonMessageSize || DEFAULT_MAX_BSON_MESSAGE_SIZE;\n\n    this.port = options.port || 27017;\n    this.host = options.host || 'localhost';\n    this.socketTimeout = typeof options.socketTimeout === 'number' ? options.socketTimeout : 0;\n\n    // These values are inspected directly in tests, but maybe not necessary to keep around\n    this.keepAlive = typeof options.keepAlive === 'boolean' ? options.keepAlive : true;\n    this.keepAliveInitialDelay =\n      typeof options.keepAliveInitialDelay === 'number' ? options.keepAliveInitialDelay : 120000;\n    this.connectionTimeout =\n      typeof options.connectionTimeout === 'number' ? options.connectionTimeout : 30000;\n    if (this.keepAliveInitialDelay > this.socketTimeout) {\n      this.keepAliveInitialDelay = Math.round(this.socketTimeout / 2);\n    }\n\n    // Debug information\n    if (this.logger.isDebug()) {\n      this.logger.debug(\n        `creating connection ${this.id} with options [${JSON.stringify(\n          debugOptions(DEBUG_FIELDS, options)\n        )}]`\n      );\n    }\n\n    // Response options\n    this.responseOptions = {\n      promoteLongs: typeof options.promoteLongs === 'boolean' ? options.promoteLongs : true,\n      promoteValues: typeof options.promoteValues === 'boolean' ? options.promoteValues : true,\n      promoteBuffers: typeof options.promoteBuffers === 'boolean' ? options.promoteBuffers : false\n    };\n\n    // Flushing\n    this.flushing = false;\n    this.queue = [];\n\n    // Internal state\n    this.writeStream = null;\n    this.destroyed = false;\n    this.timedOut = false;\n\n    // Create hash method\n    const hash = crypto.createHash('sha1');\n    hash.update(this.address);\n    this.hashedName = hash.digest('hex');\n\n    // All operations in flight on the connection\n    this.workItems = [];\n\n    // setup socket\n    this.socket = socket;\n    this.socket.once('error', errorHandler(this));\n    this.socket.once('timeout', timeoutHandler(this));\n    this.socket.once('close', closeHandler(this));\n    this.socket.on('data', dataHandler(this));\n\n    if (connectionAccounting) {\n      addConnection(this.id, this);\n    }\n  }\n\n  setSocketTimeout(value) {\n    if (this.socket) {\n      this.socket.setTimeout(value);\n    }\n  }\n\n  resetSocketTimeout() {\n    if (this.socket) {\n      this.socket.setTimeout(this.socketTimeout);\n    }\n  }\n\n  static enableConnectionAccounting(spy) {\n    if (spy) {\n      connectionAccountingSpy = spy;\n    }\n\n    connectionAccounting = true;\n    connections = {};\n  }\n\n  static disableConnectionAccounting() {\n    connectionAccounting = false;\n    connectionAccountingSpy = undefined;\n  }\n\n  static connections() {\n    return connections;\n  }\n\n  get address() {\n    return `${this.host}:${this.port}`;\n  }\n\n  /**\n   * Unref this connection\n   * @method\n   * @return {boolean}\n   */\n  unref() {\n    if (this.socket == null) {\n      this.once('connect', () => this.socket.unref());\n      return;\n    }\n\n    this.socket.unref();\n  }\n\n  /**\n   * Flush all work Items on this connection\n   *\n   * @param {*} err The error to propagate to the flushed work items\n   */\n  flush(err) {\n    while (this.workItems.length > 0) {\n      const workItem = this.workItems.shift();\n      if (workItem.cb) {\n        workItem.cb(err);\n      }\n    }\n  }\n\n  /**\n   * Destroy connection\n   * @method\n   */\n  destroy(options, callback) {\n    if (typeof options === 'function') {\n      callback = options;\n      options = {};\n    }\n\n    options = Object.assign({ force: false }, options);\n\n    if (connectionAccounting) {\n      deleteConnection(this.id);\n    }\n\n    if (this.socket == null) {\n      this.destroyed = true;\n      return;\n    }\n\n    if (options.force || this.timedOut) {\n      this.socket.destroy();\n      this.destroyed = true;\n      if (typeof callback === 'function') callback(null, null);\n      return;\n    }\n\n    this.socket.end(err => {\n      this.destroyed = true;\n      if (typeof callback === 'function') callback(err, null);\n    });\n  }\n\n  /**\n   * Write to connection\n   * @method\n   * @param {Command} command Command to write out need to implement toBin and toBinUnified\n   */\n  write(buffer) {\n    // Debug Log\n    if (this.logger.isDebug()) {\n      if (!Array.isArray(buffer)) {\n        this.logger.debug(`writing buffer [${buffer.toString('hex')}] to ${this.address}`);\n      } else {\n        for (let i = 0; i < buffer.length; i++)\n          this.logger.debug(`writing buffer [${buffer[i].toString('hex')}] to ${this.address}`);\n      }\n    }\n\n    // Double check that the connection is not destroyed\n    if (this.socket.destroyed === false) {\n      // Write out the command\n      if (!Array.isArray(buffer)) {\n        this.socket.write(buffer, 'binary');\n        return true;\n      }\n\n      // Iterate over all buffers and write them in order to the socket\n      for (let i = 0; i < buffer.length; i++) {\n        this.socket.write(buffer[i], 'binary');\n      }\n\n      return true;\n    }\n\n    // Connection is destroyed return write failed\n    return false;\n  }\n\n  /**\n   * Return id of connection as a string\n   * @method\n   * @return {string}\n   */\n  toString() {\n    return '' + this.id;\n  }\n\n  /**\n   * Return json object of connection\n   * @method\n   * @return {object}\n   */\n  toJSON() {\n    return { id: this.id, host: this.host, port: this.port };\n  }\n\n  /**\n   * Is the connection connected\n   * @method\n   * @return {boolean}\n   */\n  isConnected() {\n    if (this.destroyed) return false;\n    return !this.socket.destroyed && this.socket.writable;\n  }\n\n  /**\n   * @ignore\n   */\n  command(ns, command, options, callback) {\n    if (typeof options === 'function') (callback = options), (options = {});\n\n    const conn = this;\n    const socketTimeout = typeof options.socketTimeout === 'number' ? options.socketTimeout : 0;\n    const bson = conn.options.bson;\n    const query = new Query(bson, ns, command, {\n      numberToSkip: 0,\n      numberToReturn: 1\n    });\n\n    const noop = () => {};\n    function _callback(err, result) {\n      callback(err, result);\n      callback = noop;\n    }\n\n    function errorHandler(err) {\n      conn.resetSocketTimeout();\n      CONNECTION_ERROR_EVENTS.forEach(eventName => conn.removeListener(eventName, errorHandler));\n      conn.removeListener('message', messageHandler);\n\n      if (err == null) {\n        err = new MongoError(`runCommand failed for connection to '${conn.address}'`);\n      }\n\n      // ignore all future errors\n      conn.on('error', noop);\n      _callback(err);\n    }\n\n    function messageHandler(msg) {\n      if (msg.responseTo !== query.requestId) {\n        return;\n      }\n\n      conn.resetSocketTimeout();\n      CONNECTION_ERROR_EVENTS.forEach(eventName => conn.removeListener(eventName, errorHandler));\n      conn.removeListener('message', messageHandler);\n\n      msg.parse({ promoteValues: true });\n\n      const response = msg.documents[0];\n      if (response.ok === 0 || response.$err || response.errmsg || response.code) {\n        _callback(new MongoError(response));\n        return;\n      }\n\n      _callback(undefined, new CommandResult(response, this, msg));\n    }\n\n    conn.setSocketTimeout(socketTimeout);\n    CONNECTION_ERROR_EVENTS.forEach(eventName => conn.once(eventName, errorHandler));\n    conn.on('message', messageHandler);\n    conn.write(query.toBin());\n  }\n}\n\nconst CONNECTION_ERROR_EVENTS = ['error', 'close', 'timeout', 'parseError'];\n\nfunction deleteConnection(id) {\n  // console.log(\"=== deleted connection \" + id + \" :: \" + (connections[id] ? connections[id].port : ''))\n  delete connections[id];\n\n  if (connectionAccountingSpy) {\n    connectionAccountingSpy.deleteConnection(id);\n  }\n}\n\nfunction addConnection(id, connection) {\n  // console.log(\"=== added connection \" + id + \" :: \" + connection.port)\n  connections[id] = connection;\n\n  if (connectionAccountingSpy) {\n    connectionAccountingSpy.addConnection(id, connection);\n  }\n}\n\n//\n// Connection handlers\nfunction errorHandler(conn) {\n  return function(err) {\n    if (connectionAccounting) deleteConnection(conn.id);\n    // Debug information\n    if (conn.logger.isDebug()) {\n      conn.logger.debug(\n        `connection ${conn.id} for [${conn.address}] errored out with [${JSON.stringify(err)}]`\n      );\n    }\n\n    conn.emit('error', new MongoNetworkError(err), conn);\n  };\n}\n\nfunction timeoutHandler(conn) {\n  return function() {\n    if (connectionAccounting) deleteConnection(conn.id);\n\n    if (conn.logger.isDebug()) {\n      conn.logger.debug(`connection ${conn.id} for [${conn.address}] timed out`);\n    }\n\n    conn.timedOut = true;\n    conn.emit(\n      'timeout',\n      new MongoNetworkTimeoutError(`connection ${conn.id} to ${conn.address} timed out`, {\n        beforeHandshake: conn.ismaster == null\n      }),\n      conn\n    );\n  };\n}\n\nfunction closeHandler(conn) {\n  return function(hadError) {\n    if (connectionAccounting) deleteConnection(conn.id);\n\n    if (conn.logger.isDebug()) {\n      conn.logger.debug(`connection ${conn.id} with for [${conn.address}] closed`);\n    }\n\n    if (!hadError) {\n      conn.emit(\n        'close',\n        new MongoNetworkError(`connection ${conn.id} to ${conn.address} closed`),\n        conn\n      );\n    }\n  };\n}\n\n// Handle a message once it is received\nfunction processMessage(conn, message) {\n  const msgHeader = parseHeader(message);\n  if (msgHeader.opCode !== OP_COMPRESSED) {\n    const ResponseConstructor = msgHeader.opCode === OP_MSG ? BinMsg : Response;\n    conn.emit(\n      'message',\n      new ResponseConstructor(\n        conn.bson,\n        message,\n        msgHeader,\n        message.slice(MESSAGE_HEADER_SIZE),\n        conn.responseOptions\n      ),\n      conn\n    );\n\n    return;\n  }\n\n  msgHeader.fromCompressed = true;\n  let index = MESSAGE_HEADER_SIZE;\n  msgHeader.opCode = message.readInt32LE(index);\n  index += 4;\n  msgHeader.length = message.readInt32LE(index);\n  index += 4;\n  const compressorID = message[index];\n  index++;\n\n  decompress(compressorID, message.slice(index), (err, decompressedMsgBody) => {\n    if (err) {\n      conn.emit('error', err);\n      return;\n    }\n\n    if (decompressedMsgBody.length !== msgHeader.length) {\n      conn.emit(\n        'error',\n        new MongoError(\n          'Decompressing a compressed message from the server failed. The message is corrupt.'\n        )\n      );\n\n      return;\n    }\n\n    const ResponseConstructor = msgHeader.opCode === OP_MSG ? BinMsg : Response;\n    conn.emit(\n      'message',\n      new ResponseConstructor(\n        conn.bson,\n        message,\n        msgHeader,\n        decompressedMsgBody,\n        conn.responseOptions\n      ),\n      conn\n    );\n  });\n}\n\nfunction dataHandler(conn) {\n  return function(data) {\n    // Parse until we are done with the data\n    while (data.length > 0) {\n      // If we still have bytes to read on the current message\n      if (conn.bytesRead > 0 && conn.sizeOfMessage > 0) {\n        // Calculate the amount of remaining bytes\n        const remainingBytesToRead = conn.sizeOfMessage - conn.bytesRead;\n        // Check if the current chunk contains the rest of the message\n        if (remainingBytesToRead > data.length) {\n          // Copy the new data into the exiting buffer (should have been allocated when we know the message size)\n          data.copy(conn.buffer, conn.bytesRead);\n          // Adjust the number of bytes read so it point to the correct index in the buffer\n          conn.bytesRead = conn.bytesRead + data.length;\n\n          // Reset state of buffer\n          data = Buffer.alloc(0);\n        } else {\n          // Copy the missing part of the data into our current buffer\n          data.copy(conn.buffer, conn.bytesRead, 0, remainingBytesToRead);\n          // Slice the overflow into a new buffer that we will then re-parse\n          data = data.slice(remainingBytesToRead);\n\n          // Emit current complete message\n          const emitBuffer = conn.buffer;\n          // Reset state of buffer\n          conn.buffer = null;\n          conn.sizeOfMessage = 0;\n          conn.bytesRead = 0;\n          conn.stubBuffer = null;\n\n          processMessage(conn, emitBuffer);\n        }\n      } else {\n        // Stub buffer is kept in case we don't get enough bytes to determine the\n        // size of the message (< 4 bytes)\n        if (conn.stubBuffer != null && conn.stubBuffer.length > 0) {\n          // If we have enough bytes to determine the message size let's do it\n          if (conn.stubBuffer.length + data.length > 4) {\n            // Prepad the data\n            const newData = Buffer.alloc(conn.stubBuffer.length + data.length);\n            conn.stubBuffer.copy(newData, 0);\n            data.copy(newData, conn.stubBuffer.length);\n            // Reassign for parsing\n            data = newData;\n\n            // Reset state of buffer\n            conn.buffer = null;\n            conn.sizeOfMessage = 0;\n            conn.bytesRead = 0;\n            conn.stubBuffer = null;\n          } else {\n            // Add the the bytes to the stub buffer\n            const newStubBuffer = Buffer.alloc(conn.stubBuffer.length + data.length);\n            // Copy existing stub buffer\n            conn.stubBuffer.copy(newStubBuffer, 0);\n            // Copy missing part of the data\n            data.copy(newStubBuffer, conn.stubBuffer.length);\n            // Exit parsing loop\n            data = Buffer.alloc(0);\n          }\n        } else {\n          if (data.length > 4) {\n            // Retrieve the message size\n            const sizeOfMessage = data[0] | (data[1] << 8) | (data[2] << 16) | (data[3] << 24);\n            // If we have a negative sizeOfMessage emit error and return\n            if (sizeOfMessage < 0 || sizeOfMessage > conn.maxBsonMessageSize) {\n              const errorObject = {\n                err: 'socketHandler',\n                trace: '',\n                bin: conn.buffer,\n                parseState: {\n                  sizeOfMessage: sizeOfMessage,\n                  bytesRead: conn.bytesRead,\n                  stubBuffer: conn.stubBuffer\n                }\n              };\n              // We got a parse Error fire it off then keep going\n              conn.emit('parseError', errorObject, conn);\n              return;\n            }\n\n            // Ensure that the size of message is larger than 0 and less than the max allowed\n            if (\n              sizeOfMessage > 4 &&\n              sizeOfMessage < conn.maxBsonMessageSize &&\n              sizeOfMessage > data.length\n            ) {\n              conn.buffer = Buffer.alloc(sizeOfMessage);\n              // Copy all the data into the buffer\n              data.copy(conn.buffer, 0);\n              // Update bytes read\n              conn.bytesRead = data.length;\n              // Update sizeOfMessage\n              conn.sizeOfMessage = sizeOfMessage;\n              // Ensure stub buffer is null\n              conn.stubBuffer = null;\n              // Exit parsing loop\n              data = Buffer.alloc(0);\n            } else if (\n              sizeOfMessage > 4 &&\n              sizeOfMessage < conn.maxBsonMessageSize &&\n              sizeOfMessage === data.length\n            ) {\n              const emitBuffer = data;\n              // Reset state of buffer\n              conn.buffer = null;\n              conn.sizeOfMessage = 0;\n              conn.bytesRead = 0;\n              conn.stubBuffer = null;\n              // Exit parsing loop\n              data = Buffer.alloc(0);\n              // Emit the message\n              processMessage(conn, emitBuffer);\n            } else if (sizeOfMessage <= 4 || sizeOfMessage > conn.maxBsonMessageSize) {\n              const errorObject = {\n                err: 'socketHandler',\n                trace: null,\n                bin: data,\n                parseState: {\n                  sizeOfMessage: sizeOfMessage,\n                  bytesRead: 0,\n                  buffer: null,\n                  stubBuffer: null\n                }\n              };\n              // We got a parse Error fire it off then keep going\n              conn.emit('parseError', errorObject, conn);\n\n              // Clear out the state of the parser\n              conn.buffer = null;\n              conn.sizeOfMessage = 0;\n              conn.bytesRead = 0;\n              conn.stubBuffer = null;\n              // Exit parsing loop\n              data = Buffer.alloc(0);\n            } else {\n              const emitBuffer = data.slice(0, sizeOfMessage);\n              // Reset state of buffer\n              conn.buffer = null;\n              conn.sizeOfMessage = 0;\n              conn.bytesRead = 0;\n              conn.stubBuffer = null;\n              // Copy rest of message\n              data = data.slice(sizeOfMessage);\n              // Emit the message\n              processMessage(conn, emitBuffer);\n            }\n          } else {\n            // Create a buffer that contains the space for the non-complete message\n            conn.stubBuffer = Buffer.alloc(data.length);\n            // Copy the data to the stub buffer\n            data.copy(conn.stubBuffer, 0);\n            // Exit parsing loop\n            data = Buffer.alloc(0);\n          }\n        }\n      }\n    }\n  };\n}\n\n/**\n * A server connect event, used to verify that the connection is up and running\n *\n * @event Connection#connect\n * @type {Connection}\n */\n\n/**\n * The server connection closed, all pool connections closed\n *\n * @event Connection#close\n * @type {Connection}\n */\n\n/**\n * The server connection caused an error, all pool connections closed\n *\n * @event Connection#error\n * @type {Connection}\n */\n\n/**\n * The server connection timed out, all pool connections closed\n *\n * @event Connection#timeout\n * @type {Connection}\n */\n\n/**\n * The driver experienced an invalid message, all pool connections closed\n *\n * @event Connection#parseError\n * @type {Connection}\n */\n\n/**\n * An event emitted each time the connection receives a parsed message from the wire\n *\n * @event Connection#message\n * @type {Connection}\n */\n\nmodule.exports = Connection;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}