{"ast":null,"code":"'use strict';\n\nconst applyRetryableWrites = require('../utils').applyRetryableWrites;\n\nconst applyWriteConcern = require('../utils').applyWriteConcern;\n\nconst decorateWithCollation = require('../utils').decorateWithCollation;\n\nconst decorateWithReadConcern = require('../utils').decorateWithReadConcern;\n\nconst executeCommand = require('./db_ops').executeCommand;\n\nconst formattedOrderClause = require('../utils').formattedOrderClause;\n\nconst handleCallback = require('../utils').handleCallback;\n\nconst MongoError = require('../core').MongoError;\n\nconst ReadPreference = require('../core').ReadPreference;\n\nconst toError = require('../utils').toError;\n\nconst CursorState = require('../core/cursor').CursorState;\n/**\n * Build the count command.\n *\n * @method\n * @param {collectionOrCursor} an instance of a collection or cursor\n * @param {object} query The query for the count.\n * @param {object} [options] Optional settings. See Collection.prototype.count and Cursor.prototype.count for a list of options.\n */\n\n\nfunction buildCountCommand(collectionOrCursor, query, options) {\n  const skip = options.skip;\n  const limit = options.limit;\n  let hint = options.hint;\n  const maxTimeMS = options.maxTimeMS;\n  query = query || {}; // Final query\n\n  const cmd = {\n    count: options.collectionName,\n    query: query\n  };\n\n  if (collectionOrCursor.s.numberOfRetries) {\n    // collectionOrCursor is a cursor\n    if (collectionOrCursor.options.hint) {\n      hint = collectionOrCursor.options.hint;\n    } else if (collectionOrCursor.cmd.hint) {\n      hint = collectionOrCursor.cmd.hint;\n    }\n\n    decorateWithCollation(cmd, collectionOrCursor, collectionOrCursor.cmd);\n  } else {\n    decorateWithCollation(cmd, collectionOrCursor, options);\n  } // Add limit, skip and maxTimeMS if defined\n\n\n  if (typeof skip === 'number') cmd.skip = skip;\n  if (typeof limit === 'number') cmd.limit = limit;\n  if (typeof maxTimeMS === 'number') cmd.maxTimeMS = maxTimeMS;\n  if (hint) cmd.hint = hint; // Do we have a readConcern specified\n\n  decorateWithReadConcern(cmd, collectionOrCursor);\n  return cmd;\n}\n\nfunction deleteCallback(err, r, callback) {\n  if (callback == null) return;\n  if (err && callback) return callback(err);\n  if (r == null) return callback(null, {\n    result: {\n      ok: 1\n    }\n  });\n  r.deletedCount = r.result.n;\n  if (callback) callback(null, r);\n}\n/**\n * Find and update a document.\n *\n * @method\n * @param {Collection} a Collection instance.\n * @param {object} query Query object to locate the object to modify.\n * @param {array} sort If multiple docs match, choose the first one in the specified sort order as the object to manipulate.\n * @param {object} doc The fields/vals to be updated.\n * @param {object} [options] Optional settings. See Collection.prototype.findAndModify for a list of options.\n * @param {Collection~findAndModifyCallback} [callback] The command result callback\n * @deprecated use findOneAndUpdate, findOneAndReplace or findOneAndDelete instead\n */\n\n\nfunction findAndModify(coll, query, sort, doc, options, callback) {\n  // Create findAndModify command object\n  const queryObject = {\n    findAndModify: coll.collectionName,\n    query: query\n  };\n  sort = formattedOrderClause(sort);\n\n  if (sort) {\n    queryObject.sort = sort;\n  }\n\n  queryObject.new = options.new ? true : false;\n  queryObject.remove = options.remove ? true : false;\n  queryObject.upsert = options.upsert ? true : false;\n  const projection = options.projection || options.fields;\n\n  if (projection) {\n    queryObject.fields = projection;\n  }\n\n  if (options.arrayFilters) {\n    queryObject.arrayFilters = options.arrayFilters;\n    delete options.arrayFilters;\n  }\n\n  if (doc && !options.remove) {\n    queryObject.update = doc;\n  }\n\n  if (options.maxTimeMS) queryObject.maxTimeMS = options.maxTimeMS; // Either use override on the function, or go back to default on either the collection\n  // level or db\n\n  options.serializeFunctions = options.serializeFunctions || coll.s.serializeFunctions; // No check on the documents\n\n  options.checkKeys = false; // Final options for retryable writes and write concern\n\n  let finalOptions = Object.assign({}, options);\n  finalOptions = applyRetryableWrites(finalOptions, coll.s.db);\n  finalOptions = applyWriteConcern(finalOptions, {\n    db: coll.s.db,\n    collection: coll\n  }, options); // Decorate the findAndModify command with the write Concern\n\n  if (finalOptions.writeConcern) {\n    queryObject.writeConcern = finalOptions.writeConcern;\n  } // Have we specified bypassDocumentValidation\n\n\n  if (finalOptions.bypassDocumentValidation === true) {\n    queryObject.bypassDocumentValidation = finalOptions.bypassDocumentValidation;\n  }\n\n  finalOptions.readPreference = ReadPreference.primary; // Have we specified collation\n\n  try {\n    decorateWithCollation(queryObject, coll, finalOptions);\n  } catch (err) {\n    return callback(err, null);\n  } // Execute the command\n\n\n  executeCommand(coll.s.db, queryObject, finalOptions, (err, result) => {\n    if (err) return handleCallback(callback, err, null);\n    return handleCallback(callback, null, result);\n  });\n}\n/**\n * Retrieves this collections index info.\n *\n * @method\n * @param {Db} db The Db instance on which to retrieve the index info.\n * @param {string} name The name of the collection.\n * @param {object} [options] Optional settings. See Db.prototype.indexInformation for a list of options.\n * @param {Db~resultCallback} [callback] The command result callback\n */\n\n\nfunction indexInformation(db, name, options, callback) {\n  // If we specified full information\n  const full = options['full'] == null ? false : options['full']; // Did the user destroy the topology\n\n  if (db.serverConfig && db.serverConfig.isDestroyed()) return callback(new MongoError('topology was destroyed')); // Process all the results from the index command and collection\n\n  function processResults(indexes) {\n    // Contains all the information\n    let info = {}; // Process all the indexes\n\n    for (let i = 0; i < indexes.length; i++) {\n      const index = indexes[i]; // Let's unpack the object\n\n      info[index.name] = [];\n\n      for (let name in index.key) {\n        info[index.name].push([name, index.key[name]]);\n      }\n    }\n\n    return info;\n  } // Get the list of indexes of the specified collection\n\n\n  db.collection(name).listIndexes(options).toArray((err, indexes) => {\n    if (err) return callback(toError(err));\n    if (!Array.isArray(indexes)) return handleCallback(callback, null, []);\n    if (full) return handleCallback(callback, null, indexes);\n    handleCallback(callback, null, processResults(indexes));\n  });\n}\n\nfunction prepareDocs(coll, docs, options) {\n  const forceServerObjectId = typeof options.forceServerObjectId === 'boolean' ? options.forceServerObjectId : coll.s.db.options.forceServerObjectId; // no need to modify the docs if server sets the ObjectId\n\n  if (forceServerObjectId === true) {\n    return docs;\n  }\n\n  return docs.map(doc => {\n    if (forceServerObjectId !== true && doc._id == null) {\n      doc._id = coll.s.pkFactory.createPk();\n    }\n\n    return doc;\n  });\n} // Get the next available document from the cursor, returns null if no more documents are available.\n\n\nfunction nextObject(cursor, callback) {\n  if (cursor.s.state === CursorState.CLOSED || cursor.isDead && cursor.isDead()) {\n    return handleCallback(callback, MongoError.create({\n      message: 'Cursor is closed',\n      driver: true\n    }));\n  }\n\n  if (cursor.s.state === CursorState.INIT && cursor.cmd && cursor.cmd.sort) {\n    try {\n      cursor.cmd.sort = formattedOrderClause(cursor.cmd.sort);\n    } catch (err) {\n      return handleCallback(callback, err);\n    }\n  } // Get the next object\n\n\n  cursor._next((err, doc) => {\n    cursor.s.state = CursorState.OPEN;\n    if (err) return handleCallback(callback, err);\n    handleCallback(callback, null, doc);\n  });\n}\n\nfunction insertDocuments(coll, docs, options, callback) {\n  if (typeof options === 'function') callback = options, options = {};\n  options = options || {}; // Ensure we are operating on an array op docs\n\n  docs = Array.isArray(docs) ? docs : [docs]; // Final options for retryable writes and write concern\n\n  let finalOptions = Object.assign({}, options);\n  finalOptions = applyRetryableWrites(finalOptions, coll.s.db);\n  finalOptions = applyWriteConcern(finalOptions, {\n    db: coll.s.db,\n    collection: coll\n  }, options); // If keep going set unordered\n\n  if (finalOptions.keepGoing === true) finalOptions.ordered = false;\n  finalOptions.serializeFunctions = options.serializeFunctions || coll.s.serializeFunctions;\n  docs = prepareDocs(coll, docs, options); // File inserts\n\n  coll.s.topology.insert(coll.s.namespace, docs, finalOptions, (err, result) => {\n    if (callback == null) return;\n    if (err) return handleCallback(callback, err);\n    if (result == null) return handleCallback(callback, null, null);\n    if (result.result.code) return handleCallback(callback, toError(result.result));\n    if (result.result.writeErrors) return handleCallback(callback, toError(result.result.writeErrors[0])); // Add docs to the list\n\n    result.ops = docs; // Return the results\n\n    handleCallback(callback, null, result);\n  });\n}\n\nfunction removeDocuments(coll, selector, options, callback) {\n  if (typeof options === 'function') {\n    callback = options, options = {};\n  } else if (typeof selector === 'function') {\n    callback = selector;\n    options = {};\n    selector = {};\n  } // Create an empty options object if the provided one is null\n\n\n  options = options || {}; // Final options for retryable writes and write concern\n\n  let finalOptions = Object.assign({}, options);\n  finalOptions = applyRetryableWrites(finalOptions, coll.s.db);\n  finalOptions = applyWriteConcern(finalOptions, {\n    db: coll.s.db,\n    collection: coll\n  }, options); // If selector is null set empty\n\n  if (selector == null) selector = {}; // Build the op\n\n  const op = {\n    q: selector,\n    limit: 0\n  };\n\n  if (options.single) {\n    op.limit = 1;\n  } else if (finalOptions.retryWrites) {\n    finalOptions.retryWrites = false;\n  }\n\n  if (options.hint) {\n    op.hint = options.hint;\n  } // Have we specified collation\n\n\n  try {\n    decorateWithCollation(finalOptions, coll, options);\n  } catch (err) {\n    return callback(err, null);\n  } // Execute the remove\n\n\n  coll.s.topology.remove(coll.s.namespace, [op], finalOptions, (err, result) => {\n    if (callback == null) return;\n    if (err) return handleCallback(callback, err, null);\n    if (result == null) return handleCallback(callback, null, null);\n    if (result.result.code) return handleCallback(callback, toError(result.result));\n\n    if (result.result.writeErrors) {\n      return handleCallback(callback, toError(result.result.writeErrors[0]));\n    } // Return the results\n\n\n    handleCallback(callback, null, result);\n  });\n}\n\nfunction updateDocuments(coll, selector, document, options, callback) {\n  if ('function' === typeof options) callback = options, options = null;\n  if (options == null) options = {};\n  if (!('function' === typeof callback)) callback = null; // If we are not providing a selector or document throw\n\n  if (selector == null || typeof selector !== 'object') return callback(toError('selector must be a valid JavaScript object'));\n  if (document == null || typeof document !== 'object') return callback(toError('document must be a valid JavaScript object')); // Final options for retryable writes and write concern\n\n  let finalOptions = Object.assign({}, options);\n  finalOptions = applyRetryableWrites(finalOptions, coll.s.db);\n  finalOptions = applyWriteConcern(finalOptions, {\n    db: coll.s.db,\n    collection: coll\n  }, options); // Do we return the actual result document\n  // Either use override on the function, or go back to default on either the collection\n  // level or db\n\n  finalOptions.serializeFunctions = options.serializeFunctions || coll.s.serializeFunctions; // Execute the operation\n\n  const op = {\n    q: selector,\n    u: document\n  };\n  op.upsert = options.upsert !== void 0 ? !!options.upsert : false;\n  op.multi = options.multi !== void 0 ? !!options.multi : false;\n\n  if (options.hint) {\n    op.hint = options.hint;\n  }\n\n  if (finalOptions.arrayFilters) {\n    op.arrayFilters = finalOptions.arrayFilters;\n    delete finalOptions.arrayFilters;\n  }\n\n  if (finalOptions.retryWrites && op.multi) {\n    finalOptions.retryWrites = false;\n  } // Have we specified collation\n\n\n  try {\n    decorateWithCollation(finalOptions, coll, options);\n  } catch (err) {\n    return callback(err, null);\n  } // Update options\n\n\n  coll.s.topology.update(coll.s.namespace, [op], finalOptions, (err, result) => {\n    if (callback == null) return;\n    if (err) return handleCallback(callback, err, null);\n    if (result == null) return handleCallback(callback, null, null);\n    if (result.result.code) return handleCallback(callback, toError(result.result));\n    if (result.result.writeErrors) return handleCallback(callback, toError(result.result.writeErrors[0])); // Return the results\n\n    handleCallback(callback, null, result);\n  });\n}\n\nfunction updateCallback(err, r, callback) {\n  if (callback == null) return;\n  if (err) return callback(err);\n  if (r == null) return callback(null, {\n    result: {\n      ok: 1\n    }\n  });\n  r.modifiedCount = r.result.nModified != null ? r.result.nModified : r.result.n;\n  r.upsertedId = Array.isArray(r.result.upserted) && r.result.upserted.length > 0 ? r.result.upserted[0] // FIXME(major): should be `r.result.upserted[0]._id`\n  : null;\n  r.upsertedCount = Array.isArray(r.result.upserted) && r.result.upserted.length ? r.result.upserted.length : 0;\n  r.matchedCount = Array.isArray(r.result.upserted) && r.result.upserted.length > 0 ? 0 : r.result.n;\n  callback(null, r);\n}\n\nmodule.exports = {\n  buildCountCommand,\n  deleteCallback,\n  findAndModify,\n  indexInformation,\n  nextObject,\n  prepareDocs,\n  insertDocuments,\n  removeDocuments,\n  updateDocuments,\n  updateCallback\n};","map":{"version":3,"names":["applyRetryableWrites","require","applyWriteConcern","decorateWithCollation","decorateWithReadConcern","executeCommand","formattedOrderClause","handleCallback","MongoError","ReadPreference","toError","CursorState","buildCountCommand","collectionOrCursor","query","options","skip","limit","hint","maxTimeMS","cmd","count","collectionName","s","numberOfRetries","deleteCallback","err","r","callback","result","ok","deletedCount","n","findAndModify","coll","sort","doc","queryObject","new","remove","upsert","projection","fields","arrayFilters","update","serializeFunctions","checkKeys","finalOptions","Object","assign","db","collection","writeConcern","bypassDocumentValidation","readPreference","primary","indexInformation","name","full","serverConfig","isDestroyed","processResults","indexes","info","i","length","index","key","push","listIndexes","toArray","Array","isArray","prepareDocs","docs","forceServerObjectId","map","_id","pkFactory","createPk","nextObject","cursor","state","CLOSED","isDead","create","message","driver","INIT","_next","OPEN","insertDocuments","keepGoing","ordered","topology","insert","namespace","code","writeErrors","ops","removeDocuments","selector","op","q","single","retryWrites","updateDocuments","document","u","multi","updateCallback","modifiedCount","nModified","upsertedId","upserted","upsertedCount","matchedCount","module","exports"],"sources":["C:/Users/Administrator/Desktop/webAPI work/web/dog-website/node_modules/koa-mongo/node_modules/mongodb/lib/operations/common_functions.js"],"sourcesContent":["'use strict';\n\nconst applyRetryableWrites = require('../utils').applyRetryableWrites;\nconst applyWriteConcern = require('../utils').applyWriteConcern;\nconst decorateWithCollation = require('../utils').decorateWithCollation;\nconst decorateWithReadConcern = require('../utils').decorateWithReadConcern;\nconst executeCommand = require('./db_ops').executeCommand;\nconst formattedOrderClause = require('../utils').formattedOrderClause;\nconst handleCallback = require('../utils').handleCallback;\nconst MongoError = require('../core').MongoError;\nconst ReadPreference = require('../core').ReadPreference;\nconst toError = require('../utils').toError;\nconst CursorState = require('../core/cursor').CursorState;\n\n/**\n * Build the count command.\n *\n * @method\n * @param {collectionOrCursor} an instance of a collection or cursor\n * @param {object} query The query for the count.\n * @param {object} [options] Optional settings. See Collection.prototype.count and Cursor.prototype.count for a list of options.\n */\nfunction buildCountCommand(collectionOrCursor, query, options) {\n  const skip = options.skip;\n  const limit = options.limit;\n  let hint = options.hint;\n  const maxTimeMS = options.maxTimeMS;\n  query = query || {};\n\n  // Final query\n  const cmd = {\n    count: options.collectionName,\n    query: query\n  };\n\n  if (collectionOrCursor.s.numberOfRetries) {\n    // collectionOrCursor is a cursor\n    if (collectionOrCursor.options.hint) {\n      hint = collectionOrCursor.options.hint;\n    } else if (collectionOrCursor.cmd.hint) {\n      hint = collectionOrCursor.cmd.hint;\n    }\n    decorateWithCollation(cmd, collectionOrCursor, collectionOrCursor.cmd);\n  } else {\n    decorateWithCollation(cmd, collectionOrCursor, options);\n  }\n\n  // Add limit, skip and maxTimeMS if defined\n  if (typeof skip === 'number') cmd.skip = skip;\n  if (typeof limit === 'number') cmd.limit = limit;\n  if (typeof maxTimeMS === 'number') cmd.maxTimeMS = maxTimeMS;\n  if (hint) cmd.hint = hint;\n\n  // Do we have a readConcern specified\n  decorateWithReadConcern(cmd, collectionOrCursor);\n\n  return cmd;\n}\n\nfunction deleteCallback(err, r, callback) {\n  if (callback == null) return;\n  if (err && callback) return callback(err);\n  if (r == null) return callback(null, { result: { ok: 1 } });\n  r.deletedCount = r.result.n;\n  if (callback) callback(null, r);\n}\n\n/**\n * Find and update a document.\n *\n * @method\n * @param {Collection} a Collection instance.\n * @param {object} query Query object to locate the object to modify.\n * @param {array} sort If multiple docs match, choose the first one in the specified sort order as the object to manipulate.\n * @param {object} doc The fields/vals to be updated.\n * @param {object} [options] Optional settings. See Collection.prototype.findAndModify for a list of options.\n * @param {Collection~findAndModifyCallback} [callback] The command result callback\n * @deprecated use findOneAndUpdate, findOneAndReplace or findOneAndDelete instead\n */\nfunction findAndModify(coll, query, sort, doc, options, callback) {\n  // Create findAndModify command object\n  const queryObject = {\n    findAndModify: coll.collectionName,\n    query: query\n  };\n\n  sort = formattedOrderClause(sort);\n  if (sort) {\n    queryObject.sort = sort;\n  }\n\n  queryObject.new = options.new ? true : false;\n  queryObject.remove = options.remove ? true : false;\n  queryObject.upsert = options.upsert ? true : false;\n\n  const projection = options.projection || options.fields;\n\n  if (projection) {\n    queryObject.fields = projection;\n  }\n\n  if (options.arrayFilters) {\n    queryObject.arrayFilters = options.arrayFilters;\n    delete options.arrayFilters;\n  }\n\n  if (doc && !options.remove) {\n    queryObject.update = doc;\n  }\n\n  if (options.maxTimeMS) queryObject.maxTimeMS = options.maxTimeMS;\n\n  // Either use override on the function, or go back to default on either the collection\n  // level or db\n  options.serializeFunctions = options.serializeFunctions || coll.s.serializeFunctions;\n\n  // No check on the documents\n  options.checkKeys = false;\n\n  // Final options for retryable writes and write concern\n  let finalOptions = Object.assign({}, options);\n  finalOptions = applyRetryableWrites(finalOptions, coll.s.db);\n  finalOptions = applyWriteConcern(finalOptions, { db: coll.s.db, collection: coll }, options);\n\n  // Decorate the findAndModify command with the write Concern\n  if (finalOptions.writeConcern) {\n    queryObject.writeConcern = finalOptions.writeConcern;\n  }\n\n  // Have we specified bypassDocumentValidation\n  if (finalOptions.bypassDocumentValidation === true) {\n    queryObject.bypassDocumentValidation = finalOptions.bypassDocumentValidation;\n  }\n\n  finalOptions.readPreference = ReadPreference.primary;\n\n  // Have we specified collation\n  try {\n    decorateWithCollation(queryObject, coll, finalOptions);\n  } catch (err) {\n    return callback(err, null);\n  }\n\n  // Execute the command\n  executeCommand(coll.s.db, queryObject, finalOptions, (err, result) => {\n    if (err) return handleCallback(callback, err, null);\n\n    return handleCallback(callback, null, result);\n  });\n}\n\n/**\n * Retrieves this collections index info.\n *\n * @method\n * @param {Db} db The Db instance on which to retrieve the index info.\n * @param {string} name The name of the collection.\n * @param {object} [options] Optional settings. See Db.prototype.indexInformation for a list of options.\n * @param {Db~resultCallback} [callback] The command result callback\n */\nfunction indexInformation(db, name, options, callback) {\n  // If we specified full information\n  const full = options['full'] == null ? false : options['full'];\n\n  // Did the user destroy the topology\n  if (db.serverConfig && db.serverConfig.isDestroyed())\n    return callback(new MongoError('topology was destroyed'));\n  // Process all the results from the index command and collection\n  function processResults(indexes) {\n    // Contains all the information\n    let info = {};\n    // Process all the indexes\n    for (let i = 0; i < indexes.length; i++) {\n      const index = indexes[i];\n      // Let's unpack the object\n      info[index.name] = [];\n      for (let name in index.key) {\n        info[index.name].push([name, index.key[name]]);\n      }\n    }\n\n    return info;\n  }\n\n  // Get the list of indexes of the specified collection\n  db.collection(name)\n    .listIndexes(options)\n    .toArray((err, indexes) => {\n      if (err) return callback(toError(err));\n      if (!Array.isArray(indexes)) return handleCallback(callback, null, []);\n      if (full) return handleCallback(callback, null, indexes);\n      handleCallback(callback, null, processResults(indexes));\n    });\n}\n\nfunction prepareDocs(coll, docs, options) {\n  const forceServerObjectId =\n    typeof options.forceServerObjectId === 'boolean'\n      ? options.forceServerObjectId\n      : coll.s.db.options.forceServerObjectId;\n\n  // no need to modify the docs if server sets the ObjectId\n  if (forceServerObjectId === true) {\n    return docs;\n  }\n\n  return docs.map(doc => {\n    if (forceServerObjectId !== true && doc._id == null) {\n      doc._id = coll.s.pkFactory.createPk();\n    }\n\n    return doc;\n  });\n}\n\n// Get the next available document from the cursor, returns null if no more documents are available.\nfunction nextObject(cursor, callback) {\n  if (cursor.s.state === CursorState.CLOSED || (cursor.isDead && cursor.isDead())) {\n    return handleCallback(\n      callback,\n      MongoError.create({ message: 'Cursor is closed', driver: true })\n    );\n  }\n\n  if (cursor.s.state === CursorState.INIT && cursor.cmd && cursor.cmd.sort) {\n    try {\n      cursor.cmd.sort = formattedOrderClause(cursor.cmd.sort);\n    } catch (err) {\n      return handleCallback(callback, err);\n    }\n  }\n\n  // Get the next object\n  cursor._next((err, doc) => {\n    cursor.s.state = CursorState.OPEN;\n    if (err) return handleCallback(callback, err);\n    handleCallback(callback, null, doc);\n  });\n}\n\nfunction insertDocuments(coll, docs, options, callback) {\n  if (typeof options === 'function') (callback = options), (options = {});\n  options = options || {};\n  // Ensure we are operating on an array op docs\n  docs = Array.isArray(docs) ? docs : [docs];\n\n  // Final options for retryable writes and write concern\n  let finalOptions = Object.assign({}, options);\n  finalOptions = applyRetryableWrites(finalOptions, coll.s.db);\n  finalOptions = applyWriteConcern(finalOptions, { db: coll.s.db, collection: coll }, options);\n\n  // If keep going set unordered\n  if (finalOptions.keepGoing === true) finalOptions.ordered = false;\n  finalOptions.serializeFunctions = options.serializeFunctions || coll.s.serializeFunctions;\n\n  docs = prepareDocs(coll, docs, options);\n\n  // File inserts\n  coll.s.topology.insert(coll.s.namespace, docs, finalOptions, (err, result) => {\n    if (callback == null) return;\n    if (err) return handleCallback(callback, err);\n    if (result == null) return handleCallback(callback, null, null);\n    if (result.result.code) return handleCallback(callback, toError(result.result));\n    if (result.result.writeErrors)\n      return handleCallback(callback, toError(result.result.writeErrors[0]));\n    // Add docs to the list\n    result.ops = docs;\n    // Return the results\n    handleCallback(callback, null, result);\n  });\n}\n\nfunction removeDocuments(coll, selector, options, callback) {\n  if (typeof options === 'function') {\n    (callback = options), (options = {});\n  } else if (typeof selector === 'function') {\n    callback = selector;\n    options = {};\n    selector = {};\n  }\n\n  // Create an empty options object if the provided one is null\n  options = options || {};\n\n  // Final options for retryable writes and write concern\n  let finalOptions = Object.assign({}, options);\n  finalOptions = applyRetryableWrites(finalOptions, coll.s.db);\n  finalOptions = applyWriteConcern(finalOptions, { db: coll.s.db, collection: coll }, options);\n\n  // If selector is null set empty\n  if (selector == null) selector = {};\n\n  // Build the op\n  const op = { q: selector, limit: 0 };\n  if (options.single) {\n    op.limit = 1;\n  } else if (finalOptions.retryWrites) {\n    finalOptions.retryWrites = false;\n  }\n  if (options.hint) {\n    op.hint = options.hint;\n  }\n\n  // Have we specified collation\n  try {\n    decorateWithCollation(finalOptions, coll, options);\n  } catch (err) {\n    return callback(err, null);\n  }\n\n  // Execute the remove\n  coll.s.topology.remove(coll.s.namespace, [op], finalOptions, (err, result) => {\n    if (callback == null) return;\n    if (err) return handleCallback(callback, err, null);\n    if (result == null) return handleCallback(callback, null, null);\n    if (result.result.code) return handleCallback(callback, toError(result.result));\n    if (result.result.writeErrors) {\n      return handleCallback(callback, toError(result.result.writeErrors[0]));\n    }\n\n    // Return the results\n    handleCallback(callback, null, result);\n  });\n}\n\nfunction updateDocuments(coll, selector, document, options, callback) {\n  if ('function' === typeof options) (callback = options), (options = null);\n  if (options == null) options = {};\n  if (!('function' === typeof callback)) callback = null;\n\n  // If we are not providing a selector or document throw\n  if (selector == null || typeof selector !== 'object')\n    return callback(toError('selector must be a valid JavaScript object'));\n  if (document == null || typeof document !== 'object')\n    return callback(toError('document must be a valid JavaScript object'));\n\n  // Final options for retryable writes and write concern\n  let finalOptions = Object.assign({}, options);\n  finalOptions = applyRetryableWrites(finalOptions, coll.s.db);\n  finalOptions = applyWriteConcern(finalOptions, { db: coll.s.db, collection: coll }, options);\n\n  // Do we return the actual result document\n  // Either use override on the function, or go back to default on either the collection\n  // level or db\n  finalOptions.serializeFunctions = options.serializeFunctions || coll.s.serializeFunctions;\n\n  // Execute the operation\n  const op = { q: selector, u: document };\n  op.upsert = options.upsert !== void 0 ? !!options.upsert : false;\n  op.multi = options.multi !== void 0 ? !!options.multi : false;\n\n  if (options.hint) {\n    op.hint = options.hint;\n  }\n\n  if (finalOptions.arrayFilters) {\n    op.arrayFilters = finalOptions.arrayFilters;\n    delete finalOptions.arrayFilters;\n  }\n\n  if (finalOptions.retryWrites && op.multi) {\n    finalOptions.retryWrites = false;\n  }\n\n  // Have we specified collation\n  try {\n    decorateWithCollation(finalOptions, coll, options);\n  } catch (err) {\n    return callback(err, null);\n  }\n\n  // Update options\n  coll.s.topology.update(coll.s.namespace, [op], finalOptions, (err, result) => {\n    if (callback == null) return;\n    if (err) return handleCallback(callback, err, null);\n    if (result == null) return handleCallback(callback, null, null);\n    if (result.result.code) return handleCallback(callback, toError(result.result));\n    if (result.result.writeErrors)\n      return handleCallback(callback, toError(result.result.writeErrors[0]));\n    // Return the results\n    handleCallback(callback, null, result);\n  });\n}\n\nfunction updateCallback(err, r, callback) {\n  if (callback == null) return;\n  if (err) return callback(err);\n  if (r == null) return callback(null, { result: { ok: 1 } });\n  r.modifiedCount = r.result.nModified != null ? r.result.nModified : r.result.n;\n  r.upsertedId =\n    Array.isArray(r.result.upserted) && r.result.upserted.length > 0\n      ? r.result.upserted[0] // FIXME(major): should be `r.result.upserted[0]._id`\n      : null;\n  r.upsertedCount =\n    Array.isArray(r.result.upserted) && r.result.upserted.length ? r.result.upserted.length : 0;\n  r.matchedCount =\n    Array.isArray(r.result.upserted) && r.result.upserted.length > 0 ? 0 : r.result.n;\n  callback(null, r);\n}\n\nmodule.exports = {\n  buildCountCommand,\n  deleteCallback,\n  findAndModify,\n  indexInformation,\n  nextObject,\n  prepareDocs,\n  insertDocuments,\n  removeDocuments,\n  updateDocuments,\n  updateCallback\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}