{"ast":null,"code":"'use strict';\n\nconst Msg = require('../connection/msg').Msg;\n\nconst KillCursor = require('../connection/commands').KillCursor;\n\nconst GetMore = require('../connection/commands').GetMore;\n\nconst calculateDurationInMs = require('../../utils').calculateDurationInMs;\n/** Commands that we want to redact because of the sensitive nature of their contents */\n\n\nconst SENSITIVE_COMMANDS = new Set(['authenticate', 'saslStart', 'saslContinue', 'getnonce', 'createUser', 'updateUser', 'copydbgetnonce', 'copydbsaslstart', 'copydb']); // helper methods\n\nconst extractCommandName = commandDoc => Object.keys(commandDoc)[0];\n\nconst namespace = command => command.ns;\n\nconst databaseName = command => command.ns.split('.')[0];\n\nconst collectionName = command => command.ns.split('.')[1];\n\nconst generateConnectionId = pool => pool.options ? `${pool.options.host}:${pool.options.port}` : pool.address;\n\nconst maybeRedact = (commandName, result) => SENSITIVE_COMMANDS.has(commandName) ? {} : result;\n\nconst isLegacyPool = pool => pool.s && pool.queue;\n\nconst LEGACY_FIND_QUERY_MAP = {\n  $query: 'filter',\n  $orderby: 'sort',\n  $hint: 'hint',\n  $comment: 'comment',\n  $maxScan: 'maxScan',\n  $max: 'max',\n  $min: 'min',\n  $returnKey: 'returnKey',\n  $showDiskLoc: 'showRecordId',\n  $maxTimeMS: 'maxTimeMS',\n  $snapshot: 'snapshot'\n};\nconst LEGACY_FIND_OPTIONS_MAP = {\n  numberToSkip: 'skip',\n  numberToReturn: 'batchSize',\n  returnFieldsSelector: 'projection'\n};\nconst OP_QUERY_KEYS = ['tailable', 'oplogReplay', 'noCursorTimeout', 'awaitData', 'partial', 'exhaust'];\n/**\n * Extract the actual command from the query, possibly upconverting if it's a legacy\n * format\n *\n * @param {Object} command the command\n */\n\nconst extractCommand = command => {\n  if (command instanceof GetMore) {\n    return {\n      getMore: command.cursorId,\n      collection: collectionName(command),\n      batchSize: command.numberToReturn\n    };\n  }\n\n  if (command instanceof KillCursor) {\n    return {\n      killCursors: collectionName(command),\n      cursors: command.cursorIds\n    };\n  }\n\n  if (command instanceof Msg) {\n    return command.command;\n  }\n\n  if (command.query && command.query.$query) {\n    let result;\n\n    if (command.ns === 'admin.$cmd') {\n      // upconvert legacy command\n      result = Object.assign({}, command.query.$query);\n    } else {\n      // upconvert legacy find command\n      result = {\n        find: collectionName(command)\n      };\n      Object.keys(LEGACY_FIND_QUERY_MAP).forEach(key => {\n        if (typeof command.query[key] !== 'undefined') result[LEGACY_FIND_QUERY_MAP[key]] = command.query[key];\n      });\n    }\n\n    Object.keys(LEGACY_FIND_OPTIONS_MAP).forEach(key => {\n      if (typeof command[key] !== 'undefined') result[LEGACY_FIND_OPTIONS_MAP[key]] = command[key];\n    });\n    OP_QUERY_KEYS.forEach(key => {\n      if (command[key]) result[key] = command[key];\n    });\n\n    if (typeof command.pre32Limit !== 'undefined') {\n      result.limit = command.pre32Limit;\n    }\n\n    if (command.query.$explain) {\n      return {\n        explain: result\n      };\n    }\n\n    return result;\n  }\n\n  return command.query ? command.query : command;\n};\n\nconst extractReply = (command, reply) => {\n  if (command instanceof GetMore) {\n    return {\n      ok: 1,\n      cursor: {\n        id: reply.message.cursorId,\n        ns: namespace(command),\n        nextBatch: reply.message.documents\n      }\n    };\n  }\n\n  if (command instanceof KillCursor) {\n    return {\n      ok: 1,\n      cursorsUnknown: command.cursorIds\n    };\n  } // is this a legacy find command?\n\n\n  if (command.query && typeof command.query.$query !== 'undefined') {\n    return {\n      ok: 1,\n      cursor: {\n        id: reply.message.cursorId,\n        ns: namespace(command),\n        firstBatch: reply.message.documents\n      }\n    };\n  }\n\n  return reply && reply.result ? reply.result : reply;\n};\n\nconst extractConnectionDetails = pool => {\n  if (isLegacyPool(pool)) {\n    return {\n      connectionId: generateConnectionId(pool)\n    };\n  } // APM in the modern pool is done at the `Connection` level, so we rename it here for\n  // readability.\n\n\n  const connection = pool;\n  return {\n    address: connection.address,\n    connectionId: connection.id\n  };\n};\n/** An event indicating the start of a given command */\n\n\nclass CommandStartedEvent {\n  /**\n   * Create a started event\n   *\n   * @param {Pool} pool the pool that originated the command\n   * @param {Object} command the command\n   */\n  constructor(pool, command) {\n    const cmd = extractCommand(command);\n    const commandName = extractCommandName(cmd);\n    const connectionDetails = extractConnectionDetails(pool); // NOTE: remove in major revision, this is not spec behavior\n\n    if (SENSITIVE_COMMANDS.has(commandName)) {\n      this.commandObj = {};\n      this.commandObj[commandName] = true;\n    }\n\n    Object.assign(this, connectionDetails, {\n      requestId: command.requestId,\n      databaseName: databaseName(command),\n      commandName,\n      command: cmd\n    });\n  }\n\n}\n/** An event indicating the success of a given command */\n\n\nclass CommandSucceededEvent {\n  /**\n   * Create a succeeded event\n   *\n   * @param {Pool} pool the pool that originated the command\n   * @param {Object} command the command\n   * @param {Object} reply the reply for this command from the server\n   * @param {Array} started a high resolution tuple timestamp of when the command was first sent, to calculate duration\n   */\n  constructor(pool, command, reply, started) {\n    const cmd = extractCommand(command);\n    const commandName = extractCommandName(cmd);\n    const connectionDetails = extractConnectionDetails(pool);\n    Object.assign(this, connectionDetails, {\n      requestId: command.requestId,\n      commandName,\n      duration: calculateDurationInMs(started),\n      reply: maybeRedact(commandName, extractReply(command, reply))\n    });\n  }\n\n}\n/** An event indicating the failure of a given command */\n\n\nclass CommandFailedEvent {\n  /**\n   * Create a failure event\n   *\n   * @param {Pool} pool the pool that originated the command\n   * @param {Object} command the command\n   * @param {MongoError|Object} error the generated error or a server error response\n   * @param {Array} started a high resolution tuple timestamp of when the command was first sent, to calculate duration\n   */\n  constructor(pool, command, error, started) {\n    const cmd = extractCommand(command);\n    const commandName = extractCommandName(cmd);\n    const connectionDetails = extractConnectionDetails(pool);\n    Object.assign(this, connectionDetails, {\n      requestId: command.requestId,\n      commandName,\n      duration: calculateDurationInMs(started),\n      failure: maybeRedact(commandName, error)\n    });\n  }\n\n}\n\nmodule.exports = {\n  CommandStartedEvent,\n  CommandSucceededEvent,\n  CommandFailedEvent\n};","map":{"version":3,"names":["Msg","require","KillCursor","GetMore","calculateDurationInMs","SENSITIVE_COMMANDS","Set","extractCommandName","commandDoc","Object","keys","namespace","command","ns","databaseName","split","collectionName","generateConnectionId","pool","options","host","port","address","maybeRedact","commandName","result","has","isLegacyPool","s","queue","LEGACY_FIND_QUERY_MAP","$query","$orderby","$hint","$comment","$maxScan","$max","$min","$returnKey","$showDiskLoc","$maxTimeMS","$snapshot","LEGACY_FIND_OPTIONS_MAP","numberToSkip","numberToReturn","returnFieldsSelector","OP_QUERY_KEYS","extractCommand","getMore","cursorId","collection","batchSize","killCursors","cursors","cursorIds","query","assign","find","forEach","key","pre32Limit","limit","$explain","explain","extractReply","reply","ok","cursor","id","message","nextBatch","documents","cursorsUnknown","firstBatch","extractConnectionDetails","connectionId","connection","CommandStartedEvent","constructor","cmd","connectionDetails","commandObj","requestId","CommandSucceededEvent","started","duration","CommandFailedEvent","error","failure","module","exports"],"sources":["C:/Users/Administrator/Desktop/webAPI work/web/dog-website/node_modules/koa-mongo/node_modules/mongodb/lib/core/connection/apm.js"],"sourcesContent":["'use strict';\nconst Msg = require('../connection/msg').Msg;\nconst KillCursor = require('../connection/commands').KillCursor;\nconst GetMore = require('../connection/commands').GetMore;\nconst calculateDurationInMs = require('../../utils').calculateDurationInMs;\n\n/** Commands that we want to redact because of the sensitive nature of their contents */\nconst SENSITIVE_COMMANDS = new Set([\n  'authenticate',\n  'saslStart',\n  'saslContinue',\n  'getnonce',\n  'createUser',\n  'updateUser',\n  'copydbgetnonce',\n  'copydbsaslstart',\n  'copydb'\n]);\n\n// helper methods\nconst extractCommandName = commandDoc => Object.keys(commandDoc)[0];\nconst namespace = command => command.ns;\nconst databaseName = command => command.ns.split('.')[0];\nconst collectionName = command => command.ns.split('.')[1];\nconst generateConnectionId = pool =>\n  pool.options ? `${pool.options.host}:${pool.options.port}` : pool.address;\nconst maybeRedact = (commandName, result) => (SENSITIVE_COMMANDS.has(commandName) ? {} : result);\nconst isLegacyPool = pool => pool.s && pool.queue;\n\nconst LEGACY_FIND_QUERY_MAP = {\n  $query: 'filter',\n  $orderby: 'sort',\n  $hint: 'hint',\n  $comment: 'comment',\n  $maxScan: 'maxScan',\n  $max: 'max',\n  $min: 'min',\n  $returnKey: 'returnKey',\n  $showDiskLoc: 'showRecordId',\n  $maxTimeMS: 'maxTimeMS',\n  $snapshot: 'snapshot'\n};\n\nconst LEGACY_FIND_OPTIONS_MAP = {\n  numberToSkip: 'skip',\n  numberToReturn: 'batchSize',\n  returnFieldsSelector: 'projection'\n};\n\nconst OP_QUERY_KEYS = [\n  'tailable',\n  'oplogReplay',\n  'noCursorTimeout',\n  'awaitData',\n  'partial',\n  'exhaust'\n];\n\n/**\n * Extract the actual command from the query, possibly upconverting if it's a legacy\n * format\n *\n * @param {Object} command the command\n */\nconst extractCommand = command => {\n  if (command instanceof GetMore) {\n    return {\n      getMore: command.cursorId,\n      collection: collectionName(command),\n      batchSize: command.numberToReturn\n    };\n  }\n\n  if (command instanceof KillCursor) {\n    return {\n      killCursors: collectionName(command),\n      cursors: command.cursorIds\n    };\n  }\n\n  if (command instanceof Msg) {\n    return command.command;\n  }\n\n  if (command.query && command.query.$query) {\n    let result;\n    if (command.ns === 'admin.$cmd') {\n      // upconvert legacy command\n      result = Object.assign({}, command.query.$query);\n    } else {\n      // upconvert legacy find command\n      result = { find: collectionName(command) };\n      Object.keys(LEGACY_FIND_QUERY_MAP).forEach(key => {\n        if (typeof command.query[key] !== 'undefined')\n          result[LEGACY_FIND_QUERY_MAP[key]] = command.query[key];\n      });\n    }\n\n    Object.keys(LEGACY_FIND_OPTIONS_MAP).forEach(key => {\n      if (typeof command[key] !== 'undefined') result[LEGACY_FIND_OPTIONS_MAP[key]] = command[key];\n    });\n\n    OP_QUERY_KEYS.forEach(key => {\n      if (command[key]) result[key] = command[key];\n    });\n\n    if (typeof command.pre32Limit !== 'undefined') {\n      result.limit = command.pre32Limit;\n    }\n\n    if (command.query.$explain) {\n      return { explain: result };\n    }\n\n    return result;\n  }\n\n  return command.query ? command.query : command;\n};\n\nconst extractReply = (command, reply) => {\n  if (command instanceof GetMore) {\n    return {\n      ok: 1,\n      cursor: {\n        id: reply.message.cursorId,\n        ns: namespace(command),\n        nextBatch: reply.message.documents\n      }\n    };\n  }\n\n  if (command instanceof KillCursor) {\n    return {\n      ok: 1,\n      cursorsUnknown: command.cursorIds\n    };\n  }\n\n  // is this a legacy find command?\n  if (command.query && typeof command.query.$query !== 'undefined') {\n    return {\n      ok: 1,\n      cursor: {\n        id: reply.message.cursorId,\n        ns: namespace(command),\n        firstBatch: reply.message.documents\n      }\n    };\n  }\n\n  return reply && reply.result ? reply.result : reply;\n};\n\nconst extractConnectionDetails = pool => {\n  if (isLegacyPool(pool)) {\n    return {\n      connectionId: generateConnectionId(pool)\n    };\n  }\n\n  // APM in the modern pool is done at the `Connection` level, so we rename it here for\n  // readability.\n  const connection = pool;\n  return {\n    address: connection.address,\n    connectionId: connection.id\n  };\n};\n\n/** An event indicating the start of a given command */\nclass CommandStartedEvent {\n  /**\n   * Create a started event\n   *\n   * @param {Pool} pool the pool that originated the command\n   * @param {Object} command the command\n   */\n  constructor(pool, command) {\n    const cmd = extractCommand(command);\n    const commandName = extractCommandName(cmd);\n    const connectionDetails = extractConnectionDetails(pool);\n\n    // NOTE: remove in major revision, this is not spec behavior\n    if (SENSITIVE_COMMANDS.has(commandName)) {\n      this.commandObj = {};\n      this.commandObj[commandName] = true;\n    }\n\n    Object.assign(this, connectionDetails, {\n      requestId: command.requestId,\n      databaseName: databaseName(command),\n      commandName,\n      command: cmd\n    });\n  }\n}\n\n/** An event indicating the success of a given command */\nclass CommandSucceededEvent {\n  /**\n   * Create a succeeded event\n   *\n   * @param {Pool} pool the pool that originated the command\n   * @param {Object} command the command\n   * @param {Object} reply the reply for this command from the server\n   * @param {Array} started a high resolution tuple timestamp of when the command was first sent, to calculate duration\n   */\n  constructor(pool, command, reply, started) {\n    const cmd = extractCommand(command);\n    const commandName = extractCommandName(cmd);\n    const connectionDetails = extractConnectionDetails(pool);\n\n    Object.assign(this, connectionDetails, {\n      requestId: command.requestId,\n      commandName,\n      duration: calculateDurationInMs(started),\n      reply: maybeRedact(commandName, extractReply(command, reply))\n    });\n  }\n}\n\n/** An event indicating the failure of a given command */\nclass CommandFailedEvent {\n  /**\n   * Create a failure event\n   *\n   * @param {Pool} pool the pool that originated the command\n   * @param {Object} command the command\n   * @param {MongoError|Object} error the generated error or a server error response\n   * @param {Array} started a high resolution tuple timestamp of when the command was first sent, to calculate duration\n   */\n  constructor(pool, command, error, started) {\n    const cmd = extractCommand(command);\n    const commandName = extractCommandName(cmd);\n    const connectionDetails = extractConnectionDetails(pool);\n\n    Object.assign(this, connectionDetails, {\n      requestId: command.requestId,\n      commandName,\n      duration: calculateDurationInMs(started),\n      failure: maybeRedact(commandName, error)\n    });\n  }\n}\n\nmodule.exports = {\n  CommandStartedEvent,\n  CommandSucceededEvent,\n  CommandFailedEvent\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}