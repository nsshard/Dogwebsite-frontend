{"ast":null,"code":"'use strict';\n\nconst inherits = require('util').inherits;\n\nconst EventEmitter = require('events').EventEmitter;\n\nconst MongoError = require('../error').MongoError;\n\nconst MongoTimeoutError = require('../error').MongoTimeoutError;\n\nconst MongoWriteConcernError = require('../error').MongoWriteConcernError;\n\nconst Logger = require('./logger');\n\nconst f = require('util').format;\n\nconst Msg = require('./msg').Msg;\n\nconst CommandResult = require('./command_result');\n\nconst MESSAGE_HEADER_SIZE = require('../wireprotocol/shared').MESSAGE_HEADER_SIZE;\n\nconst COMPRESSION_DETAILS_SIZE = require('../wireprotocol/shared').COMPRESSION_DETAILS_SIZE;\n\nconst opcodes = require('../wireprotocol/shared').opcodes;\n\nconst compress = require('../wireprotocol/compression').compress;\n\nconst compressorIDs = require('../wireprotocol/compression').compressorIDs;\n\nconst uncompressibleCommands = require('../wireprotocol/compression').uncompressibleCommands;\n\nconst apm = require('./apm');\n\nconst Buffer = require('safe-buffer').Buffer;\n\nconst connect = require('./connect');\n\nconst updateSessionFromResponse = require('../sessions').updateSessionFromResponse;\n\nconst eachAsync = require('../utils').eachAsync;\n\nconst makeStateMachine = require('../utils').makeStateMachine;\n\nconst now = require('../../utils').now;\n\nconst DISCONNECTED = 'disconnected';\nconst CONNECTING = 'connecting';\nconst CONNECTED = 'connected';\nconst DRAINING = 'draining';\nconst DESTROYING = 'destroying';\nconst DESTROYED = 'destroyed';\nconst stateTransition = makeStateMachine({\n  [DISCONNECTED]: [CONNECTING, DRAINING, DISCONNECTED],\n  [CONNECTING]: [CONNECTING, CONNECTED, DRAINING, DISCONNECTED],\n  [CONNECTED]: [CONNECTED, DISCONNECTED, DRAINING],\n  [DRAINING]: [DRAINING, DESTROYING, DESTROYED],\n  [DESTROYING]: [DESTROYING, DESTROYED],\n  [DESTROYED]: [DESTROYED]\n});\nconst CONNECTION_EVENTS = new Set(['error', 'close', 'timeout', 'parseError', 'connect', 'message']);\nvar _id = 0;\n/**\n * Creates a new Pool instance\n * @class\n * @param {string} options.host The server host\n * @param {number} options.port The server port\n * @param {number} [options.size=5] Max server connection pool size\n * @param {number} [options.minSize=0] Minimum server connection pool size\n * @param {boolean} [options.reconnect=true] Server will attempt to reconnect on loss of connection\n * @param {number} [options.reconnectTries=30] Server attempt to reconnect #times\n * @param {number} [options.reconnectInterval=1000] Server will wait # milliseconds between retries\n * @param {boolean} [options.keepAlive=true] TCP Connection keep alive enabled\n * @param {number} [options.keepAliveInitialDelay=120000] Initial delay before TCP keep alive enabled\n * @param {boolean} [options.noDelay=true] TCP Connection no delay\n * @param {number} [options.connectionTimeout=30000] TCP Connection timeout setting\n * @param {number} [options.socketTimeout=0] TCP Socket timeout setting\n * @param {number} [options.monitoringSocketTimeout=0] TCP Socket timeout setting for replicaset monitoring socket\n * @param {boolean} [options.ssl=false] Use SSL for connection\n * @param {boolean|function} [options.checkServerIdentity=true] Ensure we check server identify during SSL, set to false to disable checking. Only works for Node 0.12.x or higher. You can pass in a boolean or your own checkServerIdentity override function.\n * @param {Buffer} [options.ca] SSL Certificate store binary buffer\n * @param {Buffer} [options.crl] SSL Certificate revocation store binary buffer\n * @param {Buffer} [options.cert] SSL Certificate binary buffer\n * @param {Buffer} [options.key] SSL Key file binary buffer\n * @param {string} [options.passphrase] SSL Certificate pass phrase\n * @param {boolean} [options.rejectUnauthorized=false] Reject unauthorized server certificates\n * @param {boolean} [options.promoteLongs=true] Convert Long values from the db into Numbers if they fit into 53 bits\n * @param {boolean} [options.promoteValues=true] Promotes BSON values to native types where possible, set to false to only receive wrapper types.\n * @param {boolean} [options.promoteBuffers=false] Promotes Binary BSON values to native Node Buffers.\n * @param {boolean} [options.domainsEnabled=false] Enable the wrapping of the callback in the current domain, disabled by default to avoid perf hit.\n * @fires Pool#connect\n * @fires Pool#close\n * @fires Pool#error\n * @fires Pool#timeout\n * @fires Pool#parseError\n * @return {Pool} A cursor instance\n */\n\nvar Pool = function (topology, options) {\n  // Add event listener\n  EventEmitter.call(this); // Store topology for later use\n\n  this.topology = topology;\n  this.s = {\n    state: DISCONNECTED,\n    cancellationToken: new EventEmitter()\n  }; // we don't care how many connections are listening for cancellation\n\n  this.s.cancellationToken.setMaxListeners(Infinity); // Add the options\n\n  this.options = Object.assign({\n    // Host and port settings\n    host: 'localhost',\n    port: 27017,\n    // Pool default max size\n    size: 5,\n    // Pool default min size\n    minSize: 0,\n    // socket settings\n    connectionTimeout: 30000,\n    socketTimeout: 0,\n    keepAlive: true,\n    keepAliveInitialDelay: 120000,\n    noDelay: true,\n    // SSL Settings\n    ssl: false,\n    checkServerIdentity: true,\n    ca: null,\n    crl: null,\n    cert: null,\n    key: null,\n    passphrase: null,\n    rejectUnauthorized: false,\n    promoteLongs: true,\n    promoteValues: true,\n    promoteBuffers: false,\n    // Reconnection options\n    reconnect: true,\n    reconnectInterval: 1000,\n    reconnectTries: 30,\n    // Enable domains\n    domainsEnabled: false,\n    // feature flag for determining if we are running with the unified topology or not\n    legacyCompatMode: true\n  }, options); // Identification information\n\n  this.id = _id++; // Current reconnect retries\n\n  this.retriesLeft = this.options.reconnectTries;\n  this.reconnectId = null;\n  this.reconnectError = null; // No bson parser passed in\n\n  if (!options.bson || options.bson && (typeof options.bson.serialize !== 'function' || typeof options.bson.deserialize !== 'function')) {\n    throw new Error('must pass in valid bson parser');\n  } // Logger instance\n\n\n  this.logger = Logger('Pool', options); // Connections\n\n  this.availableConnections = [];\n  this.inUseConnections = [];\n  this.connectingConnections = 0; // Currently executing\n\n  this.executing = false; // Operation work queue\n\n  this.queue = []; // Number of consecutive timeouts caught\n\n  this.numberOfConsecutiveTimeouts = 0; // Current pool Index\n\n  this.connectionIndex = 0; // event handlers\n\n  const pool = this;\n  this._messageHandler = messageHandler(this);\n\n  this._connectionCloseHandler = function (err) {\n    const connection = this;\n    connectionFailureHandler(pool, 'close', err, connection);\n  };\n\n  this._connectionErrorHandler = function (err) {\n    const connection = this;\n    connectionFailureHandler(pool, 'error', err, connection);\n  };\n\n  this._connectionTimeoutHandler = function (err) {\n    const connection = this;\n    connectionFailureHandler(pool, 'timeout', err, connection);\n  };\n\n  this._connectionParseErrorHandler = function (err) {\n    const connection = this;\n    connectionFailureHandler(pool, 'parseError', err, connection);\n  };\n};\n\ninherits(Pool, EventEmitter);\nObject.defineProperty(Pool.prototype, 'size', {\n  enumerable: true,\n  get: function () {\n    return this.options.size;\n  }\n});\nObject.defineProperty(Pool.prototype, 'minSize', {\n  enumerable: true,\n  get: function () {\n    return this.options.minSize;\n  }\n});\nObject.defineProperty(Pool.prototype, 'connectionTimeout', {\n  enumerable: true,\n  get: function () {\n    return this.options.connectionTimeout;\n  }\n});\nObject.defineProperty(Pool.prototype, 'socketTimeout', {\n  enumerable: true,\n  get: function () {\n    return this.options.socketTimeout;\n  }\n});\nObject.defineProperty(Pool.prototype, 'state', {\n  enumerable: true,\n  get: function () {\n    return this.s.state;\n  }\n}); // clears all pool state\n\nfunction resetPoolState(pool) {\n  pool.inUseConnections = [];\n  pool.availableConnections = [];\n  pool.connectingConnections = 0;\n  pool.executing = false;\n  pool.numberOfConsecutiveTimeouts = 0;\n  pool.connectionIndex = 0;\n  pool.retriesLeft = pool.options.reconnectTries;\n  pool.reconnectId = null;\n}\n\nfunction connectionFailureHandler(pool, event, err, conn) {\n  if (conn) {\n    if (conn._connectionFailHandled) {\n      return;\n    }\n\n    conn._connectionFailHandled = true;\n    conn.destroy(); // Remove the connection\n\n    removeConnection(pool, conn); // flush remaining work items\n\n    conn.flush(err);\n  } // Did we catch a timeout, increment the numberOfConsecutiveTimeouts\n\n\n  if (event === 'timeout') {\n    pool.numberOfConsecutiveTimeouts = pool.numberOfConsecutiveTimeouts + 1; // Have we timed out more than reconnectTries in a row ?\n    // Force close the pool as we are trying to connect to tcp sink hole\n\n    if (pool.numberOfConsecutiveTimeouts > pool.options.reconnectTries) {\n      pool.numberOfConsecutiveTimeouts = 0; // Destroy all connections and pool\n\n      pool.destroy(true); // Emit close event\n\n      return pool.emit('close', pool);\n    }\n  } // No more socket available propegate the event\n\n\n  if (pool.socketCount() === 0) {\n    if (pool.state !== DESTROYED && pool.state !== DESTROYING && pool.state !== DRAINING) {\n      if (pool.options.reconnect) {\n        stateTransition(pool, DISCONNECTED);\n      }\n    } // Do not emit error events, they are always close events\n    // do not trigger the low level error handler in node\n\n\n    event = event === 'error' ? 'close' : event;\n    pool.emit(event, err);\n  } // Start reconnection attempts\n\n\n  if (!pool.reconnectId && pool.options.reconnect) {\n    pool.reconnectError = err;\n    pool.reconnectId = setTimeout(attemptReconnect(pool), pool.options.reconnectInterval);\n  } // Do we need to do anything to maintain the minimum pool size\n\n\n  const totalConnections = totalConnectionCount(pool);\n\n  if (totalConnections < pool.minSize) {\n    createConnection(pool);\n  }\n}\n\nfunction attemptReconnect(pool, callback) {\n  return function () {\n    pool.emit('attemptReconnect', pool);\n\n    if (pool.state === DESTROYED || pool.state === DESTROYING) {\n      if (typeof callback === 'function') {\n        callback(new MongoError('Cannot create connection when pool is destroyed'));\n      }\n\n      return;\n    }\n\n    pool.retriesLeft = pool.retriesLeft - 1;\n\n    if (pool.retriesLeft <= 0) {\n      pool.destroy();\n      const error = new MongoTimeoutError(`failed to reconnect after ${pool.options.reconnectTries} attempts with interval ${pool.options.reconnectInterval} ms`, pool.reconnectError);\n      pool.emit('reconnectFailed', error);\n\n      if (typeof callback === 'function') {\n        callback(error);\n      }\n\n      return;\n    } // clear the reconnect id on retry\n\n\n    pool.reconnectId = null; // now retry creating a connection\n\n    createConnection(pool, (err, conn) => {\n      if (err == null) {\n        pool.reconnectId = null;\n        pool.retriesLeft = pool.options.reconnectTries;\n        pool.emit('reconnect', pool);\n      }\n\n      if (typeof callback === 'function') {\n        callback(err, conn);\n      }\n    });\n  };\n}\n\nfunction moveConnectionBetween(connection, from, to) {\n  var index = from.indexOf(connection); // Move the connection from connecting to available\n\n  if (index !== -1) {\n    from.splice(index, 1);\n    to.push(connection);\n  }\n}\n\nfunction messageHandler(self) {\n  return function (message, connection) {\n    // workItem to execute\n    var workItem = null; // Locate the workItem\n\n    for (var i = 0; i < connection.workItems.length; i++) {\n      if (connection.workItems[i].requestId === message.responseTo) {\n        // Get the callback\n        workItem = connection.workItems[i]; // Remove from list of workItems\n\n        connection.workItems.splice(i, 1);\n      }\n    }\n\n    if (workItem && workItem.monitoring) {\n      moveConnectionBetween(connection, self.inUseConnections, self.availableConnections);\n    } // Reset timeout counter\n\n\n    self.numberOfConsecutiveTimeouts = 0; // Reset the connection timeout if we modified it for\n    // this operation\n\n    if (workItem && workItem.socketTimeout) {\n      connection.resetSocketTimeout();\n    } // Log if debug enabled\n\n\n    if (self.logger.isDebug()) {\n      self.logger.debug(f('message [%s] received from %s:%s', message.raw.toString('hex'), self.options.host, self.options.port));\n    }\n\n    function handleOperationCallback(self, cb, err, result) {\n      // No domain enabled\n      if (!self.options.domainsEnabled) {\n        return process.nextTick(function () {\n          return cb(err, result);\n        });\n      } // Domain enabled just call the callback\n\n\n      cb(err, result);\n    } // Keep executing, ensure current message handler does not stop execution\n\n\n    if (!self.executing) {\n      process.nextTick(function () {\n        _execute(self)();\n      });\n    } // Time to dispatch the message if we have a callback\n\n\n    if (workItem && !workItem.immediateRelease) {\n      try {\n        // Parse the message according to the provided options\n        message.parse(workItem);\n      } catch (err) {\n        return handleOperationCallback(self, workItem.cb, new MongoError(err));\n      }\n\n      if (message.documents[0]) {\n        const document = message.documents[0];\n        const session = workItem.session;\n\n        if (session) {\n          updateSessionFromResponse(session, document);\n        }\n\n        if (self.topology && document.$clusterTime) {\n          self.topology.clusterTime = document.$clusterTime;\n        }\n      } // Establish if we have an error\n\n\n      if (workItem.command && message.documents[0]) {\n        const responseDoc = message.documents[0];\n\n        if (responseDoc.writeConcernError) {\n          const err = new MongoWriteConcernError(responseDoc.writeConcernError, responseDoc);\n          return handleOperationCallback(self, workItem.cb, err);\n        }\n\n        if (responseDoc.ok === 0 || responseDoc.$err || responseDoc.errmsg || responseDoc.code) {\n          return handleOperationCallback(self, workItem.cb, new MongoError(responseDoc));\n        }\n      } // Add the connection details\n\n\n      message.hashedName = connection.hashedName; // Return the documents\n\n      handleOperationCallback(self, workItem.cb, null, new CommandResult(workItem.fullResult ? message : message.documents[0], connection, message));\n    }\n  };\n}\n/**\n * Return the total socket count in the pool.\n * @method\n * @return {Number} The number of socket available.\n */\n\n\nPool.prototype.socketCount = function () {\n  return this.availableConnections.length + this.inUseConnections.length; // + this.connectingConnections.length;\n};\n\nfunction totalConnectionCount(pool) {\n  return pool.availableConnections.length + pool.inUseConnections.length + pool.connectingConnections;\n}\n/**\n * Return all pool connections\n * @method\n * @return {Connection[]} The pool connections\n */\n\n\nPool.prototype.allConnections = function () {\n  return this.availableConnections.concat(this.inUseConnections);\n};\n/**\n * Get a pool connection (round-robin)\n * @method\n * @return {Connection}\n */\n\n\nPool.prototype.get = function () {\n  return this.allConnections()[0];\n};\n/**\n * Is the pool connected\n * @method\n * @return {boolean}\n */\n\n\nPool.prototype.isConnected = function () {\n  // We are in a destroyed state\n  if (this.state === DESTROYED || this.state === DESTROYING) {\n    return false;\n  } // Get connections\n\n\n  var connections = this.availableConnections.concat(this.inUseConnections); // Check if we have any connected connections\n\n  for (var i = 0; i < connections.length; i++) {\n    if (connections[i].isConnected()) return true;\n  } // Not connected\n\n\n  return false;\n};\n/**\n * Was the pool destroyed\n * @method\n * @return {boolean}\n */\n\n\nPool.prototype.isDestroyed = function () {\n  return this.state === DESTROYED || this.state === DESTROYING;\n};\n/**\n * Is the pool in a disconnected state\n * @method\n * @return {boolean}\n */\n\n\nPool.prototype.isDisconnected = function () {\n  return this.state === DISCONNECTED;\n};\n/**\n * Connect pool\n */\n\n\nPool.prototype.connect = function (callback) {\n  if (this.state !== DISCONNECTED) {\n    throw new MongoError('connection in unlawful state ' + this.state);\n  }\n\n  stateTransition(this, CONNECTING);\n  createConnection(this, (err, conn) => {\n    if (err) {\n      if (typeof callback === 'function') {\n        this.destroy();\n        callback(err);\n        return;\n      }\n\n      if (this.state === CONNECTING) {\n        this.emit('error', err);\n      }\n\n      this.destroy();\n      return;\n    }\n\n    stateTransition(this, CONNECTED); // create min connections\n\n    if (this.minSize) {\n      for (let i = 0; i < this.minSize; i++) {\n        createConnection(this);\n      }\n    }\n\n    if (typeof callback === 'function') {\n      callback(null, conn);\n    } else {\n      this.emit('connect', this, conn);\n    }\n  });\n};\n/**\n * Authenticate using a specified mechanism\n * @param {authResultCallback} callback A callback function\n */\n\n\nPool.prototype.auth = function (credentials, callback) {\n  if (typeof callback === 'function') callback(null, null);\n};\n/**\n * Logout all users against a database\n * @param {authResultCallback} callback A callback function\n */\n\n\nPool.prototype.logout = function (dbName, callback) {\n  if (typeof callback === 'function') callback(null, null);\n};\n/**\n * Unref the pool\n * @method\n */\n\n\nPool.prototype.unref = function () {\n  // Get all the known connections\n  var connections = this.availableConnections.concat(this.inUseConnections);\n  connections.forEach(function (c) {\n    c.unref();\n  });\n}; // Destroy the connections\n\n\nfunction destroy(self, connections, options, callback) {\n  stateTransition(self, DESTROYING); // indicate that in-flight connections should cancel\n\n  self.s.cancellationToken.emit('cancel');\n  eachAsync(connections, (conn, cb) => {\n    for (const eventName of CONNECTION_EVENTS) {\n      conn.removeAllListeners(eventName);\n    } // ignore any errors during destruction\n\n\n    conn.on('error', () => {});\n    conn.destroy(options, cb);\n  }, err => {\n    if (err) {\n      if (typeof callback === 'function') callback(err, null);\n      return;\n    }\n\n    resetPoolState(self);\n    self.queue = [];\n    stateTransition(self, DESTROYED);\n    if (typeof callback === 'function') callback(null, null);\n  });\n}\n/**\n * Destroy pool\n * @method\n */\n\n\nPool.prototype.destroy = function (force, callback) {\n  var self = this;\n\n  if (typeof force === 'function') {\n    callback = force;\n    force = false;\n  } // Do not try again if the pool is already dead\n\n\n  if (this.state === DESTROYED || self.state === DESTROYING) {\n    if (typeof callback === 'function') callback(null, null);\n    return;\n  } // Set state to draining\n\n\n  stateTransition(this, DRAINING); // Are we force closing\n\n  if (force) {\n    // Get all the known connections\n    var connections = self.availableConnections.concat(self.inUseConnections); // Flush any remaining work items with\n    // an error\n\n    while (self.queue.length > 0) {\n      var workItem = self.queue.shift();\n\n      if (typeof workItem.cb === 'function') {\n        workItem.cb(new MongoError('Pool was force destroyed'));\n      }\n    } // Destroy the topology\n\n\n    return destroy(self, connections, {\n      force: true\n    }, callback);\n  } // Clear out the reconnect if set\n\n\n  if (this.reconnectId) {\n    clearTimeout(this.reconnectId);\n  } // Wait for the operations to drain before we close the pool\n\n\n  function checkStatus() {\n    if (self.state === DESTROYED || self.state === DESTROYING) {\n      if (typeof callback === 'function') {\n        callback();\n      }\n\n      return;\n    }\n\n    flushMonitoringOperations(self.queue);\n\n    if (self.queue.length === 0) {\n      // Get all the known connections\n      var connections = self.availableConnections.concat(self.inUseConnections); // Check if we have any in flight operations\n\n      for (var i = 0; i < connections.length; i++) {\n        // There is an operation still in flight, reschedule a\n        // check waiting for it to drain\n        if (connections[i].workItems.length > 0) {\n          return setTimeout(checkStatus, 1);\n        }\n      }\n\n      destroy(self, connections, {\n        force: false\n      }, callback);\n    } else {\n      // Ensure we empty the queue\n      _execute(self)(); // Set timeout\n\n\n      setTimeout(checkStatus, 1);\n    }\n  } // Initiate drain of operations\n\n\n  checkStatus();\n};\n/**\n * Reset all connections of this pool\n *\n * @param {function} [callback]\n */\n\n\nPool.prototype.reset = function (callback) {\n  if (this.s.state !== CONNECTED) {\n    if (typeof callback === 'function') {\n      callback(new MongoError('pool is not connected, reset aborted'));\n    }\n\n    return;\n  } // signal in-flight connections should be cancelled\n\n\n  this.s.cancellationToken.emit('cancel'); // destroy existing connections\n\n  const connections = this.availableConnections.concat(this.inUseConnections);\n  eachAsync(connections, (conn, cb) => {\n    for (const eventName of CONNECTION_EVENTS) {\n      conn.removeAllListeners(eventName);\n    }\n\n    conn.destroy({\n      force: true\n    }, cb);\n  }, err => {\n    if (err) {\n      if (typeof callback === 'function') {\n        callback(err, null);\n        return;\n      }\n    }\n\n    resetPoolState(this); // create a new connection, this will ultimately trigger execution\n\n    createConnection(this, () => {\n      if (typeof callback === 'function') {\n        callback(null, null);\n      }\n    });\n  });\n}; // Prepare the buffer that Pool.prototype.write() uses to send to the server\n\n\nfunction serializeCommand(self, command, callback) {\n  const originalCommandBuffer = command.toBin(); // Check whether we and the server have agreed to use a compressor\n\n  const shouldCompress = !!self.options.agreedCompressor;\n\n  if (!shouldCompress || !canCompress(command)) {\n    return callback(null, originalCommandBuffer);\n  } // Transform originalCommandBuffer into OP_COMPRESSED\n\n\n  const concatenatedOriginalCommandBuffer = Buffer.concat(originalCommandBuffer);\n  const messageToBeCompressed = concatenatedOriginalCommandBuffer.slice(MESSAGE_HEADER_SIZE); // Extract information needed for OP_COMPRESSED from the uncompressed message\n\n  const originalCommandOpCode = concatenatedOriginalCommandBuffer.readInt32LE(12); // Compress the message body\n\n  compress(self, messageToBeCompressed, function (err, compressedMessage) {\n    if (err) return callback(err, null); // Create the msgHeader of OP_COMPRESSED\n\n    const msgHeader = Buffer.alloc(MESSAGE_HEADER_SIZE);\n    msgHeader.writeInt32LE(MESSAGE_HEADER_SIZE + COMPRESSION_DETAILS_SIZE + compressedMessage.length, 0); // messageLength\n\n    msgHeader.writeInt32LE(command.requestId, 4); // requestID\n\n    msgHeader.writeInt32LE(0, 8); // responseTo (zero)\n\n    msgHeader.writeInt32LE(opcodes.OP_COMPRESSED, 12); // opCode\n    // Create the compression details of OP_COMPRESSED\n\n    const compressionDetails = Buffer.alloc(COMPRESSION_DETAILS_SIZE);\n    compressionDetails.writeInt32LE(originalCommandOpCode, 0); // originalOpcode\n\n    compressionDetails.writeInt32LE(messageToBeCompressed.length, 4); // Size of the uncompressed compressedMessage, excluding the MsgHeader\n\n    compressionDetails.writeUInt8(compressorIDs[self.options.agreedCompressor], 8); // compressorID\n\n    return callback(null, [msgHeader, compressionDetails, compressedMessage]);\n  });\n}\n/**\n * Write a message to MongoDB\n * @method\n * @return {Connection}\n */\n\n\nPool.prototype.write = function (command, options, cb) {\n  var self = this; // Ensure we have a callback\n\n  if (typeof options === 'function') {\n    cb = options;\n  } // Always have options\n\n\n  options = options || {}; // We need to have a callback function unless the message returns no response\n\n  if (!(typeof cb === 'function') && !options.noResponse) {\n    throw new MongoError('write method must provide a callback');\n  } // Pool was destroyed error out\n\n\n  if (this.state === DESTROYED || this.state === DESTROYING) {\n    cb(new MongoError('pool destroyed'));\n    return;\n  }\n\n  if (this.state === DRAINING) {\n    cb(new MongoError('pool is draining, new operations prohibited'));\n    return;\n  }\n\n  if (this.options.domainsEnabled && process.domain && typeof cb === 'function') {\n    // if we have a domain bind to it\n    var oldCb = cb;\n    cb = process.domain.bind(function () {\n      // v8 - argumentsToArray one-liner\n      var args = new Array(arguments.length);\n\n      for (var i = 0; i < arguments.length; i++) {\n        args[i] = arguments[i];\n      } // bounce off event loop so domain switch takes place\n\n\n      process.nextTick(function () {\n        oldCb.apply(null, args);\n      });\n    });\n  } // Do we have an operation\n\n\n  var operation = {\n    cb: cb,\n    raw: false,\n    promoteLongs: true,\n    promoteValues: true,\n    promoteBuffers: false,\n    fullResult: false\n  }; // Set the options for the parsing\n\n  operation.promoteLongs = typeof options.promoteLongs === 'boolean' ? options.promoteLongs : true;\n  operation.promoteValues = typeof options.promoteValues === 'boolean' ? options.promoteValues : true;\n  operation.promoteBuffers = typeof options.promoteBuffers === 'boolean' ? options.promoteBuffers : false;\n  operation.raw = typeof options.raw === 'boolean' ? options.raw : false;\n  operation.immediateRelease = typeof options.immediateRelease === 'boolean' ? options.immediateRelease : false;\n  operation.documentsReturnedIn = options.documentsReturnedIn;\n  operation.command = typeof options.command === 'boolean' ? options.command : false;\n  operation.fullResult = typeof options.fullResult === 'boolean' ? options.fullResult : false;\n  operation.noResponse = typeof options.noResponse === 'boolean' ? options.noResponse : false;\n  operation.session = options.session || null; // Optional per operation socketTimeout\n\n  operation.socketTimeout = options.socketTimeout;\n  operation.monitoring = options.monitoring; // Get the requestId\n\n  operation.requestId = command.requestId; // If command monitoring is enabled we need to modify the callback here\n\n  if (self.options.monitorCommands) {\n    this.emit('commandStarted', new apm.CommandStartedEvent(this, command));\n    operation.started = now();\n\n    operation.cb = (err, reply) => {\n      if (err) {\n        self.emit('commandFailed', new apm.CommandFailedEvent(this, command, err, operation.started));\n      } else {\n        if (reply && reply.result && (reply.result.ok === 0 || reply.result.$err)) {\n          self.emit('commandFailed', new apm.CommandFailedEvent(this, command, reply.result, operation.started));\n        } else {\n          self.emit('commandSucceeded', new apm.CommandSucceededEvent(this, command, reply, operation.started));\n        }\n      }\n\n      if (typeof cb === 'function') cb(err, reply);\n    };\n  } // Prepare the operation buffer\n\n\n  serializeCommand(self, command, (err, serializedBuffers) => {\n    if (err) throw err; // Set the operation's buffer to the serialization of the commands\n\n    operation.buffer = serializedBuffers; // If we have a monitoring operation schedule as the very first operation\n    // Otherwise add to back of queue\n\n    if (options.monitoring) {\n      self.queue.unshift(operation);\n    } else {\n      self.queue.push(operation);\n    } // Attempt to execute the operation\n\n\n    if (!self.executing) {\n      process.nextTick(function () {\n        _execute(self)();\n      });\n    }\n  });\n}; // Return whether a command contains an uncompressible command term\n// Will return true if command contains no uncompressible command terms\n\n\nfunction canCompress(command) {\n  const commandDoc = command instanceof Msg ? command.command : command.query;\n  const commandName = Object.keys(commandDoc)[0];\n  return !uncompressibleCommands.has(commandName);\n} // Remove connection method\n\n\nfunction remove(connection, connections) {\n  for (var i = 0; i < connections.length; i++) {\n    if (connections[i] === connection) {\n      connections.splice(i, 1);\n      return true;\n    }\n  }\n}\n\nfunction removeConnection(self, connection) {\n  if (remove(connection, self.availableConnections)) return;\n  if (remove(connection, self.inUseConnections)) return;\n}\n\nfunction createConnection(pool, callback) {\n  if (pool.state === DESTROYED || pool.state === DESTROYING) {\n    if (typeof callback === 'function') {\n      callback(new MongoError('Cannot create connection when pool is destroyed'));\n    }\n\n    return;\n  }\n\n  pool.connectingConnections++;\n  connect(pool.options, pool.s.cancellationToken, (err, connection) => {\n    pool.connectingConnections--;\n\n    if (err) {\n      if (pool.logger.isDebug()) {\n        pool.logger.debug(`connection attempt failed with error [${JSON.stringify(err)}]`);\n      } // check if reconnect is enabled, and attempt retry if so\n\n\n      if (!pool.reconnectId && pool.options.reconnect) {\n        if (pool.state === CONNECTING && pool.options.legacyCompatMode) {\n          callback(err);\n          return;\n        }\n\n        pool.reconnectError = err;\n        pool.reconnectId = setTimeout(attemptReconnect(pool, callback), pool.options.reconnectInterval);\n        return;\n      }\n\n      if (typeof callback === 'function') {\n        callback(err);\n      }\n\n      return;\n    } // the pool might have been closed since we started creating the connection\n\n\n    if (pool.state === DESTROYED || pool.state === DESTROYING) {\n      if (typeof callback === 'function') {\n        callback(new MongoError('Pool was destroyed after connection creation'));\n      }\n\n      connection.destroy();\n      return;\n    } // otherwise, connect relevant event handlers and add it to our available connections\n\n\n    connection.on('error', pool._connectionErrorHandler);\n    connection.on('close', pool._connectionCloseHandler);\n    connection.on('timeout', pool._connectionTimeoutHandler);\n    connection.on('parseError', pool._connectionParseErrorHandler);\n    connection.on('message', pool._messageHandler);\n    pool.availableConnections.push(connection); // if a callback was provided, return the connection\n\n    if (typeof callback === 'function') {\n      callback(null, connection);\n    } // immediately execute any waiting work\n\n\n    _execute(pool)();\n  });\n}\n\nfunction flushMonitoringOperations(queue) {\n  for (var i = 0; i < queue.length; i++) {\n    if (queue[i].monitoring) {\n      var workItem = queue[i];\n      queue.splice(i, 1);\n      workItem.cb(new MongoError({\n        message: 'no connection available for monitoring',\n        driver: true\n      }));\n    }\n  }\n}\n\nfunction _execute(self) {\n  return function () {\n    if (self.state === DESTROYED) return; // Already executing, skip\n\n    if (self.executing) return; // Set pool as executing\n\n    self.executing = true; // New pool connections are in progress, wait them to finish\n    // before executing any more operation to ensure distribution of\n    // operations\n\n    if (self.connectingConnections > 0) {\n      self.executing = false;\n      return;\n    } // As long as we have available connections\n    // eslint-disable-next-line\n\n\n    while (true) {\n      // Total availble connections\n      const totalConnections = totalConnectionCount(self); // No available connections available, flush any monitoring ops\n\n      if (self.availableConnections.length === 0) {\n        // Flush any monitoring operations\n        flushMonitoringOperations(self.queue); // Try to create a new connection to execute stuck operation\n\n        if (totalConnections < self.options.size && self.queue.length > 0) {\n          createConnection(self);\n        }\n\n        break;\n      } // No queue break\n\n\n      if (self.queue.length === 0) {\n        break;\n      }\n\n      var connection = null;\n      const connections = self.availableConnections.filter(conn => conn.workItems.length === 0); // No connection found that has no work on it, just pick one for pipelining\n\n      if (connections.length === 0) {\n        connection = self.availableConnections[self.connectionIndex++ % self.availableConnections.length];\n      } else {\n        connection = connections[self.connectionIndex++ % connections.length];\n      } // Is the connection connected\n\n\n      if (!connection.isConnected()) {\n        // Remove the disconnected connection\n        removeConnection(self, connection); // Flush any monitoring operations in the queue, failing fast\n\n        flushMonitoringOperations(self.queue);\n        break;\n      } // Get the next work item\n\n\n      var workItem = self.queue.shift(); // If we are monitoring we need to use a connection that is not\n      // running another operation to avoid socket timeout changes\n      // affecting an existing operation\n\n      if (workItem.monitoring) {\n        var foundValidConnection = false;\n\n        for (let i = 0; i < self.availableConnections.length; i++) {\n          // If the connection is connected\n          // And there are no pending workItems on it\n          // Then we can safely use it for monitoring.\n          if (self.availableConnections[i].isConnected() && self.availableConnections[i].workItems.length === 0) {\n            foundValidConnection = true;\n            connection = self.availableConnections[i];\n            break;\n          }\n        } // No safe connection found, attempt to grow the connections\n        // if possible and break from the loop\n\n\n        if (!foundValidConnection) {\n          // Put workItem back on the queue\n          self.queue.unshift(workItem); // Attempt to grow the pool if it's not yet maxsize\n\n          if (totalConnections < self.options.size && self.queue.length > 0) {\n            // Create a new connection\n            createConnection(self);\n          } // Re-execute the operation\n\n\n          setTimeout(() => _execute(self)(), 10);\n          break;\n        }\n      } // Don't execute operation until we have a full pool\n\n\n      if (totalConnections < self.options.size) {\n        // Connection has work items, then put it back on the queue\n        // and create a new connection\n        if (connection.workItems.length > 0) {\n          // Lets put the workItem back on the list\n          self.queue.unshift(workItem); // Create a new connection\n\n          createConnection(self); // Break from the loop\n\n          break;\n        }\n      } // Get actual binary commands\n\n\n      var buffer = workItem.buffer; // If we are monitoring take the connection of the availableConnections\n\n      if (workItem.monitoring) {\n        moveConnectionBetween(connection, self.availableConnections, self.inUseConnections);\n      } // Track the executing commands on the mongo server\n      // as long as there is an expected response\n\n\n      if (!workItem.noResponse) {\n        connection.workItems.push(workItem);\n      } // We have a custom socketTimeout\n\n\n      if (!workItem.immediateRelease && typeof workItem.socketTimeout === 'number') {\n        connection.setSocketTimeout(workItem.socketTimeout);\n      } // Capture if write was successful\n\n\n      var writeSuccessful = true; // Put operation on the wire\n\n      if (Array.isArray(buffer)) {\n        for (let i = 0; i < buffer.length; i++) {\n          writeSuccessful = connection.write(buffer[i]);\n        }\n      } else {\n        writeSuccessful = connection.write(buffer);\n      } // if the command is designated noResponse, call the callback immeditely\n\n\n      if (workItem.noResponse && typeof workItem.cb === 'function') {\n        workItem.cb(null, null);\n      }\n\n      if (writeSuccessful === false) {\n        // If write not successful put back on queue\n        self.queue.unshift(workItem); // Remove the disconnected connection\n\n        removeConnection(self, connection); // Flush any monitoring operations in the queue, failing fast\n\n        flushMonitoringOperations(self.queue);\n        break;\n      }\n    }\n\n    self.executing = false;\n  };\n} // Make execution loop available for testing\n\n\nPool._execute = _execute;\n/**\n * A server connect event, used to verify that the connection is up and running\n *\n * @event Pool#connect\n * @type {Pool}\n */\n\n/**\n * A server reconnect event, used to verify that pool reconnected.\n *\n * @event Pool#reconnect\n * @type {Pool}\n */\n\n/**\n * The server connection closed, all pool connections closed\n *\n * @event Pool#close\n * @type {Pool}\n */\n\n/**\n * The server connection caused an error, all pool connections closed\n *\n * @event Pool#error\n * @type {Pool}\n */\n\n/**\n * The server connection timed out, all pool connections closed\n *\n * @event Pool#timeout\n * @type {Pool}\n */\n\n/**\n * The driver experienced an invalid message, all pool connections closed\n *\n * @event Pool#parseError\n * @type {Pool}\n */\n\n/**\n * The driver attempted to reconnect\n *\n * @event Pool#attemptReconnect\n * @type {Pool}\n */\n\n/**\n * The driver exhausted all reconnect attempts\n *\n * @event Pool#reconnectFailed\n * @type {Pool}\n */\n\nmodule.exports = Pool;","map":{"version":3,"names":["inherits","require","EventEmitter","MongoError","MongoTimeoutError","MongoWriteConcernError","Logger","f","format","Msg","CommandResult","MESSAGE_HEADER_SIZE","COMPRESSION_DETAILS_SIZE","opcodes","compress","compressorIDs","uncompressibleCommands","apm","Buffer","connect","updateSessionFromResponse","eachAsync","makeStateMachine","now","DISCONNECTED","CONNECTING","CONNECTED","DRAINING","DESTROYING","DESTROYED","stateTransition","CONNECTION_EVENTS","Set","_id","Pool","topology","options","call","s","state","cancellationToken","setMaxListeners","Infinity","Object","assign","host","port","size","minSize","connectionTimeout","socketTimeout","keepAlive","keepAliveInitialDelay","noDelay","ssl","checkServerIdentity","ca","crl","cert","key","passphrase","rejectUnauthorized","promoteLongs","promoteValues","promoteBuffers","reconnect","reconnectInterval","reconnectTries","domainsEnabled","legacyCompatMode","id","retriesLeft","reconnectId","reconnectError","bson","serialize","deserialize","Error","logger","availableConnections","inUseConnections","connectingConnections","executing","queue","numberOfConsecutiveTimeouts","connectionIndex","pool","_messageHandler","messageHandler","_connectionCloseHandler","err","connection","connectionFailureHandler","_connectionErrorHandler","_connectionTimeoutHandler","_connectionParseErrorHandler","defineProperty","prototype","enumerable","get","resetPoolState","event","conn","_connectionFailHandled","destroy","removeConnection","flush","emit","socketCount","setTimeout","attemptReconnect","totalConnections","totalConnectionCount","createConnection","callback","error","moveConnectionBetween","from","to","index","indexOf","splice","push","self","message","workItem","i","workItems","length","requestId","responseTo","monitoring","resetSocketTimeout","isDebug","debug","raw","toString","handleOperationCallback","cb","result","process","nextTick","_execute","immediateRelease","parse","documents","document","session","$clusterTime","clusterTime","command","responseDoc","writeConcernError","ok","$err","errmsg","code","hashedName","fullResult","allConnections","concat","isConnected","connections","isDestroyed","isDisconnected","auth","credentials","logout","dbName","unref","forEach","c","eventName","removeAllListeners","on","force","shift","clearTimeout","checkStatus","flushMonitoringOperations","reset","serializeCommand","originalCommandBuffer","toBin","shouldCompress","agreedCompressor","canCompress","concatenatedOriginalCommandBuffer","messageToBeCompressed","slice","originalCommandOpCode","readInt32LE","compressedMessage","msgHeader","alloc","writeInt32LE","OP_COMPRESSED","compressionDetails","writeUInt8","write","noResponse","domain","oldCb","bind","args","Array","arguments","apply","operation","documentsReturnedIn","monitorCommands","CommandStartedEvent","started","reply","CommandFailedEvent","CommandSucceededEvent","serializedBuffers","buffer","unshift","commandDoc","query","commandName","keys","has","remove","JSON","stringify","driver","filter","foundValidConnection","setSocketTimeout","writeSuccessful","isArray","module","exports"],"sources":["C:/Users/Administrator/Desktop/webAPI work/web/dog-website/node_modules/koa-mongo/node_modules/mongodb/lib/core/connection/pool.js"],"sourcesContent":["'use strict';\n\nconst inherits = require('util').inherits;\nconst EventEmitter = require('events').EventEmitter;\nconst MongoError = require('../error').MongoError;\nconst MongoTimeoutError = require('../error').MongoTimeoutError;\nconst MongoWriteConcernError = require('../error').MongoWriteConcernError;\nconst Logger = require('./logger');\nconst f = require('util').format;\nconst Msg = require('./msg').Msg;\nconst CommandResult = require('./command_result');\nconst MESSAGE_HEADER_SIZE = require('../wireprotocol/shared').MESSAGE_HEADER_SIZE;\nconst COMPRESSION_DETAILS_SIZE = require('../wireprotocol/shared').COMPRESSION_DETAILS_SIZE;\nconst opcodes = require('../wireprotocol/shared').opcodes;\nconst compress = require('../wireprotocol/compression').compress;\nconst compressorIDs = require('../wireprotocol/compression').compressorIDs;\nconst uncompressibleCommands = require('../wireprotocol/compression').uncompressibleCommands;\nconst apm = require('./apm');\nconst Buffer = require('safe-buffer').Buffer;\nconst connect = require('./connect');\nconst updateSessionFromResponse = require('../sessions').updateSessionFromResponse;\nconst eachAsync = require('../utils').eachAsync;\nconst makeStateMachine = require('../utils').makeStateMachine;\nconst now = require('../../utils').now;\n\nconst DISCONNECTED = 'disconnected';\nconst CONNECTING = 'connecting';\nconst CONNECTED = 'connected';\nconst DRAINING = 'draining';\nconst DESTROYING = 'destroying';\nconst DESTROYED = 'destroyed';\nconst stateTransition = makeStateMachine({\n  [DISCONNECTED]: [CONNECTING, DRAINING, DISCONNECTED],\n  [CONNECTING]: [CONNECTING, CONNECTED, DRAINING, DISCONNECTED],\n  [CONNECTED]: [CONNECTED, DISCONNECTED, DRAINING],\n  [DRAINING]: [DRAINING, DESTROYING, DESTROYED],\n  [DESTROYING]: [DESTROYING, DESTROYED],\n  [DESTROYED]: [DESTROYED]\n});\n\nconst CONNECTION_EVENTS = new Set([\n  'error',\n  'close',\n  'timeout',\n  'parseError',\n  'connect',\n  'message'\n]);\n\nvar _id = 0;\n\n/**\n * Creates a new Pool instance\n * @class\n * @param {string} options.host The server host\n * @param {number} options.port The server port\n * @param {number} [options.size=5] Max server connection pool size\n * @param {number} [options.minSize=0] Minimum server connection pool size\n * @param {boolean} [options.reconnect=true] Server will attempt to reconnect on loss of connection\n * @param {number} [options.reconnectTries=30] Server attempt to reconnect #times\n * @param {number} [options.reconnectInterval=1000] Server will wait # milliseconds between retries\n * @param {boolean} [options.keepAlive=true] TCP Connection keep alive enabled\n * @param {number} [options.keepAliveInitialDelay=120000] Initial delay before TCP keep alive enabled\n * @param {boolean} [options.noDelay=true] TCP Connection no delay\n * @param {number} [options.connectionTimeout=30000] TCP Connection timeout setting\n * @param {number} [options.socketTimeout=0] TCP Socket timeout setting\n * @param {number} [options.monitoringSocketTimeout=0] TCP Socket timeout setting for replicaset monitoring socket\n * @param {boolean} [options.ssl=false] Use SSL for connection\n * @param {boolean|function} [options.checkServerIdentity=true] Ensure we check server identify during SSL, set to false to disable checking. Only works for Node 0.12.x or higher. You can pass in a boolean or your own checkServerIdentity override function.\n * @param {Buffer} [options.ca] SSL Certificate store binary buffer\n * @param {Buffer} [options.crl] SSL Certificate revocation store binary buffer\n * @param {Buffer} [options.cert] SSL Certificate binary buffer\n * @param {Buffer} [options.key] SSL Key file binary buffer\n * @param {string} [options.passphrase] SSL Certificate pass phrase\n * @param {boolean} [options.rejectUnauthorized=false] Reject unauthorized server certificates\n * @param {boolean} [options.promoteLongs=true] Convert Long values from the db into Numbers if they fit into 53 bits\n * @param {boolean} [options.promoteValues=true] Promotes BSON values to native types where possible, set to false to only receive wrapper types.\n * @param {boolean} [options.promoteBuffers=false] Promotes Binary BSON values to native Node Buffers.\n * @param {boolean} [options.domainsEnabled=false] Enable the wrapping of the callback in the current domain, disabled by default to avoid perf hit.\n * @fires Pool#connect\n * @fires Pool#close\n * @fires Pool#error\n * @fires Pool#timeout\n * @fires Pool#parseError\n * @return {Pool} A cursor instance\n */\nvar Pool = function(topology, options) {\n  // Add event listener\n  EventEmitter.call(this);\n\n  // Store topology for later use\n  this.topology = topology;\n\n  this.s = {\n    state: DISCONNECTED,\n    cancellationToken: new EventEmitter()\n  };\n\n  // we don't care how many connections are listening for cancellation\n  this.s.cancellationToken.setMaxListeners(Infinity);\n\n  // Add the options\n  this.options = Object.assign(\n    {\n      // Host and port settings\n      host: 'localhost',\n      port: 27017,\n      // Pool default max size\n      size: 5,\n      // Pool default min size\n      minSize: 0,\n      // socket settings\n      connectionTimeout: 30000,\n      socketTimeout: 0,\n      keepAlive: true,\n      keepAliveInitialDelay: 120000,\n      noDelay: true,\n      // SSL Settings\n      ssl: false,\n      checkServerIdentity: true,\n      ca: null,\n      crl: null,\n      cert: null,\n      key: null,\n      passphrase: null,\n      rejectUnauthorized: false,\n      promoteLongs: true,\n      promoteValues: true,\n      promoteBuffers: false,\n      // Reconnection options\n      reconnect: true,\n      reconnectInterval: 1000,\n      reconnectTries: 30,\n      // Enable domains\n      domainsEnabled: false,\n      // feature flag for determining if we are running with the unified topology or not\n      legacyCompatMode: true\n    },\n    options\n  );\n\n  // Identification information\n  this.id = _id++;\n  // Current reconnect retries\n  this.retriesLeft = this.options.reconnectTries;\n  this.reconnectId = null;\n  this.reconnectError = null;\n  // No bson parser passed in\n  if (\n    !options.bson ||\n    (options.bson &&\n      (typeof options.bson.serialize !== 'function' ||\n        typeof options.bson.deserialize !== 'function'))\n  ) {\n    throw new Error('must pass in valid bson parser');\n  }\n\n  // Logger instance\n  this.logger = Logger('Pool', options);\n  // Connections\n  this.availableConnections = [];\n  this.inUseConnections = [];\n  this.connectingConnections = 0;\n  // Currently executing\n  this.executing = false;\n  // Operation work queue\n  this.queue = [];\n\n  // Number of consecutive timeouts caught\n  this.numberOfConsecutiveTimeouts = 0;\n  // Current pool Index\n  this.connectionIndex = 0;\n\n  // event handlers\n  const pool = this;\n  this._messageHandler = messageHandler(this);\n  this._connectionCloseHandler = function(err) {\n    const connection = this;\n    connectionFailureHandler(pool, 'close', err, connection);\n  };\n\n  this._connectionErrorHandler = function(err) {\n    const connection = this;\n    connectionFailureHandler(pool, 'error', err, connection);\n  };\n\n  this._connectionTimeoutHandler = function(err) {\n    const connection = this;\n    connectionFailureHandler(pool, 'timeout', err, connection);\n  };\n\n  this._connectionParseErrorHandler = function(err) {\n    const connection = this;\n    connectionFailureHandler(pool, 'parseError', err, connection);\n  };\n};\n\ninherits(Pool, EventEmitter);\n\nObject.defineProperty(Pool.prototype, 'size', {\n  enumerable: true,\n  get: function() {\n    return this.options.size;\n  }\n});\n\nObject.defineProperty(Pool.prototype, 'minSize', {\n  enumerable: true,\n  get: function() {\n    return this.options.minSize;\n  }\n});\n\nObject.defineProperty(Pool.prototype, 'connectionTimeout', {\n  enumerable: true,\n  get: function() {\n    return this.options.connectionTimeout;\n  }\n});\n\nObject.defineProperty(Pool.prototype, 'socketTimeout', {\n  enumerable: true,\n  get: function() {\n    return this.options.socketTimeout;\n  }\n});\n\nObject.defineProperty(Pool.prototype, 'state', {\n  enumerable: true,\n  get: function() {\n    return this.s.state;\n  }\n});\n\n// clears all pool state\nfunction resetPoolState(pool) {\n  pool.inUseConnections = [];\n  pool.availableConnections = [];\n  pool.connectingConnections = 0;\n  pool.executing = false;\n  pool.numberOfConsecutiveTimeouts = 0;\n  pool.connectionIndex = 0;\n  pool.retriesLeft = pool.options.reconnectTries;\n  pool.reconnectId = null;\n}\n\nfunction connectionFailureHandler(pool, event, err, conn) {\n  if (conn) {\n    if (conn._connectionFailHandled) {\n      return;\n    }\n\n    conn._connectionFailHandled = true;\n    conn.destroy();\n\n    // Remove the connection\n    removeConnection(pool, conn);\n\n    // flush remaining work items\n    conn.flush(err);\n  }\n\n  // Did we catch a timeout, increment the numberOfConsecutiveTimeouts\n  if (event === 'timeout') {\n    pool.numberOfConsecutiveTimeouts = pool.numberOfConsecutiveTimeouts + 1;\n\n    // Have we timed out more than reconnectTries in a row ?\n    // Force close the pool as we are trying to connect to tcp sink hole\n    if (pool.numberOfConsecutiveTimeouts > pool.options.reconnectTries) {\n      pool.numberOfConsecutiveTimeouts = 0;\n      // Destroy all connections and pool\n      pool.destroy(true);\n      // Emit close event\n      return pool.emit('close', pool);\n    }\n  }\n\n  // No more socket available propegate the event\n  if (pool.socketCount() === 0) {\n    if (pool.state !== DESTROYED && pool.state !== DESTROYING && pool.state !== DRAINING) {\n      if (pool.options.reconnect) {\n        stateTransition(pool, DISCONNECTED);\n      }\n    }\n\n    // Do not emit error events, they are always close events\n    // do not trigger the low level error handler in node\n    event = event === 'error' ? 'close' : event;\n    pool.emit(event, err);\n  }\n\n  // Start reconnection attempts\n  if (!pool.reconnectId && pool.options.reconnect) {\n    pool.reconnectError = err;\n    pool.reconnectId = setTimeout(attemptReconnect(pool), pool.options.reconnectInterval);\n  }\n\n  // Do we need to do anything to maintain the minimum pool size\n  const totalConnections = totalConnectionCount(pool);\n  if (totalConnections < pool.minSize) {\n    createConnection(pool);\n  }\n}\n\nfunction attemptReconnect(pool, callback) {\n  return function() {\n    pool.emit('attemptReconnect', pool);\n\n    if (pool.state === DESTROYED || pool.state === DESTROYING) {\n      if (typeof callback === 'function') {\n        callback(new MongoError('Cannot create connection when pool is destroyed'));\n      }\n\n      return;\n    }\n\n    pool.retriesLeft = pool.retriesLeft - 1;\n    if (pool.retriesLeft <= 0) {\n      pool.destroy();\n\n      const error = new MongoTimeoutError(\n        `failed to reconnect after ${pool.options.reconnectTries} attempts with interval ${pool.options.reconnectInterval} ms`,\n        pool.reconnectError\n      );\n\n      pool.emit('reconnectFailed', error);\n      if (typeof callback === 'function') {\n        callback(error);\n      }\n\n      return;\n    }\n\n    // clear the reconnect id on retry\n    pool.reconnectId = null;\n\n    // now retry creating a connection\n    createConnection(pool, (err, conn) => {\n      if (err == null) {\n        pool.reconnectId = null;\n        pool.retriesLeft = pool.options.reconnectTries;\n        pool.emit('reconnect', pool);\n      }\n\n      if (typeof callback === 'function') {\n        callback(err, conn);\n      }\n    });\n  };\n}\n\nfunction moveConnectionBetween(connection, from, to) {\n  var index = from.indexOf(connection);\n  // Move the connection from connecting to available\n  if (index !== -1) {\n    from.splice(index, 1);\n    to.push(connection);\n  }\n}\n\nfunction messageHandler(self) {\n  return function(message, connection) {\n    // workItem to execute\n    var workItem = null;\n\n    // Locate the workItem\n    for (var i = 0; i < connection.workItems.length; i++) {\n      if (connection.workItems[i].requestId === message.responseTo) {\n        // Get the callback\n        workItem = connection.workItems[i];\n        // Remove from list of workItems\n        connection.workItems.splice(i, 1);\n      }\n    }\n\n    if (workItem && workItem.monitoring) {\n      moveConnectionBetween(connection, self.inUseConnections, self.availableConnections);\n    }\n\n    // Reset timeout counter\n    self.numberOfConsecutiveTimeouts = 0;\n\n    // Reset the connection timeout if we modified it for\n    // this operation\n    if (workItem && workItem.socketTimeout) {\n      connection.resetSocketTimeout();\n    }\n\n    // Log if debug enabled\n    if (self.logger.isDebug()) {\n      self.logger.debug(\n        f(\n          'message [%s] received from %s:%s',\n          message.raw.toString('hex'),\n          self.options.host,\n          self.options.port\n        )\n      );\n    }\n\n    function handleOperationCallback(self, cb, err, result) {\n      // No domain enabled\n      if (!self.options.domainsEnabled) {\n        return process.nextTick(function() {\n          return cb(err, result);\n        });\n      }\n\n      // Domain enabled just call the callback\n      cb(err, result);\n    }\n\n    // Keep executing, ensure current message handler does not stop execution\n    if (!self.executing) {\n      process.nextTick(function() {\n        _execute(self)();\n      });\n    }\n\n    // Time to dispatch the message if we have a callback\n    if (workItem && !workItem.immediateRelease) {\n      try {\n        // Parse the message according to the provided options\n        message.parse(workItem);\n      } catch (err) {\n        return handleOperationCallback(self, workItem.cb, new MongoError(err));\n      }\n\n      if (message.documents[0]) {\n        const document = message.documents[0];\n        const session = workItem.session;\n        if (session) {\n          updateSessionFromResponse(session, document);\n        }\n\n        if (self.topology && document.$clusterTime) {\n          self.topology.clusterTime = document.$clusterTime;\n        }\n      }\n\n      // Establish if we have an error\n      if (workItem.command && message.documents[0]) {\n        const responseDoc = message.documents[0];\n\n        if (responseDoc.writeConcernError) {\n          const err = new MongoWriteConcernError(responseDoc.writeConcernError, responseDoc);\n          return handleOperationCallback(self, workItem.cb, err);\n        }\n\n        if (responseDoc.ok === 0 || responseDoc.$err || responseDoc.errmsg || responseDoc.code) {\n          return handleOperationCallback(self, workItem.cb, new MongoError(responseDoc));\n        }\n      }\n\n      // Add the connection details\n      message.hashedName = connection.hashedName;\n\n      // Return the documents\n      handleOperationCallback(\n        self,\n        workItem.cb,\n        null,\n        new CommandResult(workItem.fullResult ? message : message.documents[0], connection, message)\n      );\n    }\n  };\n}\n\n/**\n * Return the total socket count in the pool.\n * @method\n * @return {Number} The number of socket available.\n */\nPool.prototype.socketCount = function() {\n  return this.availableConnections.length + this.inUseConnections.length;\n  // + this.connectingConnections.length;\n};\n\nfunction totalConnectionCount(pool) {\n  return (\n    pool.availableConnections.length + pool.inUseConnections.length + pool.connectingConnections\n  );\n}\n\n/**\n * Return all pool connections\n * @method\n * @return {Connection[]} The pool connections\n */\nPool.prototype.allConnections = function() {\n  return this.availableConnections.concat(this.inUseConnections);\n};\n\n/**\n * Get a pool connection (round-robin)\n * @method\n * @return {Connection}\n */\nPool.prototype.get = function() {\n  return this.allConnections()[0];\n};\n\n/**\n * Is the pool connected\n * @method\n * @return {boolean}\n */\nPool.prototype.isConnected = function() {\n  // We are in a destroyed state\n  if (this.state === DESTROYED || this.state === DESTROYING) {\n    return false;\n  }\n\n  // Get connections\n  var connections = this.availableConnections.concat(this.inUseConnections);\n\n  // Check if we have any connected connections\n  for (var i = 0; i < connections.length; i++) {\n    if (connections[i].isConnected()) return true;\n  }\n\n  // Not connected\n  return false;\n};\n\n/**\n * Was the pool destroyed\n * @method\n * @return {boolean}\n */\nPool.prototype.isDestroyed = function() {\n  return this.state === DESTROYED || this.state === DESTROYING;\n};\n\n/**\n * Is the pool in a disconnected state\n * @method\n * @return {boolean}\n */\nPool.prototype.isDisconnected = function() {\n  return this.state === DISCONNECTED;\n};\n\n/**\n * Connect pool\n */\nPool.prototype.connect = function(callback) {\n  if (this.state !== DISCONNECTED) {\n    throw new MongoError('connection in unlawful state ' + this.state);\n  }\n\n  stateTransition(this, CONNECTING);\n  createConnection(this, (err, conn) => {\n    if (err) {\n      if (typeof callback === 'function') {\n        this.destroy();\n        callback(err);\n        return;\n      }\n\n      if (this.state === CONNECTING) {\n        this.emit('error', err);\n      }\n\n      this.destroy();\n      return;\n    }\n\n    stateTransition(this, CONNECTED);\n\n    // create min connections\n    if (this.minSize) {\n      for (let i = 0; i < this.minSize; i++) {\n        createConnection(this);\n      }\n    }\n\n    if (typeof callback === 'function') {\n      callback(null, conn);\n    } else {\n      this.emit('connect', this, conn);\n    }\n  });\n};\n\n/**\n * Authenticate using a specified mechanism\n * @param {authResultCallback} callback A callback function\n */\nPool.prototype.auth = function(credentials, callback) {\n  if (typeof callback === 'function') callback(null, null);\n};\n\n/**\n * Logout all users against a database\n * @param {authResultCallback} callback A callback function\n */\nPool.prototype.logout = function(dbName, callback) {\n  if (typeof callback === 'function') callback(null, null);\n};\n\n/**\n * Unref the pool\n * @method\n */\nPool.prototype.unref = function() {\n  // Get all the known connections\n  var connections = this.availableConnections.concat(this.inUseConnections);\n\n  connections.forEach(function(c) {\n    c.unref();\n  });\n};\n\n// Destroy the connections\nfunction destroy(self, connections, options, callback) {\n  stateTransition(self, DESTROYING);\n\n  // indicate that in-flight connections should cancel\n  self.s.cancellationToken.emit('cancel');\n\n  eachAsync(\n    connections,\n    (conn, cb) => {\n      for (const eventName of CONNECTION_EVENTS) {\n        conn.removeAllListeners(eventName);\n      }\n\n      // ignore any errors during destruction\n      conn.on('error', () => {});\n\n      conn.destroy(options, cb);\n    },\n    err => {\n      if (err) {\n        if (typeof callback === 'function') callback(err, null);\n        return;\n      }\n\n      resetPoolState(self);\n      self.queue = [];\n\n      stateTransition(self, DESTROYED);\n      if (typeof callback === 'function') callback(null, null);\n    }\n  );\n}\n\n/**\n * Destroy pool\n * @method\n */\nPool.prototype.destroy = function(force, callback) {\n  var self = this;\n  if (typeof force === 'function') {\n    callback = force;\n    force = false;\n  }\n\n  // Do not try again if the pool is already dead\n  if (this.state === DESTROYED || self.state === DESTROYING) {\n    if (typeof callback === 'function') callback(null, null);\n    return;\n  }\n\n  // Set state to draining\n  stateTransition(this, DRAINING);\n\n  // Are we force closing\n  if (force) {\n    // Get all the known connections\n    var connections = self.availableConnections.concat(self.inUseConnections);\n\n    // Flush any remaining work items with\n    // an error\n    while (self.queue.length > 0) {\n      var workItem = self.queue.shift();\n      if (typeof workItem.cb === 'function') {\n        workItem.cb(new MongoError('Pool was force destroyed'));\n      }\n    }\n\n    // Destroy the topology\n    return destroy(self, connections, { force: true }, callback);\n  }\n\n  // Clear out the reconnect if set\n  if (this.reconnectId) {\n    clearTimeout(this.reconnectId);\n  }\n\n  // Wait for the operations to drain before we close the pool\n  function checkStatus() {\n    if (self.state === DESTROYED || self.state === DESTROYING) {\n      if (typeof callback === 'function') {\n        callback();\n      }\n\n      return;\n    }\n\n    flushMonitoringOperations(self.queue);\n\n    if (self.queue.length === 0) {\n      // Get all the known connections\n      var connections = self.availableConnections.concat(self.inUseConnections);\n\n      // Check if we have any in flight operations\n      for (var i = 0; i < connections.length; i++) {\n        // There is an operation still in flight, reschedule a\n        // check waiting for it to drain\n        if (connections[i].workItems.length > 0) {\n          return setTimeout(checkStatus, 1);\n        }\n      }\n\n      destroy(self, connections, { force: false }, callback);\n    } else {\n      // Ensure we empty the queue\n      _execute(self)();\n      // Set timeout\n      setTimeout(checkStatus, 1);\n    }\n  }\n\n  // Initiate drain of operations\n  checkStatus();\n};\n\n/**\n * Reset all connections of this pool\n *\n * @param {function} [callback]\n */\nPool.prototype.reset = function(callback) {\n  if (this.s.state !== CONNECTED) {\n    if (typeof callback === 'function') {\n      callback(new MongoError('pool is not connected, reset aborted'));\n    }\n\n    return;\n  }\n\n  // signal in-flight connections should be cancelled\n  this.s.cancellationToken.emit('cancel');\n\n  // destroy existing connections\n  const connections = this.availableConnections.concat(this.inUseConnections);\n  eachAsync(\n    connections,\n    (conn, cb) => {\n      for (const eventName of CONNECTION_EVENTS) {\n        conn.removeAllListeners(eventName);\n      }\n\n      conn.destroy({ force: true }, cb);\n    },\n    err => {\n      if (err) {\n        if (typeof callback === 'function') {\n          callback(err, null);\n          return;\n        }\n      }\n\n      resetPoolState(this);\n\n      // create a new connection, this will ultimately trigger execution\n      createConnection(this, () => {\n        if (typeof callback === 'function') {\n          callback(null, null);\n        }\n      });\n    }\n  );\n};\n\n// Prepare the buffer that Pool.prototype.write() uses to send to the server\nfunction serializeCommand(self, command, callback) {\n  const originalCommandBuffer = command.toBin();\n\n  // Check whether we and the server have agreed to use a compressor\n  const shouldCompress = !!self.options.agreedCompressor;\n  if (!shouldCompress || !canCompress(command)) {\n    return callback(null, originalCommandBuffer);\n  }\n\n  // Transform originalCommandBuffer into OP_COMPRESSED\n  const concatenatedOriginalCommandBuffer = Buffer.concat(originalCommandBuffer);\n  const messageToBeCompressed = concatenatedOriginalCommandBuffer.slice(MESSAGE_HEADER_SIZE);\n\n  // Extract information needed for OP_COMPRESSED from the uncompressed message\n  const originalCommandOpCode = concatenatedOriginalCommandBuffer.readInt32LE(12);\n\n  // Compress the message body\n  compress(self, messageToBeCompressed, function(err, compressedMessage) {\n    if (err) return callback(err, null);\n\n    // Create the msgHeader of OP_COMPRESSED\n    const msgHeader = Buffer.alloc(MESSAGE_HEADER_SIZE);\n    msgHeader.writeInt32LE(\n      MESSAGE_HEADER_SIZE + COMPRESSION_DETAILS_SIZE + compressedMessage.length,\n      0\n    ); // messageLength\n    msgHeader.writeInt32LE(command.requestId, 4); // requestID\n    msgHeader.writeInt32LE(0, 8); // responseTo (zero)\n    msgHeader.writeInt32LE(opcodes.OP_COMPRESSED, 12); // opCode\n\n    // Create the compression details of OP_COMPRESSED\n    const compressionDetails = Buffer.alloc(COMPRESSION_DETAILS_SIZE);\n    compressionDetails.writeInt32LE(originalCommandOpCode, 0); // originalOpcode\n    compressionDetails.writeInt32LE(messageToBeCompressed.length, 4); // Size of the uncompressed compressedMessage, excluding the MsgHeader\n    compressionDetails.writeUInt8(compressorIDs[self.options.agreedCompressor], 8); // compressorID\n\n    return callback(null, [msgHeader, compressionDetails, compressedMessage]);\n  });\n}\n\n/**\n * Write a message to MongoDB\n * @method\n * @return {Connection}\n */\nPool.prototype.write = function(command, options, cb) {\n  var self = this;\n  // Ensure we have a callback\n  if (typeof options === 'function') {\n    cb = options;\n  }\n\n  // Always have options\n  options = options || {};\n\n  // We need to have a callback function unless the message returns no response\n  if (!(typeof cb === 'function') && !options.noResponse) {\n    throw new MongoError('write method must provide a callback');\n  }\n\n  // Pool was destroyed error out\n  if (this.state === DESTROYED || this.state === DESTROYING) {\n    cb(new MongoError('pool destroyed'));\n    return;\n  }\n\n  if (this.state === DRAINING) {\n    cb(new MongoError('pool is draining, new operations prohibited'));\n    return;\n  }\n\n  if (this.options.domainsEnabled && process.domain && typeof cb === 'function') {\n    // if we have a domain bind to it\n    var oldCb = cb;\n    cb = process.domain.bind(function() {\n      // v8 - argumentsToArray one-liner\n      var args = new Array(arguments.length);\n      for (var i = 0; i < arguments.length; i++) {\n        args[i] = arguments[i];\n      }\n      // bounce off event loop so domain switch takes place\n      process.nextTick(function() {\n        oldCb.apply(null, args);\n      });\n    });\n  }\n\n  // Do we have an operation\n  var operation = {\n    cb: cb,\n    raw: false,\n    promoteLongs: true,\n    promoteValues: true,\n    promoteBuffers: false,\n    fullResult: false\n  };\n\n  // Set the options for the parsing\n  operation.promoteLongs = typeof options.promoteLongs === 'boolean' ? options.promoteLongs : true;\n  operation.promoteValues =\n    typeof options.promoteValues === 'boolean' ? options.promoteValues : true;\n  operation.promoteBuffers =\n    typeof options.promoteBuffers === 'boolean' ? options.promoteBuffers : false;\n  operation.raw = typeof options.raw === 'boolean' ? options.raw : false;\n  operation.immediateRelease =\n    typeof options.immediateRelease === 'boolean' ? options.immediateRelease : false;\n  operation.documentsReturnedIn = options.documentsReturnedIn;\n  operation.command = typeof options.command === 'boolean' ? options.command : false;\n  operation.fullResult = typeof options.fullResult === 'boolean' ? options.fullResult : false;\n  operation.noResponse = typeof options.noResponse === 'boolean' ? options.noResponse : false;\n  operation.session = options.session || null;\n\n  // Optional per operation socketTimeout\n  operation.socketTimeout = options.socketTimeout;\n  operation.monitoring = options.monitoring;\n\n  // Get the requestId\n  operation.requestId = command.requestId;\n\n  // If command monitoring is enabled we need to modify the callback here\n  if (self.options.monitorCommands) {\n    this.emit('commandStarted', new apm.CommandStartedEvent(this, command));\n\n    operation.started = now();\n    operation.cb = (err, reply) => {\n      if (err) {\n        self.emit(\n          'commandFailed',\n          new apm.CommandFailedEvent(this, command, err, operation.started)\n        );\n      } else {\n        if (reply && reply.result && (reply.result.ok === 0 || reply.result.$err)) {\n          self.emit(\n            'commandFailed',\n            new apm.CommandFailedEvent(this, command, reply.result, operation.started)\n          );\n        } else {\n          self.emit(\n            'commandSucceeded',\n            new apm.CommandSucceededEvent(this, command, reply, operation.started)\n          );\n        }\n      }\n\n      if (typeof cb === 'function') cb(err, reply);\n    };\n  }\n\n  // Prepare the operation buffer\n  serializeCommand(self, command, (err, serializedBuffers) => {\n    if (err) throw err;\n\n    // Set the operation's buffer to the serialization of the commands\n    operation.buffer = serializedBuffers;\n\n    // If we have a monitoring operation schedule as the very first operation\n    // Otherwise add to back of queue\n    if (options.monitoring) {\n      self.queue.unshift(operation);\n    } else {\n      self.queue.push(operation);\n    }\n\n    // Attempt to execute the operation\n    if (!self.executing) {\n      process.nextTick(function() {\n        _execute(self)();\n      });\n    }\n  });\n};\n\n// Return whether a command contains an uncompressible command term\n// Will return true if command contains no uncompressible command terms\nfunction canCompress(command) {\n  const commandDoc = command instanceof Msg ? command.command : command.query;\n  const commandName = Object.keys(commandDoc)[0];\n  return !uncompressibleCommands.has(commandName);\n}\n\n// Remove connection method\nfunction remove(connection, connections) {\n  for (var i = 0; i < connections.length; i++) {\n    if (connections[i] === connection) {\n      connections.splice(i, 1);\n      return true;\n    }\n  }\n}\n\nfunction removeConnection(self, connection) {\n  if (remove(connection, self.availableConnections)) return;\n  if (remove(connection, self.inUseConnections)) return;\n}\n\nfunction createConnection(pool, callback) {\n  if (pool.state === DESTROYED || pool.state === DESTROYING) {\n    if (typeof callback === 'function') {\n      callback(new MongoError('Cannot create connection when pool is destroyed'));\n    }\n\n    return;\n  }\n\n  pool.connectingConnections++;\n  connect(pool.options, pool.s.cancellationToken, (err, connection) => {\n    pool.connectingConnections--;\n\n    if (err) {\n      if (pool.logger.isDebug()) {\n        pool.logger.debug(`connection attempt failed with error [${JSON.stringify(err)}]`);\n      }\n\n      // check if reconnect is enabled, and attempt retry if so\n      if (!pool.reconnectId && pool.options.reconnect) {\n        if (pool.state === CONNECTING && pool.options.legacyCompatMode) {\n          callback(err);\n          return;\n        }\n\n        pool.reconnectError = err;\n        pool.reconnectId = setTimeout(\n          attemptReconnect(pool, callback),\n          pool.options.reconnectInterval\n        );\n\n        return;\n      }\n\n      if (typeof callback === 'function') {\n        callback(err);\n      }\n\n      return;\n    }\n\n    // the pool might have been closed since we started creating the connection\n    if (pool.state === DESTROYED || pool.state === DESTROYING) {\n      if (typeof callback === 'function') {\n        callback(new MongoError('Pool was destroyed after connection creation'));\n      }\n\n      connection.destroy();\n      return;\n    }\n\n    // otherwise, connect relevant event handlers and add it to our available connections\n    connection.on('error', pool._connectionErrorHandler);\n    connection.on('close', pool._connectionCloseHandler);\n    connection.on('timeout', pool._connectionTimeoutHandler);\n    connection.on('parseError', pool._connectionParseErrorHandler);\n    connection.on('message', pool._messageHandler);\n\n    pool.availableConnections.push(connection);\n\n    // if a callback was provided, return the connection\n    if (typeof callback === 'function') {\n      callback(null, connection);\n    }\n\n    // immediately execute any waiting work\n    _execute(pool)();\n  });\n}\n\nfunction flushMonitoringOperations(queue) {\n  for (var i = 0; i < queue.length; i++) {\n    if (queue[i].monitoring) {\n      var workItem = queue[i];\n      queue.splice(i, 1);\n      workItem.cb(\n        new MongoError({ message: 'no connection available for monitoring', driver: true })\n      );\n    }\n  }\n}\n\nfunction _execute(self) {\n  return function() {\n    if (self.state === DESTROYED) return;\n    // Already executing, skip\n    if (self.executing) return;\n    // Set pool as executing\n    self.executing = true;\n\n    // New pool connections are in progress, wait them to finish\n    // before executing any more operation to ensure distribution of\n    // operations\n    if (self.connectingConnections > 0) {\n      self.executing = false;\n      return;\n    }\n\n    // As long as we have available connections\n    // eslint-disable-next-line\n    while (true) {\n      // Total availble connections\n      const totalConnections = totalConnectionCount(self);\n\n      // No available connections available, flush any monitoring ops\n      if (self.availableConnections.length === 0) {\n        // Flush any monitoring operations\n        flushMonitoringOperations(self.queue);\n\n        // Try to create a new connection to execute stuck operation\n        if (totalConnections < self.options.size && self.queue.length > 0) {\n          createConnection(self);\n        }\n\n        break;\n      }\n\n      // No queue break\n      if (self.queue.length === 0) {\n        break;\n      }\n\n      var connection = null;\n      const connections = self.availableConnections.filter(conn => conn.workItems.length === 0);\n\n      // No connection found that has no work on it, just pick one for pipelining\n      if (connections.length === 0) {\n        connection =\n          self.availableConnections[self.connectionIndex++ % self.availableConnections.length];\n      } else {\n        connection = connections[self.connectionIndex++ % connections.length];\n      }\n\n      // Is the connection connected\n      if (!connection.isConnected()) {\n        // Remove the disconnected connection\n        removeConnection(self, connection);\n        // Flush any monitoring operations in the queue, failing fast\n        flushMonitoringOperations(self.queue);\n        break;\n      }\n\n      // Get the next work item\n      var workItem = self.queue.shift();\n\n      // If we are monitoring we need to use a connection that is not\n      // running another operation to avoid socket timeout changes\n      // affecting an existing operation\n      if (workItem.monitoring) {\n        var foundValidConnection = false;\n\n        for (let i = 0; i < self.availableConnections.length; i++) {\n          // If the connection is connected\n          // And there are no pending workItems on it\n          // Then we can safely use it for monitoring.\n          if (\n            self.availableConnections[i].isConnected() &&\n            self.availableConnections[i].workItems.length === 0\n          ) {\n            foundValidConnection = true;\n            connection = self.availableConnections[i];\n            break;\n          }\n        }\n\n        // No safe connection found, attempt to grow the connections\n        // if possible and break from the loop\n        if (!foundValidConnection) {\n          // Put workItem back on the queue\n          self.queue.unshift(workItem);\n\n          // Attempt to grow the pool if it's not yet maxsize\n          if (totalConnections < self.options.size && self.queue.length > 0) {\n            // Create a new connection\n            createConnection(self);\n          }\n\n          // Re-execute the operation\n          setTimeout(() => _execute(self)(), 10);\n          break;\n        }\n      }\n\n      // Don't execute operation until we have a full pool\n      if (totalConnections < self.options.size) {\n        // Connection has work items, then put it back on the queue\n        // and create a new connection\n        if (connection.workItems.length > 0) {\n          // Lets put the workItem back on the list\n          self.queue.unshift(workItem);\n          // Create a new connection\n          createConnection(self);\n          // Break from the loop\n          break;\n        }\n      }\n\n      // Get actual binary commands\n      var buffer = workItem.buffer;\n\n      // If we are monitoring take the connection of the availableConnections\n      if (workItem.monitoring) {\n        moveConnectionBetween(connection, self.availableConnections, self.inUseConnections);\n      }\n\n      // Track the executing commands on the mongo server\n      // as long as there is an expected response\n      if (!workItem.noResponse) {\n        connection.workItems.push(workItem);\n      }\n\n      // We have a custom socketTimeout\n      if (!workItem.immediateRelease && typeof workItem.socketTimeout === 'number') {\n        connection.setSocketTimeout(workItem.socketTimeout);\n      }\n\n      // Capture if write was successful\n      var writeSuccessful = true;\n\n      // Put operation on the wire\n      if (Array.isArray(buffer)) {\n        for (let i = 0; i < buffer.length; i++) {\n          writeSuccessful = connection.write(buffer[i]);\n        }\n      } else {\n        writeSuccessful = connection.write(buffer);\n      }\n\n      // if the command is designated noResponse, call the callback immeditely\n      if (workItem.noResponse && typeof workItem.cb === 'function') {\n        workItem.cb(null, null);\n      }\n\n      if (writeSuccessful === false) {\n        // If write not successful put back on queue\n        self.queue.unshift(workItem);\n        // Remove the disconnected connection\n        removeConnection(self, connection);\n        // Flush any monitoring operations in the queue, failing fast\n        flushMonitoringOperations(self.queue);\n        break;\n      }\n    }\n\n    self.executing = false;\n  };\n}\n\n// Make execution loop available for testing\nPool._execute = _execute;\n\n/**\n * A server connect event, used to verify that the connection is up and running\n *\n * @event Pool#connect\n * @type {Pool}\n */\n\n/**\n * A server reconnect event, used to verify that pool reconnected.\n *\n * @event Pool#reconnect\n * @type {Pool}\n */\n\n/**\n * The server connection closed, all pool connections closed\n *\n * @event Pool#close\n * @type {Pool}\n */\n\n/**\n * The server connection caused an error, all pool connections closed\n *\n * @event Pool#error\n * @type {Pool}\n */\n\n/**\n * The server connection timed out, all pool connections closed\n *\n * @event Pool#timeout\n * @type {Pool}\n */\n\n/**\n * The driver experienced an invalid message, all pool connections closed\n *\n * @event Pool#parseError\n * @type {Pool}\n */\n\n/**\n * The driver attempted to reconnect\n *\n * @event Pool#attemptReconnect\n * @type {Pool}\n */\n\n/**\n * The driver exhausted all reconnect attempts\n *\n * @event Pool#reconnectFailed\n * @type {Pool}\n */\n\nmodule.exports = Pool;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}