{"ast":null,"code":"'use strict';\n\nconst MongoError = require('./core/error').MongoError;\n\nconst WriteConcern = require('./write_concern');\n\nvar shallowClone = function (obj) {\n  var copy = {};\n\n  for (var name in obj) copy[name] = obj[name];\n\n  return copy;\n}; // Set simple property\n\n\nvar getSingleProperty = function (obj, name, value) {\n  Object.defineProperty(obj, name, {\n    enumerable: true,\n    get: function () {\n      return value;\n    }\n  });\n};\n\nvar formatSortValue = exports.formatSortValue = function (sortDirection) {\n  var value = ('' + sortDirection).toLowerCase();\n\n  switch (value) {\n    case 'ascending':\n    case 'asc':\n    case '1':\n      return 1;\n\n    case 'descending':\n    case 'desc':\n    case '-1':\n      return -1;\n\n    default:\n      throw new Error('Illegal sort clause, must be of the form ' + \"[['field1', '(ascending|descending)'], \" + \"['field2', '(ascending|descending)']]\");\n  }\n};\n\nvar formattedOrderClause = exports.formattedOrderClause = function (sortValue) {\n  var orderBy = {};\n  if (sortValue == null) return null;\n\n  if (Array.isArray(sortValue)) {\n    if (sortValue.length === 0) {\n      return null;\n    }\n\n    for (var i = 0; i < sortValue.length; i++) {\n      if (sortValue[i].constructor === String) {\n        orderBy[sortValue[i]] = 1;\n      } else {\n        orderBy[sortValue[i][0]] = formatSortValue(sortValue[i][1]);\n      }\n    }\n  } else if (sortValue != null && typeof sortValue === 'object') {\n    orderBy = sortValue;\n  } else if (typeof sortValue === 'string') {\n    orderBy[sortValue] = 1;\n  } else {\n    throw new Error('Illegal sort clause, must be of the form ' + \"[['field1', '(ascending|descending)'], ['field2', '(ascending|descending)']]\");\n  }\n\n  return orderBy;\n};\n\nvar checkCollectionName = function checkCollectionName(collectionName) {\n  if ('string' !== typeof collectionName) {\n    throw new MongoError('collection name must be a String');\n  }\n\n  if (!collectionName || collectionName.indexOf('..') !== -1) {\n    throw new MongoError('collection names cannot be empty');\n  }\n\n  if (collectionName.indexOf('$') !== -1 && collectionName.match(/((^\\$cmd)|(oplog\\.\\$main))/) == null) {\n    throw new MongoError(\"collection names must not contain '$'\");\n  }\n\n  if (collectionName.match(/^\\.|\\.$/) != null) {\n    throw new MongoError(\"collection names must not start or end with '.'\");\n  } // Validate that we are not passing 0x00 in the collection name\n\n\n  if (collectionName.indexOf('\\x00') !== -1) {\n    throw new MongoError('collection names cannot contain a null character');\n  }\n};\n\nvar handleCallback = function (callback, err, value1, value2) {\n  try {\n    if (callback == null) return;\n\n    if (callback) {\n      return value2 ? callback(err, value1, value2) : callback(err, value1);\n    }\n  } catch (err) {\n    process.nextTick(function () {\n      throw err;\n    });\n    return false;\n  }\n\n  return true;\n};\n/**\n * Wrap a Mongo error document in an Error instance\n * @ignore\n * @api private\n */\n\n\nvar toError = function (error) {\n  if (error instanceof Error) return error;\n  var msg = error.err || error.errmsg || error.errMessage || error;\n  var e = MongoError.create({\n    message: msg,\n    driver: true\n  }); // Get all object keys\n\n  var keys = typeof error === 'object' ? Object.keys(error) : [];\n\n  for (var i = 0; i < keys.length; i++) {\n    try {\n      e[keys[i]] = error[keys[i]];\n    } catch (err) {// continue\n    }\n  }\n\n  return e;\n};\n/**\n * @ignore\n */\n\n\nvar normalizeHintField = function normalizeHintField(hint) {\n  var finalHint = null;\n\n  if (typeof hint === 'string') {\n    finalHint = hint;\n  } else if (Array.isArray(hint)) {\n    finalHint = {};\n    hint.forEach(function (param) {\n      finalHint[param] = 1;\n    });\n  } else if (hint != null && typeof hint === 'object') {\n    finalHint = {};\n\n    for (var name in hint) {\n      finalHint[name] = hint[name];\n    }\n  }\n\n  return finalHint;\n};\n/**\n * Create index name based on field spec\n *\n * @ignore\n * @api private\n */\n\n\nvar parseIndexOptions = function (fieldOrSpec) {\n  var fieldHash = {};\n  var indexes = [];\n  var keys; // Get all the fields accordingly\n\n  if ('string' === typeof fieldOrSpec) {\n    // 'type'\n    indexes.push(fieldOrSpec + '_' + 1);\n    fieldHash[fieldOrSpec] = 1;\n  } else if (Array.isArray(fieldOrSpec)) {\n    fieldOrSpec.forEach(function (f) {\n      if ('string' === typeof f) {\n        // [{location:'2d'}, 'type']\n        indexes.push(f + '_' + 1);\n        fieldHash[f] = 1;\n      } else if (Array.isArray(f)) {\n        // [['location', '2d'],['type', 1]]\n        indexes.push(f[0] + '_' + (f[1] || 1));\n        fieldHash[f[0]] = f[1] || 1;\n      } else if (isObject(f)) {\n        // [{location:'2d'}, {type:1}]\n        keys = Object.keys(f);\n        keys.forEach(function (k) {\n          indexes.push(k + '_' + f[k]);\n          fieldHash[k] = f[k];\n        });\n      } else {// undefined (ignore)\n      }\n    });\n  } else if (isObject(fieldOrSpec)) {\n    // {location:'2d', type:1}\n    keys = Object.keys(fieldOrSpec);\n    keys.forEach(function (key) {\n      indexes.push(key + '_' + fieldOrSpec[key]);\n      fieldHash[key] = fieldOrSpec[key];\n    });\n  }\n\n  return {\n    name: indexes.join('_'),\n    keys: keys,\n    fieldHash: fieldHash\n  };\n};\n\nvar isObject = exports.isObject = function (arg) {\n  return '[object Object]' === Object.prototype.toString.call(arg);\n};\n\nvar debugOptions = function (debugFields, options) {\n  var finaloptions = {};\n  debugFields.forEach(function (n) {\n    finaloptions[n] = options[n];\n  });\n  return finaloptions;\n};\n\nvar decorateCommand = function (command, options, exclude) {\n  for (var name in options) {\n    if (exclude.indexOf(name) === -1) command[name] = options[name];\n  }\n\n  return command;\n};\n\nvar mergeOptions = function (target, source) {\n  for (var name in source) {\n    target[name] = source[name];\n  }\n\n  return target;\n}; // Merge options with translation\n\n\nvar translateOptions = function (target, source) {\n  var translations = {\n    // SSL translation options\n    sslCA: 'ca',\n    sslCRL: 'crl',\n    sslValidate: 'rejectUnauthorized',\n    sslKey: 'key',\n    sslCert: 'cert',\n    sslPass: 'passphrase',\n    // SocketTimeout translation options\n    socketTimeoutMS: 'socketTimeout',\n    connectTimeoutMS: 'connectionTimeout',\n    // Replicaset options\n    replicaSet: 'setName',\n    rs_name: 'setName',\n    secondaryAcceptableLatencyMS: 'acceptableLatency',\n    connectWithNoPrimary: 'secondaryOnlyConnectionAllowed',\n    // Mongos options\n    acceptableLatencyMS: 'localThresholdMS'\n  };\n\n  for (var name in source) {\n    if (translations[name]) {\n      target[translations[name]] = source[name];\n    } else {\n      target[name] = source[name];\n    }\n  }\n\n  return target;\n};\n\nvar filterOptions = function (options, names) {\n  var filterOptions = {};\n\n  for (var name in options) {\n    if (names.indexOf(name) !== -1) filterOptions[name] = options[name];\n  } // Filtered options\n\n\n  return filterOptions;\n}; // Write concern keys\n\n\nvar writeConcernKeys = ['w', 'j', 'wtimeout', 'fsync']; // Merge the write concern options\n\nvar mergeOptionsAndWriteConcern = function (targetOptions, sourceOptions, keys, mergeWriteConcern) {\n  // Mix in any allowed options\n  for (var i = 0; i < keys.length; i++) {\n    if (!targetOptions[keys[i]] && sourceOptions[keys[i]] !== undefined) {\n      targetOptions[keys[i]] = sourceOptions[keys[i]];\n    }\n  } // No merging of write concern\n\n\n  if (!mergeWriteConcern) return targetOptions; // Found no write Concern options\n\n  var found = false;\n\n  for (i = 0; i < writeConcernKeys.length; i++) {\n    if (targetOptions[writeConcernKeys[i]]) {\n      found = true;\n      break;\n    }\n  }\n\n  if (!found) {\n    for (i = 0; i < writeConcernKeys.length; i++) {\n      if (sourceOptions[writeConcernKeys[i]]) {\n        targetOptions[writeConcernKeys[i]] = sourceOptions[writeConcernKeys[i]];\n      }\n    }\n  }\n\n  return targetOptions;\n};\n/**\n * Executes the given operation with provided arguments.\n *\n * This method reduces large amounts of duplication in the entire codebase by providing\n * a single point for determining whether callbacks or promises should be used. Additionally\n * it allows for a single point of entry to provide features such as implicit sessions, which\n * are required by the Driver Sessions specification in the event that a ClientSession is\n * not provided\n *\n * @param {object} topology The topology to execute this operation on\n * @param {function} operation The operation to execute\n * @param {array} args Arguments to apply the provided operation\n * @param {object} [options] Options that modify the behavior of the method\n */\n\n\nconst executeLegacyOperation = (topology, operation, args, options) => {\n  if (topology == null) {\n    throw new TypeError('This method requires a valid topology instance');\n  }\n\n  if (!Array.isArray(args)) {\n    throw new TypeError('This method requires an array of arguments to apply');\n  }\n\n  options = options || {};\n  const Promise = topology.s.promiseLibrary;\n  let callback = args[args.length - 1]; // The driver sessions spec mandates that we implicitly create sessions for operations\n  // that are not explicitly provided with a session.\n\n  let session, opOptions, owner;\n\n  if (!options.skipSessions && topology.hasSessionSupport()) {\n    opOptions = args[args.length - 2];\n\n    if (opOptions == null || opOptions.session == null) {\n      owner = Symbol();\n      session = topology.startSession({\n        owner\n      });\n      const optionsIndex = args.length - 2;\n      args[optionsIndex] = Object.assign({}, args[optionsIndex], {\n        session: session\n      });\n    } else if (opOptions.session && opOptions.session.hasEnded) {\n      throw new MongoError('Use of expired sessions is not permitted');\n    }\n  }\n\n  const makeExecuteCallback = (resolve, reject) => function executeCallback(err, result) {\n    if (session && session.owner === owner && !options.returnsCursor) {\n      session.endSession(() => {\n        delete opOptions.session;\n        if (err) return reject(err);\n        resolve(result);\n      });\n    } else {\n      if (err) return reject(err);\n      resolve(result);\n    }\n  }; // Execute using callback\n\n\n  if (typeof callback === 'function') {\n    callback = args.pop();\n    const handler = makeExecuteCallback(result => callback(null, result), err => callback(err, null));\n    args.push(handler);\n\n    try {\n      return operation.apply(null, args);\n    } catch (e) {\n      handler(e);\n      throw e;\n    }\n  } // Return a Promise\n\n\n  if (args[args.length - 1] != null) {\n    throw new TypeError('final argument to `executeLegacyOperation` must be a callback');\n  }\n\n  return new Promise(function (resolve, reject) {\n    const handler = makeExecuteCallback(resolve, reject);\n    args[args.length - 1] = handler;\n\n    try {\n      return operation.apply(null, args);\n    } catch (e) {\n      handler(e);\n    }\n  });\n};\n/**\n * Applies retryWrites: true to a command if retryWrites is set on the command's database.\n *\n * @param {object} target The target command to which we will apply retryWrites.\n * @param {object} db The database from which we can inherit a retryWrites value.\n */\n\n\nfunction applyRetryableWrites(target, db) {\n  if (db && db.s.options.retryWrites) {\n    target.retryWrites = true;\n  }\n\n  return target;\n}\n/**\n * Applies a write concern to a command based on well defined inheritance rules, optionally\n * detecting support for the write concern in the first place.\n *\n * @param {Object} target the target command we will be applying the write concern to\n * @param {Object} sources sources where we can inherit default write concerns from\n * @param {Object} [options] optional settings passed into a command for write concern overrides\n * @returns {Object} the (now) decorated target\n */\n\n\nfunction applyWriteConcern(target, sources, options) {\n  options = options || {};\n  const db = sources.db;\n  const coll = sources.collection;\n\n  if (options.session && options.session.inTransaction()) {\n    // writeConcern is not allowed within a multi-statement transaction\n    if (target.writeConcern) {\n      delete target.writeConcern;\n    }\n\n    return target;\n  }\n\n  const writeConcern = WriteConcern.fromOptions(options);\n\n  if (writeConcern) {\n    return Object.assign(target, {\n      writeConcern\n    });\n  }\n\n  if (coll && coll.writeConcern) {\n    return Object.assign(target, {\n      writeConcern: Object.assign({}, coll.writeConcern)\n    });\n  }\n\n  if (db && db.writeConcern) {\n    return Object.assign(target, {\n      writeConcern: Object.assign({}, db.writeConcern)\n    });\n  }\n\n  return target;\n}\n/**\n * Checks if a given value is a Promise\n *\n * @param {*} maybePromise\n * @return true if the provided value is a Promise\n */\n\n\nfunction isPromiseLike(maybePromise) {\n  return maybePromise && typeof maybePromise.then === 'function';\n}\n/**\n * Applies collation to a given command.\n *\n * @param {object} [command] the command on which to apply collation\n * @param {(Cursor|Collection)} [target] target of command\n * @param {object} [options] options containing collation settings\n */\n\n\nfunction decorateWithCollation(command, target, options) {\n  const topology = target.s && target.s.topology || target.topology;\n\n  if (!topology) {\n    throw new TypeError('parameter \"target\" is missing a topology');\n  }\n\n  const capabilities = topology.capabilities();\n\n  if (options.collation && typeof options.collation === 'object') {\n    if (capabilities && capabilities.commandsTakeCollation) {\n      command.collation = options.collation;\n    } else {\n      throw new MongoError(`Current topology does not support collation`);\n    }\n  }\n}\n/**\n * Applies a read concern to a given command.\n *\n * @param {object} command the command on which to apply the read concern\n * @param {Collection} coll the parent collection of the operation calling this method\n */\n\n\nfunction decorateWithReadConcern(command, coll, options) {\n  if (options && options.session && options.session.inTransaction()) {\n    return;\n  }\n\n  let readConcern = Object.assign({}, command.readConcern || {});\n\n  if (coll.s.readConcern) {\n    Object.assign(readConcern, coll.s.readConcern);\n  }\n\n  if (Object.keys(readConcern).length > 0) {\n    Object.assign(command, {\n      readConcern: readConcern\n    });\n  }\n}\n\nconst emitProcessWarning = msg => process.emitWarning(msg, 'DeprecationWarning');\n\nconst emitConsoleWarning = msg => console.error(msg);\n\nconst emitDeprecationWarning = process.emitWarning ? emitProcessWarning : emitConsoleWarning;\n/**\n * Default message handler for generating deprecation warnings.\n *\n * @param {string} name function name\n * @param {string} option option name\n * @return {string} warning message\n * @ignore\n * @api private\n */\n\nfunction defaultMsgHandler(name, option) {\n  return `${name} option [${option}] is deprecated and will be removed in a later version.`;\n}\n/**\n * Deprecates a given function's options.\n *\n * @param {object} config configuration for deprecation\n * @param {string} config.name function name\n * @param {Array} config.deprecatedOptions options to deprecate\n * @param {number} config.optionsIndex index of options object in function arguments array\n * @param {function} [config.msgHandler] optional custom message handler to generate warnings\n * @param {function} fn the target function of deprecation\n * @return {function} modified function that warns once per deprecated option, and executes original function\n * @ignore\n * @api private\n */\n\n\nfunction deprecateOptions(config, fn) {\n  if (process.noDeprecation === true) {\n    return fn;\n  }\n\n  const msgHandler = config.msgHandler ? config.msgHandler : defaultMsgHandler;\n  const optionsWarned = new Set();\n\n  function deprecated() {\n    const options = arguments[config.optionsIndex]; // ensure options is a valid, non-empty object, otherwise short-circuit\n\n    if (!isObject(options) || Object.keys(options).length === 0) {\n      return fn.apply(this, arguments);\n    }\n\n    config.deprecatedOptions.forEach(deprecatedOption => {\n      if (Object.prototype.hasOwnProperty.call(options, deprecatedOption) && !optionsWarned.has(deprecatedOption)) {\n        optionsWarned.add(deprecatedOption);\n        const msg = msgHandler(config.name, deprecatedOption);\n        emitDeprecationWarning(msg);\n\n        if (this && this.getLogger) {\n          const logger = this.getLogger();\n\n          if (logger) {\n            logger.warn(msg);\n          }\n        }\n      }\n    });\n    return fn.apply(this, arguments);\n  } // These lines copied from https://github.com/nodejs/node/blob/25e5ae41688676a5fd29b2e2e7602168eee4ceb5/lib/internal/util.js#L73-L80\n  // The wrapper will keep the same prototype as fn to maintain prototype chain\n\n\n  Object.setPrototypeOf(deprecated, fn);\n\n  if (fn.prototype) {\n    // Setting this (rather than using Object.setPrototype, as above) ensures\n    // that calling the unwrapped constructor gives an instanceof the wrapped\n    // constructor.\n    deprecated.prototype = fn.prototype;\n  }\n\n  return deprecated;\n}\n\nconst SUPPORTS = {}; // Test asyncIterator support\n\ntry {\n  require('./async/async_iterator');\n\n  SUPPORTS.ASYNC_ITERATOR = true;\n} catch (e) {\n  SUPPORTS.ASYNC_ITERATOR = false;\n}\n\nclass MongoDBNamespace {\n  constructor(db, collection) {\n    this.db = db;\n    this.collection = collection;\n  }\n\n  toString() {\n    return this.collection ? `${this.db}.${this.collection}` : this.db;\n  }\n\n  withCollection(collection) {\n    return new MongoDBNamespace(this.db, collection);\n  }\n\n  static fromString(namespace) {\n    if (!namespace) {\n      throw new Error(`Cannot parse namespace from \"${namespace}\"`);\n    }\n\n    const index = namespace.indexOf('.');\n    return new MongoDBNamespace(namespace.substring(0, index), namespace.substring(index + 1));\n  }\n\n}\n\nfunction* makeCounter(seed) {\n  let count = seed || 0;\n\n  while (true) {\n    const newCount = count;\n    count += 1;\n    yield newCount;\n  }\n}\n/**\n * Helper function for either accepting a callback, or returning a promise\n *\n * @param {Object} parent an instance of parent with promiseLibrary.\n * @param {object} parent.s an object containing promiseLibrary.\n * @param {function} parent.s.promiseLibrary an object containing promiseLibrary.\n * @param {[Function]} callback an optional callback.\n * @param {Function} fn A function that takes a callback\n * @returns {Promise|void} Returns nothing if a callback is supplied, else returns a Promise.\n */\n\n\nfunction maybePromise(parent, callback, fn) {\n  const PromiseLibrary = parent && parent.s && parent.s.promiseLibrary || Promise;\n  let result;\n\n  if (typeof callback !== 'function') {\n    result = new PromiseLibrary((resolve, reject) => {\n      callback = (err, res) => {\n        if (err) return reject(err);\n        resolve(res);\n      };\n    });\n  }\n\n  fn(function (err, res) {\n    if (err != null) {\n      try {\n        callback(err);\n      } catch (error) {\n        return process.nextTick(() => {\n          throw error;\n        });\n      }\n\n      return;\n    }\n\n    callback(err, res);\n  });\n  return result;\n}\n\nfunction now() {\n  const hrtime = process.hrtime();\n  return Math.floor(hrtime[0] * 1000 + hrtime[1] / 1000000);\n}\n\nfunction calculateDurationInMs(started) {\n  if (typeof started !== 'number') {\n    throw TypeError('numeric value required to calculate duration');\n  }\n\n  const elapsed = now() - started;\n  return elapsed < 0 ? 0 : elapsed;\n}\n/**\n * Creates an interval timer which is able to be woken up sooner than\n * the interval. The timer will also debounce multiple calls to wake\n * ensuring that the function is only ever called once within a minimum\n * interval window.\n *\n * @param {function} fn An async function to run on an interval, must accept a `callback` as its only parameter\n * @param {object} [options] Optional settings\n * @param {number} [options.interval] The interval at which to run the provided function\n * @param {number} [options.minInterval] The minimum time which must pass between invocations of the provided function\n * @param {boolean} [options.immediate] Execute the function immediately when the interval is started\n */\n\n\nfunction makeInterruptableAsyncInterval(fn, options) {\n  let timerId;\n  let lastCallTime;\n  let lastWakeTime;\n  let stopped = false;\n  options = options || {};\n  const interval = options.interval || 1000;\n  const minInterval = options.minInterval || 500;\n  const immediate = typeof options.immediate === 'boolean' ? options.immediate : false;\n  const clock = typeof options.clock === 'function' ? options.clock : now;\n\n  function wake() {\n    const currentTime = clock();\n    const timeSinceLastWake = currentTime - lastWakeTime;\n    const timeSinceLastCall = currentTime - lastCallTime;\n    const timeUntilNextCall = interval - timeSinceLastCall;\n    lastWakeTime = currentTime; // For the streaming protocol: there is nothing obviously stopping this\n    // interval from being woken up again while we are waiting \"infinitely\"\n    // for `fn` to be called again`. Since the function effectively\n    // never completes, the `timeUntilNextCall` will continue to grow\n    // negatively unbounded, so it will never trigger a reschedule here.\n    // debounce multiple calls to wake within the `minInterval`\n\n    if (timeSinceLastWake < minInterval) {\n      return;\n    } // reschedule a call as soon as possible, ensuring the call never happens\n    // faster than the `minInterval`\n\n\n    if (timeUntilNextCall > minInterval) {\n      reschedule(minInterval);\n    } // This is possible in virtualized environments like AWS Lambda where our\n    // clock is unreliable. In these cases the timer is \"running\" but never\n    // actually completes, so we want to execute immediately and then attempt\n    // to reschedule.\n\n\n    if (timeUntilNextCall < 0) {\n      executeAndReschedule();\n    }\n  }\n\n  function stop() {\n    stopped = true;\n\n    if (timerId) {\n      clearTimeout(timerId);\n      timerId = null;\n    }\n\n    lastCallTime = 0;\n    lastWakeTime = 0;\n  }\n\n  function reschedule(ms) {\n    if (stopped) return;\n    clearTimeout(timerId);\n    timerId = setTimeout(executeAndReschedule, ms || interval);\n  }\n\n  function executeAndReschedule() {\n    lastWakeTime = 0;\n    lastCallTime = clock();\n    fn(err => {\n      if (err) throw err;\n      reschedule(interval);\n    });\n  }\n\n  if (immediate) {\n    executeAndReschedule();\n  } else {\n    lastCallTime = clock();\n    reschedule();\n  }\n\n  return {\n    wake,\n    stop\n  };\n}\n\nfunction hasAtomicOperators(doc) {\n  if (Array.isArray(doc)) {\n    return doc.reduce((err, u) => err || hasAtomicOperators(u), null);\n  }\n\n  const keys = Object.keys(doc);\n  return keys.length > 0 && keys[0][0] === '$';\n}\n\nmodule.exports = {\n  filterOptions,\n  mergeOptions,\n  translateOptions,\n  shallowClone,\n  getSingleProperty,\n  checkCollectionName,\n  toError,\n  formattedOrderClause,\n  parseIndexOptions,\n  normalizeHintField,\n  handleCallback,\n  decorateCommand,\n  isObject,\n  debugOptions,\n  MAX_JS_INT: Number.MAX_SAFE_INTEGER + 1,\n  mergeOptionsAndWriteConcern,\n  executeLegacyOperation,\n  applyRetryableWrites,\n  applyWriteConcern,\n  isPromiseLike,\n  decorateWithCollation,\n  decorateWithReadConcern,\n  deprecateOptions,\n  SUPPORTS,\n  MongoDBNamespace,\n  emitDeprecationWarning,\n  makeCounter,\n  maybePromise,\n  now,\n  calculateDurationInMs,\n  makeInterruptableAsyncInterval,\n  hasAtomicOperators\n};","map":{"version":3,"names":["MongoError","require","WriteConcern","shallowClone","obj","copy","name","getSingleProperty","value","Object","defineProperty","enumerable","get","formatSortValue","exports","sortDirection","toLowerCase","Error","formattedOrderClause","sortValue","orderBy","Array","isArray","length","i","constructor","String","checkCollectionName","collectionName","indexOf","match","handleCallback","callback","err","value1","value2","process","nextTick","toError","error","msg","errmsg","errMessage","e","create","message","driver","keys","normalizeHintField","hint","finalHint","forEach","param","parseIndexOptions","fieldOrSpec","fieldHash","indexes","push","f","isObject","k","key","join","arg","prototype","toString","call","debugOptions","debugFields","options","finaloptions","n","decorateCommand","command","exclude","mergeOptions","target","source","translateOptions","translations","sslCA","sslCRL","sslValidate","sslKey","sslCert","sslPass","socketTimeoutMS","connectTimeoutMS","replicaSet","rs_name","secondaryAcceptableLatencyMS","connectWithNoPrimary","acceptableLatencyMS","filterOptions","names","writeConcernKeys","mergeOptionsAndWriteConcern","targetOptions","sourceOptions","mergeWriteConcern","undefined","found","executeLegacyOperation","topology","operation","args","TypeError","Promise","s","promiseLibrary","session","opOptions","owner","skipSessions","hasSessionSupport","Symbol","startSession","optionsIndex","assign","hasEnded","makeExecuteCallback","resolve","reject","executeCallback","result","returnsCursor","endSession","pop","handler","apply","applyRetryableWrites","db","retryWrites","applyWriteConcern","sources","coll","collection","inTransaction","writeConcern","fromOptions","isPromiseLike","maybePromise","then","decorateWithCollation","capabilities","collation","commandsTakeCollation","decorateWithReadConcern","readConcern","emitProcessWarning","emitWarning","emitConsoleWarning","console","emitDeprecationWarning","defaultMsgHandler","option","deprecateOptions","config","fn","noDeprecation","msgHandler","optionsWarned","Set","deprecated","arguments","deprecatedOptions","deprecatedOption","hasOwnProperty","has","add","getLogger","logger","warn","setPrototypeOf","SUPPORTS","ASYNC_ITERATOR","MongoDBNamespace","withCollection","fromString","namespace","index","substring","makeCounter","seed","count","newCount","parent","PromiseLibrary","res","now","hrtime","Math","floor","calculateDurationInMs","started","elapsed","makeInterruptableAsyncInterval","timerId","lastCallTime","lastWakeTime","stopped","interval","minInterval","immediate","clock","wake","currentTime","timeSinceLastWake","timeSinceLastCall","timeUntilNextCall","reschedule","executeAndReschedule","stop","clearTimeout","ms","setTimeout","hasAtomicOperators","doc","reduce","u","module","MAX_JS_INT","Number","MAX_SAFE_INTEGER"],"sources":["C:/Users/Administrator/Desktop/webAPI work/web/dog-website/node_modules/koa-mongo/node_modules/mongodb/lib/utils.js"],"sourcesContent":["'use strict';\nconst MongoError = require('./core/error').MongoError;\nconst WriteConcern = require('./write_concern');\n\nvar shallowClone = function(obj) {\n  var copy = {};\n  for (var name in obj) copy[name] = obj[name];\n  return copy;\n};\n\n// Set simple property\nvar getSingleProperty = function(obj, name, value) {\n  Object.defineProperty(obj, name, {\n    enumerable: true,\n    get: function() {\n      return value;\n    }\n  });\n};\n\nvar formatSortValue = (exports.formatSortValue = function(sortDirection) {\n  var value = ('' + sortDirection).toLowerCase();\n\n  switch (value) {\n    case 'ascending':\n    case 'asc':\n    case '1':\n      return 1;\n    case 'descending':\n    case 'desc':\n    case '-1':\n      return -1;\n    default:\n      throw new Error(\n        'Illegal sort clause, must be of the form ' +\n          \"[['field1', '(ascending|descending)'], \" +\n          \"['field2', '(ascending|descending)']]\"\n      );\n  }\n});\n\nvar formattedOrderClause = (exports.formattedOrderClause = function(sortValue) {\n  var orderBy = {};\n  if (sortValue == null) return null;\n  if (Array.isArray(sortValue)) {\n    if (sortValue.length === 0) {\n      return null;\n    }\n\n    for (var i = 0; i < sortValue.length; i++) {\n      if (sortValue[i].constructor === String) {\n        orderBy[sortValue[i]] = 1;\n      } else {\n        orderBy[sortValue[i][0]] = formatSortValue(sortValue[i][1]);\n      }\n    }\n  } else if (sortValue != null && typeof sortValue === 'object') {\n    orderBy = sortValue;\n  } else if (typeof sortValue === 'string') {\n    orderBy[sortValue] = 1;\n  } else {\n    throw new Error(\n      'Illegal sort clause, must be of the form ' +\n        \"[['field1', '(ascending|descending)'], ['field2', '(ascending|descending)']]\"\n    );\n  }\n\n  return orderBy;\n});\n\nvar checkCollectionName = function checkCollectionName(collectionName) {\n  if ('string' !== typeof collectionName) {\n    throw new MongoError('collection name must be a String');\n  }\n\n  if (!collectionName || collectionName.indexOf('..') !== -1) {\n    throw new MongoError('collection names cannot be empty');\n  }\n\n  if (\n    collectionName.indexOf('$') !== -1 &&\n    collectionName.match(/((^\\$cmd)|(oplog\\.\\$main))/) == null\n  ) {\n    throw new MongoError(\"collection names must not contain '$'\");\n  }\n\n  if (collectionName.match(/^\\.|\\.$/) != null) {\n    throw new MongoError(\"collection names must not start or end with '.'\");\n  }\n\n  // Validate that we are not passing 0x00 in the collection name\n  if (collectionName.indexOf('\\x00') !== -1) {\n    throw new MongoError('collection names cannot contain a null character');\n  }\n};\n\nvar handleCallback = function(callback, err, value1, value2) {\n  try {\n    if (callback == null) return;\n\n    if (callback) {\n      return value2 ? callback(err, value1, value2) : callback(err, value1);\n    }\n  } catch (err) {\n    process.nextTick(function() {\n      throw err;\n    });\n    return false;\n  }\n\n  return true;\n};\n\n/**\n * Wrap a Mongo error document in an Error instance\n * @ignore\n * @api private\n */\nvar toError = function(error) {\n  if (error instanceof Error) return error;\n\n  var msg = error.err || error.errmsg || error.errMessage || error;\n  var e = MongoError.create({ message: msg, driver: true });\n\n  // Get all object keys\n  var keys = typeof error === 'object' ? Object.keys(error) : [];\n\n  for (var i = 0; i < keys.length; i++) {\n    try {\n      e[keys[i]] = error[keys[i]];\n    } catch (err) {\n      // continue\n    }\n  }\n\n  return e;\n};\n\n/**\n * @ignore\n */\nvar normalizeHintField = function normalizeHintField(hint) {\n  var finalHint = null;\n\n  if (typeof hint === 'string') {\n    finalHint = hint;\n  } else if (Array.isArray(hint)) {\n    finalHint = {};\n\n    hint.forEach(function(param) {\n      finalHint[param] = 1;\n    });\n  } else if (hint != null && typeof hint === 'object') {\n    finalHint = {};\n    for (var name in hint) {\n      finalHint[name] = hint[name];\n    }\n  }\n\n  return finalHint;\n};\n\n/**\n * Create index name based on field spec\n *\n * @ignore\n * @api private\n */\nvar parseIndexOptions = function(fieldOrSpec) {\n  var fieldHash = {};\n  var indexes = [];\n  var keys;\n\n  // Get all the fields accordingly\n  if ('string' === typeof fieldOrSpec) {\n    // 'type'\n    indexes.push(fieldOrSpec + '_' + 1);\n    fieldHash[fieldOrSpec] = 1;\n  } else if (Array.isArray(fieldOrSpec)) {\n    fieldOrSpec.forEach(function(f) {\n      if ('string' === typeof f) {\n        // [{location:'2d'}, 'type']\n        indexes.push(f + '_' + 1);\n        fieldHash[f] = 1;\n      } else if (Array.isArray(f)) {\n        // [['location', '2d'],['type', 1]]\n        indexes.push(f[0] + '_' + (f[1] || 1));\n        fieldHash[f[0]] = f[1] || 1;\n      } else if (isObject(f)) {\n        // [{location:'2d'}, {type:1}]\n        keys = Object.keys(f);\n        keys.forEach(function(k) {\n          indexes.push(k + '_' + f[k]);\n          fieldHash[k] = f[k];\n        });\n      } else {\n        // undefined (ignore)\n      }\n    });\n  } else if (isObject(fieldOrSpec)) {\n    // {location:'2d', type:1}\n    keys = Object.keys(fieldOrSpec);\n    keys.forEach(function(key) {\n      indexes.push(key + '_' + fieldOrSpec[key]);\n      fieldHash[key] = fieldOrSpec[key];\n    });\n  }\n\n  return {\n    name: indexes.join('_'),\n    keys: keys,\n    fieldHash: fieldHash\n  };\n};\n\nvar isObject = (exports.isObject = function(arg) {\n  return '[object Object]' === Object.prototype.toString.call(arg);\n});\n\nvar debugOptions = function(debugFields, options) {\n  var finaloptions = {};\n  debugFields.forEach(function(n) {\n    finaloptions[n] = options[n];\n  });\n\n  return finaloptions;\n};\n\nvar decorateCommand = function(command, options, exclude) {\n  for (var name in options) {\n    if (exclude.indexOf(name) === -1) command[name] = options[name];\n  }\n\n  return command;\n};\n\nvar mergeOptions = function(target, source) {\n  for (var name in source) {\n    target[name] = source[name];\n  }\n\n  return target;\n};\n\n// Merge options with translation\nvar translateOptions = function(target, source) {\n  var translations = {\n    // SSL translation options\n    sslCA: 'ca',\n    sslCRL: 'crl',\n    sslValidate: 'rejectUnauthorized',\n    sslKey: 'key',\n    sslCert: 'cert',\n    sslPass: 'passphrase',\n    // SocketTimeout translation options\n    socketTimeoutMS: 'socketTimeout',\n    connectTimeoutMS: 'connectionTimeout',\n    // Replicaset options\n    replicaSet: 'setName',\n    rs_name: 'setName',\n    secondaryAcceptableLatencyMS: 'acceptableLatency',\n    connectWithNoPrimary: 'secondaryOnlyConnectionAllowed',\n    // Mongos options\n    acceptableLatencyMS: 'localThresholdMS'\n  };\n\n  for (var name in source) {\n    if (translations[name]) {\n      target[translations[name]] = source[name];\n    } else {\n      target[name] = source[name];\n    }\n  }\n\n  return target;\n};\n\nvar filterOptions = function(options, names) {\n  var filterOptions = {};\n\n  for (var name in options) {\n    if (names.indexOf(name) !== -1) filterOptions[name] = options[name];\n  }\n\n  // Filtered options\n  return filterOptions;\n};\n\n// Write concern keys\nvar writeConcernKeys = ['w', 'j', 'wtimeout', 'fsync'];\n\n// Merge the write concern options\nvar mergeOptionsAndWriteConcern = function(targetOptions, sourceOptions, keys, mergeWriteConcern) {\n  // Mix in any allowed options\n  for (var i = 0; i < keys.length; i++) {\n    if (!targetOptions[keys[i]] && sourceOptions[keys[i]] !== undefined) {\n      targetOptions[keys[i]] = sourceOptions[keys[i]];\n    }\n  }\n\n  // No merging of write concern\n  if (!mergeWriteConcern) return targetOptions;\n\n  // Found no write Concern options\n  var found = false;\n  for (i = 0; i < writeConcernKeys.length; i++) {\n    if (targetOptions[writeConcernKeys[i]]) {\n      found = true;\n      break;\n    }\n  }\n\n  if (!found) {\n    for (i = 0; i < writeConcernKeys.length; i++) {\n      if (sourceOptions[writeConcernKeys[i]]) {\n        targetOptions[writeConcernKeys[i]] = sourceOptions[writeConcernKeys[i]];\n      }\n    }\n  }\n\n  return targetOptions;\n};\n\n/**\n * Executes the given operation with provided arguments.\n *\n * This method reduces large amounts of duplication in the entire codebase by providing\n * a single point for determining whether callbacks or promises should be used. Additionally\n * it allows for a single point of entry to provide features such as implicit sessions, which\n * are required by the Driver Sessions specification in the event that a ClientSession is\n * not provided\n *\n * @param {object} topology The topology to execute this operation on\n * @param {function} operation The operation to execute\n * @param {array} args Arguments to apply the provided operation\n * @param {object} [options] Options that modify the behavior of the method\n */\nconst executeLegacyOperation = (topology, operation, args, options) => {\n  if (topology == null) {\n    throw new TypeError('This method requires a valid topology instance');\n  }\n\n  if (!Array.isArray(args)) {\n    throw new TypeError('This method requires an array of arguments to apply');\n  }\n\n  options = options || {};\n  const Promise = topology.s.promiseLibrary;\n  let callback = args[args.length - 1];\n\n  // The driver sessions spec mandates that we implicitly create sessions for operations\n  // that are not explicitly provided with a session.\n  let session, opOptions, owner;\n  if (!options.skipSessions && topology.hasSessionSupport()) {\n    opOptions = args[args.length - 2];\n    if (opOptions == null || opOptions.session == null) {\n      owner = Symbol();\n      session = topology.startSession({ owner });\n      const optionsIndex = args.length - 2;\n      args[optionsIndex] = Object.assign({}, args[optionsIndex], { session: session });\n    } else if (opOptions.session && opOptions.session.hasEnded) {\n      throw new MongoError('Use of expired sessions is not permitted');\n    }\n  }\n\n  const makeExecuteCallback = (resolve, reject) =>\n    function executeCallback(err, result) {\n      if (session && session.owner === owner && !options.returnsCursor) {\n        session.endSession(() => {\n          delete opOptions.session;\n          if (err) return reject(err);\n          resolve(result);\n        });\n      } else {\n        if (err) return reject(err);\n        resolve(result);\n      }\n    };\n\n  // Execute using callback\n  if (typeof callback === 'function') {\n    callback = args.pop();\n    const handler = makeExecuteCallback(\n      result => callback(null, result),\n      err => callback(err, null)\n    );\n    args.push(handler);\n\n    try {\n      return operation.apply(null, args);\n    } catch (e) {\n      handler(e);\n      throw e;\n    }\n  }\n\n  // Return a Promise\n  if (args[args.length - 1] != null) {\n    throw new TypeError('final argument to `executeLegacyOperation` must be a callback');\n  }\n\n  return new Promise(function(resolve, reject) {\n    const handler = makeExecuteCallback(resolve, reject);\n    args[args.length - 1] = handler;\n\n    try {\n      return operation.apply(null, args);\n    } catch (e) {\n      handler(e);\n    }\n  });\n};\n\n/**\n * Applies retryWrites: true to a command if retryWrites is set on the command's database.\n *\n * @param {object} target The target command to which we will apply retryWrites.\n * @param {object} db The database from which we can inherit a retryWrites value.\n */\nfunction applyRetryableWrites(target, db) {\n  if (db && db.s.options.retryWrites) {\n    target.retryWrites = true;\n  }\n\n  return target;\n}\n\n/**\n * Applies a write concern to a command based on well defined inheritance rules, optionally\n * detecting support for the write concern in the first place.\n *\n * @param {Object} target the target command we will be applying the write concern to\n * @param {Object} sources sources where we can inherit default write concerns from\n * @param {Object} [options] optional settings passed into a command for write concern overrides\n * @returns {Object} the (now) decorated target\n */\nfunction applyWriteConcern(target, sources, options) {\n  options = options || {};\n  const db = sources.db;\n  const coll = sources.collection;\n\n  if (options.session && options.session.inTransaction()) {\n    // writeConcern is not allowed within a multi-statement transaction\n    if (target.writeConcern) {\n      delete target.writeConcern;\n    }\n\n    return target;\n  }\n\n  const writeConcern = WriteConcern.fromOptions(options);\n  if (writeConcern) {\n    return Object.assign(target, { writeConcern });\n  }\n\n  if (coll && coll.writeConcern) {\n    return Object.assign(target, { writeConcern: Object.assign({}, coll.writeConcern) });\n  }\n\n  if (db && db.writeConcern) {\n    return Object.assign(target, { writeConcern: Object.assign({}, db.writeConcern) });\n  }\n\n  return target;\n}\n\n/**\n * Checks if a given value is a Promise\n *\n * @param {*} maybePromise\n * @return true if the provided value is a Promise\n */\nfunction isPromiseLike(maybePromise) {\n  return maybePromise && typeof maybePromise.then === 'function';\n}\n\n/**\n * Applies collation to a given command.\n *\n * @param {object} [command] the command on which to apply collation\n * @param {(Cursor|Collection)} [target] target of command\n * @param {object} [options] options containing collation settings\n */\nfunction decorateWithCollation(command, target, options) {\n  const topology = (target.s && target.s.topology) || target.topology;\n\n  if (!topology) {\n    throw new TypeError('parameter \"target\" is missing a topology');\n  }\n\n  const capabilities = topology.capabilities();\n  if (options.collation && typeof options.collation === 'object') {\n    if (capabilities && capabilities.commandsTakeCollation) {\n      command.collation = options.collation;\n    } else {\n      throw new MongoError(`Current topology does not support collation`);\n    }\n  }\n}\n\n/**\n * Applies a read concern to a given command.\n *\n * @param {object} command the command on which to apply the read concern\n * @param {Collection} coll the parent collection of the operation calling this method\n */\nfunction decorateWithReadConcern(command, coll, options) {\n  if (options && options.session && options.session.inTransaction()) {\n    return;\n  }\n  let readConcern = Object.assign({}, command.readConcern || {});\n  if (coll.s.readConcern) {\n    Object.assign(readConcern, coll.s.readConcern);\n  }\n\n  if (Object.keys(readConcern).length > 0) {\n    Object.assign(command, { readConcern: readConcern });\n  }\n}\n\nconst emitProcessWarning = msg => process.emitWarning(msg, 'DeprecationWarning');\nconst emitConsoleWarning = msg => console.error(msg);\nconst emitDeprecationWarning = process.emitWarning ? emitProcessWarning : emitConsoleWarning;\n\n/**\n * Default message handler for generating deprecation warnings.\n *\n * @param {string} name function name\n * @param {string} option option name\n * @return {string} warning message\n * @ignore\n * @api private\n */\nfunction defaultMsgHandler(name, option) {\n  return `${name} option [${option}] is deprecated and will be removed in a later version.`;\n}\n\n/**\n * Deprecates a given function's options.\n *\n * @param {object} config configuration for deprecation\n * @param {string} config.name function name\n * @param {Array} config.deprecatedOptions options to deprecate\n * @param {number} config.optionsIndex index of options object in function arguments array\n * @param {function} [config.msgHandler] optional custom message handler to generate warnings\n * @param {function} fn the target function of deprecation\n * @return {function} modified function that warns once per deprecated option, and executes original function\n * @ignore\n * @api private\n */\nfunction deprecateOptions(config, fn) {\n  if (process.noDeprecation === true) {\n    return fn;\n  }\n\n  const msgHandler = config.msgHandler ? config.msgHandler : defaultMsgHandler;\n\n  const optionsWarned = new Set();\n  function deprecated() {\n    const options = arguments[config.optionsIndex];\n\n    // ensure options is a valid, non-empty object, otherwise short-circuit\n    if (!isObject(options) || Object.keys(options).length === 0) {\n      return fn.apply(this, arguments);\n    }\n\n    config.deprecatedOptions.forEach(deprecatedOption => {\n      if (\n        Object.prototype.hasOwnProperty.call(options, deprecatedOption) &&\n        !optionsWarned.has(deprecatedOption)\n      ) {\n        optionsWarned.add(deprecatedOption);\n        const msg = msgHandler(config.name, deprecatedOption);\n        emitDeprecationWarning(msg);\n        if (this && this.getLogger) {\n          const logger = this.getLogger();\n          if (logger) {\n            logger.warn(msg);\n          }\n        }\n      }\n    });\n\n    return fn.apply(this, arguments);\n  }\n\n  // These lines copied from https://github.com/nodejs/node/blob/25e5ae41688676a5fd29b2e2e7602168eee4ceb5/lib/internal/util.js#L73-L80\n  // The wrapper will keep the same prototype as fn to maintain prototype chain\n  Object.setPrototypeOf(deprecated, fn);\n  if (fn.prototype) {\n    // Setting this (rather than using Object.setPrototype, as above) ensures\n    // that calling the unwrapped constructor gives an instanceof the wrapped\n    // constructor.\n    deprecated.prototype = fn.prototype;\n  }\n\n  return deprecated;\n}\n\nconst SUPPORTS = {};\n// Test asyncIterator support\ntry {\n  require('./async/async_iterator');\n  SUPPORTS.ASYNC_ITERATOR = true;\n} catch (e) {\n  SUPPORTS.ASYNC_ITERATOR = false;\n}\n\nclass MongoDBNamespace {\n  constructor(db, collection) {\n    this.db = db;\n    this.collection = collection;\n  }\n\n  toString() {\n    return this.collection ? `${this.db}.${this.collection}` : this.db;\n  }\n\n  withCollection(collection) {\n    return new MongoDBNamespace(this.db, collection);\n  }\n\n  static fromString(namespace) {\n    if (!namespace) {\n      throw new Error(`Cannot parse namespace from \"${namespace}\"`);\n    }\n\n    const index = namespace.indexOf('.');\n    return new MongoDBNamespace(namespace.substring(0, index), namespace.substring(index + 1));\n  }\n}\n\nfunction* makeCounter(seed) {\n  let count = seed || 0;\n  while (true) {\n    const newCount = count;\n    count += 1;\n    yield newCount;\n  }\n}\n\n/**\n * Helper function for either accepting a callback, or returning a promise\n *\n * @param {Object} parent an instance of parent with promiseLibrary.\n * @param {object} parent.s an object containing promiseLibrary.\n * @param {function} parent.s.promiseLibrary an object containing promiseLibrary.\n * @param {[Function]} callback an optional callback.\n * @param {Function} fn A function that takes a callback\n * @returns {Promise|void} Returns nothing if a callback is supplied, else returns a Promise.\n */\nfunction maybePromise(parent, callback, fn) {\n  const PromiseLibrary = (parent && parent.s && parent.s.promiseLibrary) || Promise;\n\n  let result;\n  if (typeof callback !== 'function') {\n    result = new PromiseLibrary((resolve, reject) => {\n      callback = (err, res) => {\n        if (err) return reject(err);\n        resolve(res);\n      };\n    });\n  }\n\n  fn(function(err, res) {\n    if (err != null) {\n      try {\n        callback(err);\n      } catch (error) {\n        return process.nextTick(() => {\n          throw error;\n        });\n      }\n      return;\n    }\n\n    callback(err, res);\n  });\n\n  return result;\n}\n\nfunction now() {\n  const hrtime = process.hrtime();\n  return Math.floor(hrtime[0] * 1000 + hrtime[1] / 1000000);\n}\n\nfunction calculateDurationInMs(started) {\n  if (typeof started !== 'number') {\n    throw TypeError('numeric value required to calculate duration');\n  }\n\n  const elapsed = now() - started;\n  return elapsed < 0 ? 0 : elapsed;\n}\n\n/**\n * Creates an interval timer which is able to be woken up sooner than\n * the interval. The timer will also debounce multiple calls to wake\n * ensuring that the function is only ever called once within a minimum\n * interval window.\n *\n * @param {function} fn An async function to run on an interval, must accept a `callback` as its only parameter\n * @param {object} [options] Optional settings\n * @param {number} [options.interval] The interval at which to run the provided function\n * @param {number} [options.minInterval] The minimum time which must pass between invocations of the provided function\n * @param {boolean} [options.immediate] Execute the function immediately when the interval is started\n */\nfunction makeInterruptableAsyncInterval(fn, options) {\n  let timerId;\n  let lastCallTime;\n  let lastWakeTime;\n  let stopped = false;\n\n  options = options || {};\n  const interval = options.interval || 1000;\n  const minInterval = options.minInterval || 500;\n  const immediate = typeof options.immediate === 'boolean' ? options.immediate : false;\n  const clock = typeof options.clock === 'function' ? options.clock : now;\n\n  function wake() {\n    const currentTime = clock();\n    const timeSinceLastWake = currentTime - lastWakeTime;\n    const timeSinceLastCall = currentTime - lastCallTime;\n    const timeUntilNextCall = interval - timeSinceLastCall;\n    lastWakeTime = currentTime;\n\n    // For the streaming protocol: there is nothing obviously stopping this\n    // interval from being woken up again while we are waiting \"infinitely\"\n    // for `fn` to be called again`. Since the function effectively\n    // never completes, the `timeUntilNextCall` will continue to grow\n    // negatively unbounded, so it will never trigger a reschedule here.\n\n    // debounce multiple calls to wake within the `minInterval`\n    if (timeSinceLastWake < minInterval) {\n      return;\n    }\n\n    // reschedule a call as soon as possible, ensuring the call never happens\n    // faster than the `minInterval`\n    if (timeUntilNextCall > minInterval) {\n      reschedule(minInterval);\n    }\n\n    // This is possible in virtualized environments like AWS Lambda where our\n    // clock is unreliable. In these cases the timer is \"running\" but never\n    // actually completes, so we want to execute immediately and then attempt\n    // to reschedule.\n    if (timeUntilNextCall < 0) {\n      executeAndReschedule();\n    }\n  }\n\n  function stop() {\n    stopped = true;\n    if (timerId) {\n      clearTimeout(timerId);\n      timerId = null;\n    }\n\n    lastCallTime = 0;\n    lastWakeTime = 0;\n  }\n\n  function reschedule(ms) {\n    if (stopped) return;\n    clearTimeout(timerId);\n    timerId = setTimeout(executeAndReschedule, ms || interval);\n  }\n\n  function executeAndReschedule() {\n    lastWakeTime = 0;\n    lastCallTime = clock();\n\n    fn(err => {\n      if (err) throw err;\n      reschedule(interval);\n    });\n  }\n\n  if (immediate) {\n    executeAndReschedule();\n  } else {\n    lastCallTime = clock();\n    reschedule();\n  }\n\n  return { wake, stop };\n}\n\nfunction hasAtomicOperators(doc) {\n  if (Array.isArray(doc)) {\n    return doc.reduce((err, u) => err || hasAtomicOperators(u), null);\n  }\n\n  const keys = Object.keys(doc);\n  return keys.length > 0 && keys[0][0] === '$';\n}\n\nmodule.exports = {\n  filterOptions,\n  mergeOptions,\n  translateOptions,\n  shallowClone,\n  getSingleProperty,\n  checkCollectionName,\n  toError,\n  formattedOrderClause,\n  parseIndexOptions,\n  normalizeHintField,\n  handleCallback,\n  decorateCommand,\n  isObject,\n  debugOptions,\n  MAX_JS_INT: Number.MAX_SAFE_INTEGER + 1,\n  mergeOptionsAndWriteConcern,\n  executeLegacyOperation,\n  applyRetryableWrites,\n  applyWriteConcern,\n  isPromiseLike,\n  decorateWithCollation,\n  decorateWithReadConcern,\n  deprecateOptions,\n  SUPPORTS,\n  MongoDBNamespace,\n  emitDeprecationWarning,\n  makeCounter,\n  maybePromise,\n  now,\n  calculateDurationInMs,\n  makeInterruptableAsyncInterval,\n  hasAtomicOperators\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}