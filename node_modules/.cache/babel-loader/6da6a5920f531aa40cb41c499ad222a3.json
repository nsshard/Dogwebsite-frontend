{"ast":null,"code":"'use strict';\n\nvar core = require('../core');\n\nvar crypto = require('crypto');\n\nvar stream = require('stream');\n\nvar util = require('util');\n\nvar Buffer = require('safe-buffer').Buffer;\n\nvar ERROR_NAMESPACE_NOT_FOUND = 26;\nmodule.exports = GridFSBucketWriteStream;\n/**\n * A writable stream that enables you to write buffers to GridFS.\n *\n * Do not instantiate this class directly. Use `openUploadStream()` instead.\n *\n * @class\n * @extends external:Writable\n * @param {GridFSBucket} bucket Handle for this stream's corresponding bucket\n * @param {string} filename The value of the 'filename' key in the files doc\n * @param {object} [options] Optional settings.\n * @param {string|number|object} [options.id] Custom file id for the GridFS file.\n * @param {number} [options.chunkSizeBytes] The chunk size to use, in bytes\n * @param {number} [options.w] The write concern\n * @param {number} [options.wtimeout] The write concern timeout\n * @param {number} [options.j] The journal write concern\n * @param {boolean} [options.disableMD5=false] If true, disables adding an md5 field to file data\n * @fires GridFSBucketWriteStream#error\n * @fires GridFSBucketWriteStream#finish\n */\n\nfunction GridFSBucketWriteStream(bucket, filename, options) {\n  options = options || {};\n  this.bucket = bucket;\n  this.chunks = bucket.s._chunksCollection;\n  this.filename = filename;\n  this.files = bucket.s._filesCollection;\n  this.options = options; // Signals the write is all done\n\n  this.done = false;\n  this.id = options.id ? options.id : core.BSON.ObjectId();\n  this.chunkSizeBytes = this.options.chunkSizeBytes;\n  this.bufToStore = Buffer.alloc(this.chunkSizeBytes);\n  this.length = 0;\n  this.md5 = !options.disableMD5 && crypto.createHash('md5');\n  this.n = 0;\n  this.pos = 0;\n  this.state = {\n    streamEnd: false,\n    outstandingRequests: 0,\n    errored: false,\n    aborted: false,\n    promiseLibrary: this.bucket.s.promiseLibrary\n  };\n\n  if (!this.bucket.s.calledOpenUploadStream) {\n    this.bucket.s.calledOpenUploadStream = true;\n\n    var _this = this;\n\n    checkIndexes(this, function () {\n      _this.bucket.s.checkedIndexes = true;\n\n      _this.bucket.emit('index');\n    });\n  }\n}\n\nutil.inherits(GridFSBucketWriteStream, stream.Writable);\n/**\n * An error occurred\n *\n * @event GridFSBucketWriteStream#error\n * @type {Error}\n */\n\n/**\n * `end()` was called and the write stream successfully wrote the file\n * metadata and all the chunks to MongoDB.\n *\n * @event GridFSBucketWriteStream#finish\n * @type {object}\n */\n\n/**\n * Write a buffer to the stream.\n *\n * @method\n * @param {Buffer} chunk Buffer to write\n * @param {String} encoding Optional encoding for the buffer\n * @param {GridFSBucket~errorCallback} callback Function to call when the chunk was added to the buffer, or if the entire chunk was persisted to MongoDB if this chunk caused a flush.\n * @return {Boolean} False if this write required flushing a chunk to MongoDB. True otherwise.\n */\n\nGridFSBucketWriteStream.prototype.write = function (chunk, encoding, callback) {\n  var _this = this;\n\n  return waitForIndexes(this, function () {\n    return doWrite(_this, chunk, encoding, callback);\n  });\n};\n/**\n * Places this write stream into an aborted state (all future writes fail)\n * and deletes all chunks that have already been written.\n *\n * @method\n * @param {GridFSBucket~errorCallback} callback called when chunks are successfully removed or error occurred\n * @return {Promise} if no callback specified\n */\n\n\nGridFSBucketWriteStream.prototype.abort = function (callback) {\n  if (this.state.streamEnd) {\n    var error = new Error('Cannot abort a stream that has already completed');\n\n    if (typeof callback === 'function') {\n      return callback(error);\n    }\n\n    return this.state.promiseLibrary.reject(error);\n  }\n\n  if (this.state.aborted) {\n    error = new Error('Cannot call abort() on a stream twice');\n\n    if (typeof callback === 'function') {\n      return callback(error);\n    }\n\n    return this.state.promiseLibrary.reject(error);\n  }\n\n  this.state.aborted = true;\n  this.chunks.deleteMany({\n    files_id: this.id\n  }, function (error) {\n    if (typeof callback === 'function') callback(error);\n  });\n};\n/**\n * Tells the stream that no more data will be coming in. The stream will\n * persist the remaining data to MongoDB, write the files document, and\n * then emit a 'finish' event.\n *\n * @method\n * @param {Buffer} chunk Buffer to write\n * @param {String} encoding Optional encoding for the buffer\n * @param {GridFSBucket~errorCallback} callback Function to call when all files and chunks have been persisted to MongoDB\n */\n\n\nGridFSBucketWriteStream.prototype.end = function (chunk, encoding, callback) {\n  var _this = this;\n\n  if (typeof chunk === 'function') {\n    callback = chunk, chunk = null, encoding = null;\n  } else if (typeof encoding === 'function') {\n    callback = encoding, encoding = null;\n  }\n\n  if (checkAborted(this, callback)) {\n    return;\n  }\n\n  this.state.streamEnd = true;\n\n  if (callback) {\n    this.once('finish', function (result) {\n      callback(null, result);\n    });\n  }\n\n  if (!chunk) {\n    waitForIndexes(this, function () {\n      writeRemnant(_this);\n    });\n    return;\n  }\n\n  this.write(chunk, encoding, function () {\n    writeRemnant(_this);\n  });\n};\n/**\n * @ignore\n */\n\n\nfunction __handleError(_this, error, callback) {\n  if (_this.state.errored) {\n    return;\n  }\n\n  _this.state.errored = true;\n\n  if (callback) {\n    return callback(error);\n  }\n\n  _this.emit('error', error);\n}\n/**\n * @ignore\n */\n\n\nfunction createChunkDoc(filesId, n, data) {\n  return {\n    _id: core.BSON.ObjectId(),\n    files_id: filesId,\n    n: n,\n    data: data\n  };\n}\n/**\n * @ignore\n */\n\n\nfunction checkChunksIndex(_this, callback) {\n  _this.chunks.listIndexes().toArray(function (error, indexes) {\n    if (error) {\n      // Collection doesn't exist so create index\n      if (error.code === ERROR_NAMESPACE_NOT_FOUND) {\n        var index = {\n          files_id: 1,\n          n: 1\n        };\n\n        _this.chunks.createIndex(index, {\n          background: false,\n          unique: true\n        }, function (error) {\n          if (error) {\n            return callback(error);\n          }\n\n          callback();\n        });\n\n        return;\n      }\n\n      return callback(error);\n    }\n\n    var hasChunksIndex = false;\n    indexes.forEach(function (index) {\n      if (index.key) {\n        var keys = Object.keys(index.key);\n\n        if (keys.length === 2 && index.key.files_id === 1 && index.key.n === 1) {\n          hasChunksIndex = true;\n        }\n      }\n    });\n\n    if (hasChunksIndex) {\n      callback();\n    } else {\n      index = {\n        files_id: 1,\n        n: 1\n      };\n      var indexOptions = getWriteOptions(_this);\n      indexOptions.background = false;\n      indexOptions.unique = true;\n\n      _this.chunks.createIndex(index, indexOptions, function (error) {\n        if (error) {\n          return callback(error);\n        }\n\n        callback();\n      });\n    }\n  });\n}\n/**\n * @ignore\n */\n\n\nfunction checkDone(_this, callback) {\n  if (_this.done) return true;\n\n  if (_this.state.streamEnd && _this.state.outstandingRequests === 0 && !_this.state.errored) {\n    // Set done so we dont' trigger duplicate createFilesDoc\n    _this.done = true; // Create a new files doc\n\n    var filesDoc = createFilesDoc(_this.id, _this.length, _this.chunkSizeBytes, _this.md5 && _this.md5.digest('hex'), _this.filename, _this.options.contentType, _this.options.aliases, _this.options.metadata);\n\n    if (checkAborted(_this, callback)) {\n      return false;\n    }\n\n    _this.files.insertOne(filesDoc, getWriteOptions(_this), function (error) {\n      if (error) {\n        return __handleError(_this, error, callback);\n      }\n\n      _this.emit('finish', filesDoc);\n    });\n\n    return true;\n  }\n\n  return false;\n}\n/**\n * @ignore\n */\n\n\nfunction checkIndexes(_this, callback) {\n  _this.files.findOne({}, {\n    _id: 1\n  }, function (error, doc) {\n    if (error) {\n      return callback(error);\n    }\n\n    if (doc) {\n      return callback();\n    }\n\n    _this.files.listIndexes().toArray(function (error, indexes) {\n      if (error) {\n        // Collection doesn't exist so create index\n        if (error.code === ERROR_NAMESPACE_NOT_FOUND) {\n          var index = {\n            filename: 1,\n            uploadDate: 1\n          };\n\n          _this.files.createIndex(index, {\n            background: false\n          }, function (error) {\n            if (error) {\n              return callback(error);\n            }\n\n            checkChunksIndex(_this, callback);\n          });\n\n          return;\n        }\n\n        return callback(error);\n      }\n\n      var hasFileIndex = false;\n      indexes.forEach(function (index) {\n        var keys = Object.keys(index.key);\n\n        if (keys.length === 2 && index.key.filename === 1 && index.key.uploadDate === 1) {\n          hasFileIndex = true;\n        }\n      });\n\n      if (hasFileIndex) {\n        checkChunksIndex(_this, callback);\n      } else {\n        index = {\n          filename: 1,\n          uploadDate: 1\n        };\n        var indexOptions = getWriteOptions(_this);\n        indexOptions.background = false;\n\n        _this.files.createIndex(index, indexOptions, function (error) {\n          if (error) {\n            return callback(error);\n          }\n\n          checkChunksIndex(_this, callback);\n        });\n      }\n    });\n  });\n}\n/**\n * @ignore\n */\n\n\nfunction createFilesDoc(_id, length, chunkSize, md5, filename, contentType, aliases, metadata) {\n  var ret = {\n    _id: _id,\n    length: length,\n    chunkSize: chunkSize,\n    uploadDate: new Date(),\n    filename: filename\n  };\n\n  if (md5) {\n    ret.md5 = md5;\n  }\n\n  if (contentType) {\n    ret.contentType = contentType;\n  }\n\n  if (aliases) {\n    ret.aliases = aliases;\n  }\n\n  if (metadata) {\n    ret.metadata = metadata;\n  }\n\n  return ret;\n}\n/**\n * @ignore\n */\n\n\nfunction doWrite(_this, chunk, encoding, callback) {\n  if (checkAborted(_this, callback)) {\n    return false;\n  }\n\n  var inputBuf = Buffer.isBuffer(chunk) ? chunk : Buffer.from(chunk, encoding);\n  _this.length += inputBuf.length; // Input is small enough to fit in our buffer\n\n  if (_this.pos + inputBuf.length < _this.chunkSizeBytes) {\n    inputBuf.copy(_this.bufToStore, _this.pos);\n    _this.pos += inputBuf.length;\n    callback && callback(); // Note that we reverse the typical semantics of write's return value\n    // to be compatible with node's `.pipe()` function.\n    // True means client can keep writing.\n\n    return true;\n  } // Otherwise, buffer is too big for current chunk, so we need to flush\n  // to MongoDB.\n\n\n  var inputBufRemaining = inputBuf.length;\n  var spaceRemaining = _this.chunkSizeBytes - _this.pos;\n  var numToCopy = Math.min(spaceRemaining, inputBuf.length);\n  var outstandingRequests = 0;\n\n  while (inputBufRemaining > 0) {\n    var inputBufPos = inputBuf.length - inputBufRemaining;\n    inputBuf.copy(_this.bufToStore, _this.pos, inputBufPos, inputBufPos + numToCopy);\n    _this.pos += numToCopy;\n    spaceRemaining -= numToCopy;\n\n    if (spaceRemaining === 0) {\n      if (_this.md5) {\n        _this.md5.update(_this.bufToStore);\n      }\n\n      var doc = createChunkDoc(_this.id, _this.n, Buffer.from(_this.bufToStore));\n      ++_this.state.outstandingRequests;\n      ++outstandingRequests;\n\n      if (checkAborted(_this, callback)) {\n        return false;\n      }\n\n      _this.chunks.insertOne(doc, getWriteOptions(_this), function (error) {\n        if (error) {\n          return __handleError(_this, error);\n        }\n\n        --_this.state.outstandingRequests;\n        --outstandingRequests;\n\n        if (!outstandingRequests) {\n          _this.emit('drain', doc);\n\n          callback && callback();\n          checkDone(_this);\n        }\n      });\n\n      spaceRemaining = _this.chunkSizeBytes;\n      _this.pos = 0;\n      ++_this.n;\n    }\n\n    inputBufRemaining -= numToCopy;\n    numToCopy = Math.min(spaceRemaining, inputBufRemaining);\n  } // Note that we reverse the typical semantics of write's return value\n  // to be compatible with node's `.pipe()` function.\n  // False means the client should wait for the 'drain' event.\n\n\n  return false;\n}\n/**\n * @ignore\n */\n\n\nfunction getWriteOptions(_this) {\n  var obj = {};\n\n  if (_this.options.writeConcern) {\n    obj.w = _this.options.writeConcern.w;\n    obj.wtimeout = _this.options.writeConcern.wtimeout;\n    obj.j = _this.options.writeConcern.j;\n  }\n\n  return obj;\n}\n/**\n * @ignore\n */\n\n\nfunction waitForIndexes(_this, callback) {\n  if (_this.bucket.s.checkedIndexes) {\n    return callback(false);\n  }\n\n  _this.bucket.once('index', function () {\n    callback(true);\n  });\n\n  return true;\n}\n/**\n * @ignore\n */\n\n\nfunction writeRemnant(_this, callback) {\n  // Buffer is empty, so don't bother to insert\n  if (_this.pos === 0) {\n    return checkDone(_this, callback);\n  }\n\n  ++_this.state.outstandingRequests; // Create a new buffer to make sure the buffer isn't bigger than it needs\n  // to be.\n\n  var remnant = Buffer.alloc(_this.pos);\n\n  _this.bufToStore.copy(remnant, 0, 0, _this.pos);\n\n  if (_this.md5) {\n    _this.md5.update(remnant);\n  }\n\n  var doc = createChunkDoc(_this.id, _this.n, remnant); // If the stream was aborted, do not write remnant\n\n  if (checkAborted(_this, callback)) {\n    return false;\n  }\n\n  _this.chunks.insertOne(doc, getWriteOptions(_this), function (error) {\n    if (error) {\n      return __handleError(_this, error);\n    }\n\n    --_this.state.outstandingRequests;\n    checkDone(_this);\n  });\n}\n/**\n * @ignore\n */\n\n\nfunction checkAborted(_this, callback) {\n  if (_this.state.aborted) {\n    if (typeof callback === 'function') {\n      callback(new Error('this stream has been aborted'));\n    }\n\n    return true;\n  }\n\n  return false;\n}","map":{"version":3,"names":["core","require","crypto","stream","util","Buffer","ERROR_NAMESPACE_NOT_FOUND","module","exports","GridFSBucketWriteStream","bucket","filename","options","chunks","s","_chunksCollection","files","_filesCollection","done","id","BSON","ObjectId","chunkSizeBytes","bufToStore","alloc","length","md5","disableMD5","createHash","n","pos","state","streamEnd","outstandingRequests","errored","aborted","promiseLibrary","calledOpenUploadStream","_this","checkIndexes","checkedIndexes","emit","inherits","Writable","prototype","write","chunk","encoding","callback","waitForIndexes","doWrite","abort","error","Error","reject","deleteMany","files_id","end","checkAborted","once","result","writeRemnant","__handleError","createChunkDoc","filesId","data","_id","checkChunksIndex","listIndexes","toArray","indexes","code","index","createIndex","background","unique","hasChunksIndex","forEach","key","keys","Object","indexOptions","getWriteOptions","checkDone","filesDoc","createFilesDoc","digest","contentType","aliases","metadata","insertOne","findOne","doc","uploadDate","hasFileIndex","chunkSize","ret","Date","inputBuf","isBuffer","from","copy","inputBufRemaining","spaceRemaining","numToCopy","Math","min","inputBufPos","update","obj","writeConcern","w","wtimeout","j","remnant"],"sources":["C:/Users/Administrator/Desktop/webAPI work/web/dog-website/node_modules/koa-mongo/node_modules/mongodb/lib/gridfs-stream/upload.js"],"sourcesContent":["'use strict';\n\nvar core = require('../core');\nvar crypto = require('crypto');\nvar stream = require('stream');\nvar util = require('util');\nvar Buffer = require('safe-buffer').Buffer;\n\nvar ERROR_NAMESPACE_NOT_FOUND = 26;\n\nmodule.exports = GridFSBucketWriteStream;\n\n/**\n * A writable stream that enables you to write buffers to GridFS.\n *\n * Do not instantiate this class directly. Use `openUploadStream()` instead.\n *\n * @class\n * @extends external:Writable\n * @param {GridFSBucket} bucket Handle for this stream's corresponding bucket\n * @param {string} filename The value of the 'filename' key in the files doc\n * @param {object} [options] Optional settings.\n * @param {string|number|object} [options.id] Custom file id for the GridFS file.\n * @param {number} [options.chunkSizeBytes] The chunk size to use, in bytes\n * @param {number} [options.w] The write concern\n * @param {number} [options.wtimeout] The write concern timeout\n * @param {number} [options.j] The journal write concern\n * @param {boolean} [options.disableMD5=false] If true, disables adding an md5 field to file data\n * @fires GridFSBucketWriteStream#error\n * @fires GridFSBucketWriteStream#finish\n */\n\nfunction GridFSBucketWriteStream(bucket, filename, options) {\n  options = options || {};\n  this.bucket = bucket;\n  this.chunks = bucket.s._chunksCollection;\n  this.filename = filename;\n  this.files = bucket.s._filesCollection;\n  this.options = options;\n  // Signals the write is all done\n  this.done = false;\n\n  this.id = options.id ? options.id : core.BSON.ObjectId();\n  this.chunkSizeBytes = this.options.chunkSizeBytes;\n  this.bufToStore = Buffer.alloc(this.chunkSizeBytes);\n  this.length = 0;\n  this.md5 = !options.disableMD5 && crypto.createHash('md5');\n  this.n = 0;\n  this.pos = 0;\n  this.state = {\n    streamEnd: false,\n    outstandingRequests: 0,\n    errored: false,\n    aborted: false,\n    promiseLibrary: this.bucket.s.promiseLibrary\n  };\n\n  if (!this.bucket.s.calledOpenUploadStream) {\n    this.bucket.s.calledOpenUploadStream = true;\n\n    var _this = this;\n    checkIndexes(this, function() {\n      _this.bucket.s.checkedIndexes = true;\n      _this.bucket.emit('index');\n    });\n  }\n}\n\nutil.inherits(GridFSBucketWriteStream, stream.Writable);\n\n/**\n * An error occurred\n *\n * @event GridFSBucketWriteStream#error\n * @type {Error}\n */\n\n/**\n * `end()` was called and the write stream successfully wrote the file\n * metadata and all the chunks to MongoDB.\n *\n * @event GridFSBucketWriteStream#finish\n * @type {object}\n */\n\n/**\n * Write a buffer to the stream.\n *\n * @method\n * @param {Buffer} chunk Buffer to write\n * @param {String} encoding Optional encoding for the buffer\n * @param {GridFSBucket~errorCallback} callback Function to call when the chunk was added to the buffer, or if the entire chunk was persisted to MongoDB if this chunk caused a flush.\n * @return {Boolean} False if this write required flushing a chunk to MongoDB. True otherwise.\n */\n\nGridFSBucketWriteStream.prototype.write = function(chunk, encoding, callback) {\n  var _this = this;\n  return waitForIndexes(this, function() {\n    return doWrite(_this, chunk, encoding, callback);\n  });\n};\n\n/**\n * Places this write stream into an aborted state (all future writes fail)\n * and deletes all chunks that have already been written.\n *\n * @method\n * @param {GridFSBucket~errorCallback} callback called when chunks are successfully removed or error occurred\n * @return {Promise} if no callback specified\n */\n\nGridFSBucketWriteStream.prototype.abort = function(callback) {\n  if (this.state.streamEnd) {\n    var error = new Error('Cannot abort a stream that has already completed');\n    if (typeof callback === 'function') {\n      return callback(error);\n    }\n    return this.state.promiseLibrary.reject(error);\n  }\n  if (this.state.aborted) {\n    error = new Error('Cannot call abort() on a stream twice');\n    if (typeof callback === 'function') {\n      return callback(error);\n    }\n    return this.state.promiseLibrary.reject(error);\n  }\n  this.state.aborted = true;\n  this.chunks.deleteMany({ files_id: this.id }, function(error) {\n    if (typeof callback === 'function') callback(error);\n  });\n};\n\n/**\n * Tells the stream that no more data will be coming in. The stream will\n * persist the remaining data to MongoDB, write the files document, and\n * then emit a 'finish' event.\n *\n * @method\n * @param {Buffer} chunk Buffer to write\n * @param {String} encoding Optional encoding for the buffer\n * @param {GridFSBucket~errorCallback} callback Function to call when all files and chunks have been persisted to MongoDB\n */\n\nGridFSBucketWriteStream.prototype.end = function(chunk, encoding, callback) {\n  var _this = this;\n  if (typeof chunk === 'function') {\n    (callback = chunk), (chunk = null), (encoding = null);\n  } else if (typeof encoding === 'function') {\n    (callback = encoding), (encoding = null);\n  }\n\n  if (checkAborted(this, callback)) {\n    return;\n  }\n  this.state.streamEnd = true;\n\n  if (callback) {\n    this.once('finish', function(result) {\n      callback(null, result);\n    });\n  }\n\n  if (!chunk) {\n    waitForIndexes(this, function() {\n      writeRemnant(_this);\n    });\n    return;\n  }\n\n  this.write(chunk, encoding, function() {\n    writeRemnant(_this);\n  });\n};\n\n/**\n * @ignore\n */\n\nfunction __handleError(_this, error, callback) {\n  if (_this.state.errored) {\n    return;\n  }\n  _this.state.errored = true;\n  if (callback) {\n    return callback(error);\n  }\n  _this.emit('error', error);\n}\n\n/**\n * @ignore\n */\n\nfunction createChunkDoc(filesId, n, data) {\n  return {\n    _id: core.BSON.ObjectId(),\n    files_id: filesId,\n    n: n,\n    data: data\n  };\n}\n\n/**\n * @ignore\n */\n\nfunction checkChunksIndex(_this, callback) {\n  _this.chunks.listIndexes().toArray(function(error, indexes) {\n    if (error) {\n      // Collection doesn't exist so create index\n      if (error.code === ERROR_NAMESPACE_NOT_FOUND) {\n        var index = { files_id: 1, n: 1 };\n        _this.chunks.createIndex(index, { background: false, unique: true }, function(error) {\n          if (error) {\n            return callback(error);\n          }\n\n          callback();\n        });\n        return;\n      }\n      return callback(error);\n    }\n\n    var hasChunksIndex = false;\n    indexes.forEach(function(index) {\n      if (index.key) {\n        var keys = Object.keys(index.key);\n        if (keys.length === 2 && index.key.files_id === 1 && index.key.n === 1) {\n          hasChunksIndex = true;\n        }\n      }\n    });\n\n    if (hasChunksIndex) {\n      callback();\n    } else {\n      index = { files_id: 1, n: 1 };\n      var indexOptions = getWriteOptions(_this);\n\n      indexOptions.background = false;\n      indexOptions.unique = true;\n\n      _this.chunks.createIndex(index, indexOptions, function(error) {\n        if (error) {\n          return callback(error);\n        }\n\n        callback();\n      });\n    }\n  });\n}\n\n/**\n * @ignore\n */\n\nfunction checkDone(_this, callback) {\n  if (_this.done) return true;\n  if (_this.state.streamEnd && _this.state.outstandingRequests === 0 && !_this.state.errored) {\n    // Set done so we dont' trigger duplicate createFilesDoc\n    _this.done = true;\n    // Create a new files doc\n    var filesDoc = createFilesDoc(\n      _this.id,\n      _this.length,\n      _this.chunkSizeBytes,\n      _this.md5 && _this.md5.digest('hex'),\n      _this.filename,\n      _this.options.contentType,\n      _this.options.aliases,\n      _this.options.metadata\n    );\n\n    if (checkAborted(_this, callback)) {\n      return false;\n    }\n\n    _this.files.insertOne(filesDoc, getWriteOptions(_this), function(error) {\n      if (error) {\n        return __handleError(_this, error, callback);\n      }\n      _this.emit('finish', filesDoc);\n    });\n\n    return true;\n  }\n\n  return false;\n}\n\n/**\n * @ignore\n */\n\nfunction checkIndexes(_this, callback) {\n  _this.files.findOne({}, { _id: 1 }, function(error, doc) {\n    if (error) {\n      return callback(error);\n    }\n    if (doc) {\n      return callback();\n    }\n\n    _this.files.listIndexes().toArray(function(error, indexes) {\n      if (error) {\n        // Collection doesn't exist so create index\n        if (error.code === ERROR_NAMESPACE_NOT_FOUND) {\n          var index = { filename: 1, uploadDate: 1 };\n          _this.files.createIndex(index, { background: false }, function(error) {\n            if (error) {\n              return callback(error);\n            }\n\n            checkChunksIndex(_this, callback);\n          });\n          return;\n        }\n        return callback(error);\n      }\n\n      var hasFileIndex = false;\n      indexes.forEach(function(index) {\n        var keys = Object.keys(index.key);\n        if (keys.length === 2 && index.key.filename === 1 && index.key.uploadDate === 1) {\n          hasFileIndex = true;\n        }\n      });\n\n      if (hasFileIndex) {\n        checkChunksIndex(_this, callback);\n      } else {\n        index = { filename: 1, uploadDate: 1 };\n\n        var indexOptions = getWriteOptions(_this);\n\n        indexOptions.background = false;\n\n        _this.files.createIndex(index, indexOptions, function(error) {\n          if (error) {\n            return callback(error);\n          }\n\n          checkChunksIndex(_this, callback);\n        });\n      }\n    });\n  });\n}\n\n/**\n * @ignore\n */\n\nfunction createFilesDoc(_id, length, chunkSize, md5, filename, contentType, aliases, metadata) {\n  var ret = {\n    _id: _id,\n    length: length,\n    chunkSize: chunkSize,\n    uploadDate: new Date(),\n    filename: filename\n  };\n\n  if (md5) {\n    ret.md5 = md5;\n  }\n\n  if (contentType) {\n    ret.contentType = contentType;\n  }\n\n  if (aliases) {\n    ret.aliases = aliases;\n  }\n\n  if (metadata) {\n    ret.metadata = metadata;\n  }\n\n  return ret;\n}\n\n/**\n * @ignore\n */\n\nfunction doWrite(_this, chunk, encoding, callback) {\n  if (checkAborted(_this, callback)) {\n    return false;\n  }\n\n  var inputBuf = Buffer.isBuffer(chunk) ? chunk : Buffer.from(chunk, encoding);\n\n  _this.length += inputBuf.length;\n\n  // Input is small enough to fit in our buffer\n  if (_this.pos + inputBuf.length < _this.chunkSizeBytes) {\n    inputBuf.copy(_this.bufToStore, _this.pos);\n    _this.pos += inputBuf.length;\n\n    callback && callback();\n\n    // Note that we reverse the typical semantics of write's return value\n    // to be compatible with node's `.pipe()` function.\n    // True means client can keep writing.\n    return true;\n  }\n\n  // Otherwise, buffer is too big for current chunk, so we need to flush\n  // to MongoDB.\n  var inputBufRemaining = inputBuf.length;\n  var spaceRemaining = _this.chunkSizeBytes - _this.pos;\n  var numToCopy = Math.min(spaceRemaining, inputBuf.length);\n  var outstandingRequests = 0;\n  while (inputBufRemaining > 0) {\n    var inputBufPos = inputBuf.length - inputBufRemaining;\n    inputBuf.copy(_this.bufToStore, _this.pos, inputBufPos, inputBufPos + numToCopy);\n    _this.pos += numToCopy;\n    spaceRemaining -= numToCopy;\n    if (spaceRemaining === 0) {\n      if (_this.md5) {\n        _this.md5.update(_this.bufToStore);\n      }\n      var doc = createChunkDoc(_this.id, _this.n, Buffer.from(_this.bufToStore));\n      ++_this.state.outstandingRequests;\n      ++outstandingRequests;\n\n      if (checkAborted(_this, callback)) {\n        return false;\n      }\n\n      _this.chunks.insertOne(doc, getWriteOptions(_this), function(error) {\n        if (error) {\n          return __handleError(_this, error);\n        }\n        --_this.state.outstandingRequests;\n        --outstandingRequests;\n\n        if (!outstandingRequests) {\n          _this.emit('drain', doc);\n          callback && callback();\n          checkDone(_this);\n        }\n      });\n\n      spaceRemaining = _this.chunkSizeBytes;\n      _this.pos = 0;\n      ++_this.n;\n    }\n    inputBufRemaining -= numToCopy;\n    numToCopy = Math.min(spaceRemaining, inputBufRemaining);\n  }\n\n  // Note that we reverse the typical semantics of write's return value\n  // to be compatible with node's `.pipe()` function.\n  // False means the client should wait for the 'drain' event.\n  return false;\n}\n\n/**\n * @ignore\n */\n\nfunction getWriteOptions(_this) {\n  var obj = {};\n  if (_this.options.writeConcern) {\n    obj.w = _this.options.writeConcern.w;\n    obj.wtimeout = _this.options.writeConcern.wtimeout;\n    obj.j = _this.options.writeConcern.j;\n  }\n  return obj;\n}\n\n/**\n * @ignore\n */\n\nfunction waitForIndexes(_this, callback) {\n  if (_this.bucket.s.checkedIndexes) {\n    return callback(false);\n  }\n\n  _this.bucket.once('index', function() {\n    callback(true);\n  });\n\n  return true;\n}\n\n/**\n * @ignore\n */\n\nfunction writeRemnant(_this, callback) {\n  // Buffer is empty, so don't bother to insert\n  if (_this.pos === 0) {\n    return checkDone(_this, callback);\n  }\n\n  ++_this.state.outstandingRequests;\n\n  // Create a new buffer to make sure the buffer isn't bigger than it needs\n  // to be.\n  var remnant = Buffer.alloc(_this.pos);\n  _this.bufToStore.copy(remnant, 0, 0, _this.pos);\n  if (_this.md5) {\n    _this.md5.update(remnant);\n  }\n  var doc = createChunkDoc(_this.id, _this.n, remnant);\n\n  // If the stream was aborted, do not write remnant\n  if (checkAborted(_this, callback)) {\n    return false;\n  }\n\n  _this.chunks.insertOne(doc, getWriteOptions(_this), function(error) {\n    if (error) {\n      return __handleError(_this, error);\n    }\n    --_this.state.outstandingRequests;\n    checkDone(_this);\n  });\n}\n\n/**\n * @ignore\n */\n\nfunction checkAborted(_this, callback) {\n  if (_this.state.aborted) {\n    if (typeof callback === 'function') {\n      callback(new Error('this stream has been aborted'));\n    }\n    return true;\n  }\n  return false;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}