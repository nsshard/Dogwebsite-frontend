{"ast":null,"code":"'use strict';\n\nconst Denque = require('denque');\n\nconst EventEmitter = require('events');\n\nconst isResumableError = require('./error').isResumableError;\n\nconst MongoError = require('./core').MongoError;\n\nconst Cursor = require('./cursor');\n\nconst relayEvents = require('./core/utils').relayEvents;\n\nconst maxWireVersion = require('./core/utils').maxWireVersion;\n\nconst maybePromise = require('./utils').maybePromise;\n\nconst now = require('./utils').now;\n\nconst calculateDurationInMs = require('./utils').calculateDurationInMs;\n\nconst AggregateOperation = require('./operations/aggregate');\n\nconst kResumeQueue = Symbol('resumeQueue');\nconst CHANGE_STREAM_OPTIONS = ['resumeAfter', 'startAfter', 'startAtOperationTime', 'fullDocument'];\nconst CURSOR_OPTIONS = ['batchSize', 'maxAwaitTimeMS', 'collation', 'readPreference'].concat(CHANGE_STREAM_OPTIONS);\nconst CHANGE_DOMAIN_TYPES = {\n  COLLECTION: Symbol('Collection'),\n  DATABASE: Symbol('Database'),\n  CLUSTER: Symbol('Cluster')\n};\n/**\n * @typedef ResumeToken\n * @description Represents the logical starting point for a new or resuming {@link ChangeStream} on the server.\n * @see https://docs.mongodb.com/master/changeStreams/#change-stream-resume-token\n */\n\n/**\n * @typedef OperationTime\n * @description Represents a specific point in time on a server. Can be retrieved by using {@link Db#command}\n * @see https://docs.mongodb.com/manual/reference/method/db.runCommand/#response\n */\n\n/**\n * @typedef ChangeStreamOptions\n * @description Options that can be passed to a ChangeStream. Note that startAfter, resumeAfter, and startAtOperationTime are all mutually exclusive, and the server will error if more than one is specified.\n * @property {string} [fullDocument='default'] Allowed values: ‘default’, ‘updateLookup’. When set to ‘updateLookup’, the change stream will include both a delta describing the changes to the document, as well as a copy of the entire document that was changed from some time after the change occurred.\n * @property {number} [maxAwaitTimeMS] The maximum amount of time for the server to wait on new documents to satisfy a change stream query.\n * @property {ResumeToken} [resumeAfter] Allows you to start a changeStream after a specified event. See {@link https://docs.mongodb.com/master/changeStreams/#resumeafter-for-change-streams|ChangeStream documentation}.\n * @property {ResumeToken} [startAfter] Similar to resumeAfter, but will allow you to start after an invalidated event. See {@link https://docs.mongodb.com/master/changeStreams/#startafter-for-change-streams|ChangeStream documentation}.\n * @property {OperationTime} [startAtOperationTime] Will start the changeStream after the specified operationTime.\n * @property {number} [batchSize=1000] The number of documents to return per batch. See {@link https://docs.mongodb.com/manual/reference/command/aggregate|aggregation documentation}.\n * @property {object} [collation] Specify collation settings for operation. See {@link https://docs.mongodb.com/manual/reference/command/aggregate|aggregation documentation}.\n * @property {ReadPreference} [readPreference] The read preference. Defaults to the read preference of the database or collection. See {@link https://docs.mongodb.com/manual/reference/read-preference|read preference documentation}.\n */\n\n/**\n * Creates a new Change Stream instance. Normally created using {@link Collection#watch|Collection.watch()}.\n * @class ChangeStream\n * @since 3.0.0\n * @param {(MongoClient|Db|Collection)} parent The parent object that created this change stream\n * @param {Array} pipeline An array of {@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline/|aggregation pipeline stages} through which to pass change stream documents\n * @param {ChangeStreamOptions} [options] Optional settings\n * @fires ChangeStream#close\n * @fires ChangeStream#change\n * @fires ChangeStream#end\n * @fires ChangeStream#error\n * @fires ChangeStream#resumeTokenChanged\n * @return {ChangeStream} a ChangeStream instance.\n */\n\nclass ChangeStream extends EventEmitter {\n  constructor(parent, pipeline, options) {\n    super();\n\n    const Collection = require('./collection');\n\n    const Db = require('./db');\n\n    const MongoClient = require('./mongo_client');\n\n    this.pipeline = pipeline || [];\n    this.options = options || {};\n    this.parent = parent;\n    this.namespace = parent.s.namespace;\n\n    if (parent instanceof Collection) {\n      this.type = CHANGE_DOMAIN_TYPES.COLLECTION;\n      this.topology = parent.s.db.serverConfig;\n    } else if (parent instanceof Db) {\n      this.type = CHANGE_DOMAIN_TYPES.DATABASE;\n      this.topology = parent.serverConfig;\n    } else if (parent instanceof MongoClient) {\n      this.type = CHANGE_DOMAIN_TYPES.CLUSTER;\n      this.topology = parent.topology;\n    } else {\n      throw new TypeError('parent provided to ChangeStream constructor is not an instance of Collection, Db, or MongoClient');\n    }\n\n    this.promiseLibrary = parent.s.promiseLibrary;\n\n    if (!this.options.readPreference && parent.s.readPreference) {\n      this.options.readPreference = parent.s.readPreference;\n    }\n\n    this[kResumeQueue] = new Denque(); // Create contained Change Stream cursor\n\n    this.cursor = createChangeStreamCursor(this, options);\n    this.closed = false; // Listen for any `change` listeners being added to ChangeStream\n\n    this.on('newListener', eventName => {\n      if (eventName === 'change' && this.cursor && this.listenerCount('change') === 0) {\n        this.cursor.on('data', change => processNewChange(this, change));\n      }\n    }); // Listen for all `change` listeners being removed from ChangeStream\n\n    this.on('removeListener', eventName => {\n      if (eventName === 'change' && this.listenerCount('change') === 0 && this.cursor) {\n        this.cursor.removeAllListeners('data');\n      }\n    });\n  }\n  /**\n   * @property {ResumeToken} resumeToken\n   * The cached resume token that will be used to resume\n   * after the most recently returned change.\n   */\n\n\n  get resumeToken() {\n    return this.cursor.resumeToken;\n  }\n  /**\n   * Check if there is any document still available in the Change Stream\n   * @function ChangeStream.prototype.hasNext\n   * @param {ChangeStream~resultCallback} [callback] The result callback.\n   * @throws {MongoError}\n   * @returns {Promise|void} returns Promise if no callback passed\n   */\n\n\n  hasNext(callback) {\n    return maybePromise(this.parent, callback, cb => {\n      getCursor(this, (err, cursor) => {\n        if (err) return cb(err); // failed to resume, raise an error\n\n        cursor.hasNext(cb);\n      });\n    });\n  }\n  /**\n   * Get the next available document from the Change Stream, returns null if no more documents are available.\n   * @function ChangeStream.prototype.next\n   * @param {ChangeStream~resultCallback} [callback] The result callback.\n   * @throws {MongoError}\n   * @returns {Promise|void} returns Promise if no callback passed\n   */\n\n\n  next(callback) {\n    return maybePromise(this.parent, callback, cb => {\n      getCursor(this, (err, cursor) => {\n        if (err) return cb(err); // failed to resume, raise an error\n\n        cursor.next((error, change) => {\n          if (error) {\n            this[kResumeQueue].push(() => this.next(cb));\n            processError(this, error, cb);\n            return;\n          }\n\n          processNewChange(this, change, cb);\n        });\n      });\n    });\n  }\n  /**\n   * Is the change stream closed\n   * @method ChangeStream.prototype.isClosed\n   * @return {boolean}\n   */\n\n\n  isClosed() {\n    return this.closed || this.cursor && this.cursor.isClosed();\n  }\n  /**\n   * Close the Change Stream\n   * @method ChangeStream.prototype.close\n   * @param {ChangeStream~resultCallback} [callback] The result callback.\n   * @return {Promise} returns Promise if no callback passed\n   */\n\n\n  close(callback) {\n    return maybePromise(this.parent, callback, cb => {\n      if (this.closed) return cb(); // flag the change stream as explicitly closed\n\n      this.closed = true;\n      if (!this.cursor) return cb(); // Tidy up the existing cursor\n\n      const cursor = this.cursor;\n      return cursor.close(err => {\n        ['data', 'close', 'end', 'error'].forEach(event => cursor.removeAllListeners(event));\n        this.cursor = undefined;\n        return cb(err);\n      });\n    });\n  }\n  /**\n   * This method pulls all the data out of a readable stream, and writes it to the supplied destination, automatically managing the flow so that the destination is not overwhelmed by a fast readable stream.\n   * @method\n   * @param {Writable} destination The destination for writing data\n   * @param {object} [options] {@link https://nodejs.org/api/stream.html#stream_readable_pipe_destination_options|Pipe options}\n   * @return {null}\n   */\n\n\n  pipe(destination, options) {\n    if (!this.pipeDestinations) {\n      this.pipeDestinations = [];\n    }\n\n    this.pipeDestinations.push(destination);\n    return this.cursor.pipe(destination, options);\n  }\n  /**\n   * This method will remove the hooks set up for a previous pipe() call.\n   * @param {Writable} [destination] The destination for writing data\n   * @return {null}\n   */\n\n\n  unpipe(destination) {\n    if (this.pipeDestinations && this.pipeDestinations.indexOf(destination) > -1) {\n      this.pipeDestinations.splice(this.pipeDestinations.indexOf(destination), 1);\n    }\n\n    return this.cursor.unpipe(destination);\n  }\n  /**\n   * Return a modified Readable stream including a possible transform method.\n   * @method\n   * @param {object} [options] Optional settings.\n   * @param {function} [options.transform] A transformation method applied to each document emitted by the stream.\n   * @return {Cursor}\n   */\n\n\n  stream(options) {\n    this.streamOptions = options;\n    return this.cursor.stream(options);\n  }\n  /**\n   * This method will cause a stream in flowing mode to stop emitting data events. Any data that becomes available will remain in the internal buffer.\n   * @return {null}\n   */\n\n\n  pause() {\n    return this.cursor.pause();\n  }\n  /**\n   * This method will cause the readable stream to resume emitting data events.\n   * @return {null}\n   */\n\n\n  resume() {\n    return this.cursor.resume();\n  }\n\n}\n\nclass ChangeStreamCursor extends Cursor {\n  constructor(topology, operation, options) {\n    super(topology, operation, options);\n    options = options || {};\n    this._resumeToken = null;\n    this.startAtOperationTime = options.startAtOperationTime;\n\n    if (options.startAfter) {\n      this.resumeToken = options.startAfter;\n    } else if (options.resumeAfter) {\n      this.resumeToken = options.resumeAfter;\n    }\n  }\n\n  set resumeToken(token) {\n    this._resumeToken = token;\n    this.emit('resumeTokenChanged', token);\n  }\n\n  get resumeToken() {\n    return this._resumeToken;\n  }\n\n  get resumeOptions() {\n    const result = {};\n\n    for (const optionName of CURSOR_OPTIONS) {\n      if (this.options[optionName]) result[optionName] = this.options[optionName];\n    }\n\n    if (this.resumeToken || this.startAtOperationTime) {\n      ['resumeAfter', 'startAfter', 'startAtOperationTime'].forEach(key => delete result[key]);\n\n      if (this.resumeToken) {\n        const resumeKey = this.options.startAfter && !this.hasReceived ? 'startAfter' : 'resumeAfter';\n        result[resumeKey] = this.resumeToken;\n      } else if (this.startAtOperationTime && maxWireVersion(this.server) >= 7) {\n        result.startAtOperationTime = this.startAtOperationTime;\n      }\n    }\n\n    return result;\n  }\n\n  cacheResumeToken(resumeToken) {\n    if (this.bufferedCount() === 0 && this.cursorState.postBatchResumeToken) {\n      this.resumeToken = this.cursorState.postBatchResumeToken;\n    } else {\n      this.resumeToken = resumeToken;\n    }\n\n    this.hasReceived = true;\n  }\n\n  _processBatch(batchName, response) {\n    const cursor = response.cursor;\n\n    if (cursor.postBatchResumeToken) {\n      this.cursorState.postBatchResumeToken = cursor.postBatchResumeToken;\n\n      if (cursor[batchName].length === 0) {\n        this.resumeToken = cursor.postBatchResumeToken;\n      }\n    }\n  }\n\n  _initializeCursor(callback) {\n    super._initializeCursor((err, result) => {\n      if (err || result == null) {\n        callback(err, result);\n        return;\n      }\n\n      const response = result.documents[0];\n\n      if (this.startAtOperationTime == null && this.resumeAfter == null && this.startAfter == null && maxWireVersion(this.server) >= 7) {\n        this.startAtOperationTime = response.operationTime;\n      }\n\n      this._processBatch('firstBatch', response);\n\n      this.emit('init', result);\n      this.emit('response');\n      callback(err, result);\n    });\n  }\n\n  _getMore(callback) {\n    super._getMore((err, response) => {\n      if (err) {\n        callback(err);\n        return;\n      }\n\n      this._processBatch('nextBatch', response);\n\n      this.emit('more', response);\n      this.emit('response');\n      callback(err, response);\n    });\n  }\n\n}\n/**\n * @event ChangeStreamCursor#response\n * internal event DO NOT USE\n * @ignore\n */\n// Create a new change stream cursor based on self's configuration\n\n\nfunction createChangeStreamCursor(self, options) {\n  const changeStreamStageOptions = {\n    fullDocument: options.fullDocument || 'default'\n  };\n  applyKnownOptions(changeStreamStageOptions, options, CHANGE_STREAM_OPTIONS);\n\n  if (self.type === CHANGE_DOMAIN_TYPES.CLUSTER) {\n    changeStreamStageOptions.allChangesForCluster = true;\n  }\n\n  const pipeline = [{\n    $changeStream: changeStreamStageOptions\n  }].concat(self.pipeline);\n  const cursorOptions = applyKnownOptions({}, options, CURSOR_OPTIONS);\n  const changeStreamCursor = new ChangeStreamCursor(self.topology, new AggregateOperation(self.parent, pipeline, options), cursorOptions);\n  relayEvents(changeStreamCursor, self, ['resumeTokenChanged', 'end', 'close']);\n  /**\n   * Fired for each new matching change in the specified namespace. Attaching a `change`\n   * event listener to a Change Stream will switch the stream into flowing mode. Data will\n   * then be passed as soon as it is available.\n   *\n   * @event ChangeStream#change\n   * @type {object}\n   */\n\n  if (self.listenerCount('change') > 0) {\n    changeStreamCursor.on('data', function (change) {\n      processNewChange(self, change);\n    });\n  }\n  /**\n   * Change stream close event\n   *\n   * @event ChangeStream#close\n   * @type {null}\n   */\n\n  /**\n   * Change stream end event\n   *\n   * @event ChangeStream#end\n   * @type {null}\n   */\n\n  /**\n   * Emitted each time the change stream stores a new resume token.\n   *\n   * @event ChangeStream#resumeTokenChanged\n   * @type {ResumeToken}\n   */\n\n  /**\n   * Fired when the stream encounters an error.\n   *\n   * @event ChangeStream#error\n   * @type {Error}\n   */\n\n\n  changeStreamCursor.on('error', function (error) {\n    processError(self, error);\n  });\n\n  if (self.pipeDestinations) {\n    const cursorStream = changeStreamCursor.stream(self.streamOptions);\n\n    for (let pipeDestination of self.pipeDestinations) {\n      cursorStream.pipe(pipeDestination);\n    }\n  }\n\n  return changeStreamCursor;\n}\n\nfunction applyKnownOptions(target, source, optionNames) {\n  optionNames.forEach(name => {\n    if (source[name]) {\n      target[name] = source[name];\n    }\n  });\n  return target;\n} // This method performs a basic server selection loop, satisfying the requirements of\n// ChangeStream resumability until the new SDAM layer can be used.\n\n\nconst SELECTION_TIMEOUT = 30000;\n\nfunction waitForTopologyConnected(topology, options, callback) {\n  setTimeout(() => {\n    if (options && options.start == null) {\n      options.start = now();\n    }\n\n    const start = options.start || now();\n    const timeout = options.timeout || SELECTION_TIMEOUT;\n    const readPreference = options.readPreference;\n\n    if (topology.isConnected({\n      readPreference\n    })) {\n      return callback();\n    }\n\n    if (calculateDurationInMs(start) > timeout) {\n      return callback(new MongoError('Timed out waiting for connection'));\n    }\n\n    waitForTopologyConnected(topology, options, callback);\n  }, 500); // this is an arbitrary wait time to allow SDAM to transition\n}\n\nfunction processNewChange(changeStream, change, callback) {\n  const cursor = changeStream.cursor; // a null change means the cursor has been notified, implicitly closing the change stream\n\n  if (change == null) {\n    changeStream.closed = true;\n  }\n\n  if (changeStream.closed) {\n    if (callback) callback(new MongoError('ChangeStream is closed'));\n    return;\n  }\n\n  if (change && !change._id) {\n    const noResumeTokenError = new Error('A change stream document has been received that lacks a resume token (_id).');\n    if (!callback) return changeStream.emit('error', noResumeTokenError);\n    return callback(noResumeTokenError);\n  } // cache the resume token\n\n\n  cursor.cacheResumeToken(change._id); // wipe the startAtOperationTime if there was one so that there won't be a conflict\n  // between resumeToken and startAtOperationTime if we need to reconnect the cursor\n\n  changeStream.options.startAtOperationTime = undefined; // Return the change\n\n  if (!callback) return changeStream.emit('change', change);\n  return callback(undefined, change);\n}\n\nfunction processError(changeStream, error, callback) {\n  const topology = changeStream.topology;\n  const cursor = changeStream.cursor; // If the change stream has been closed explictly, do not process error.\n\n  if (changeStream.closed) {\n    if (callback) callback(new MongoError('ChangeStream is closed'));\n    return;\n  } // if the resume succeeds, continue with the new cursor\n\n\n  function resumeWithCursor(newCursor) {\n    changeStream.cursor = newCursor;\n    processResumeQueue(changeStream);\n  } // otherwise, raise an error and close the change stream\n\n\n  function unresumableError(err) {\n    if (!callback) {\n      changeStream.emit('error', err);\n      changeStream.emit('close');\n    }\n\n    processResumeQueue(changeStream, err);\n    changeStream.closed = true;\n  }\n\n  if (cursor && isResumableError(error, maxWireVersion(cursor.server))) {\n    changeStream.cursor = undefined; // stop listening to all events from old cursor\n\n    ['data', 'close', 'end', 'error'].forEach(event => cursor.removeAllListeners(event)); // close internal cursor, ignore errors\n\n    cursor.close();\n    waitForTopologyConnected(topology, {\n      readPreference: cursor.options.readPreference\n    }, err => {\n      // if the topology can't reconnect, close the stream\n      if (err) return unresumableError(err); // create a new cursor, preserving the old cursor's options\n\n      const newCursor = createChangeStreamCursor(changeStream, cursor.resumeOptions); // attempt to continue in emitter mode\n\n      if (!callback) return resumeWithCursor(newCursor); // attempt to continue in iterator mode\n\n      newCursor.hasNext(err => {\n        // if there's an error immediately after resuming, close the stream\n        if (err) return unresumableError(err);\n        resumeWithCursor(newCursor);\n      });\n    });\n    return;\n  }\n\n  if (!callback) return changeStream.emit('error', error);\n  return callback(error);\n}\n/**\n * Safely provides a cursor across resume attempts\n *\n * @param {ChangeStream} changeStream the parent ChangeStream\n * @param {function} callback gets the cursor or error\n * @param {ChangeStreamCursor} [oldCursor] when resuming from an error, carry over options from previous cursor\n */\n\n\nfunction getCursor(changeStream, callback) {\n  if (changeStream.isClosed()) {\n    callback(new MongoError('ChangeStream is closed.'));\n    return;\n  } // if a cursor exists and it is open, return it\n\n\n  if (changeStream.cursor) {\n    callback(undefined, changeStream.cursor);\n    return;\n  } // no cursor, queue callback until topology reconnects\n\n\n  changeStream[kResumeQueue].push(callback);\n}\n/**\n * Drain the resume queue when a new has become available\n *\n * @param {ChangeStream} changeStream the parent ChangeStream\n * @param {ChangeStreamCursor?} changeStream.cursor the new cursor\n * @param {Error} [err] error getting a new cursor\n */\n\n\nfunction processResumeQueue(changeStream, err) {\n  while (changeStream[kResumeQueue].length) {\n    const request = changeStream[kResumeQueue].pop();\n\n    if (changeStream.isClosed() && !err) {\n      request(new MongoError('Change Stream is not open.'));\n      return;\n    }\n\n    request(err, changeStream.cursor);\n  }\n}\n/**\n * The callback format for results\n * @callback ChangeStream~resultCallback\n * @param {MongoError} error An error instance representing the error during the execution.\n * @param {(object|null)} result The result object if the command was executed successfully.\n */\n\n\nmodule.exports = ChangeStream;","map":{"version":3,"names":["Denque","require","EventEmitter","isResumableError","MongoError","Cursor","relayEvents","maxWireVersion","maybePromise","now","calculateDurationInMs","AggregateOperation","kResumeQueue","Symbol","CHANGE_STREAM_OPTIONS","CURSOR_OPTIONS","concat","CHANGE_DOMAIN_TYPES","COLLECTION","DATABASE","CLUSTER","ChangeStream","constructor","parent","pipeline","options","Collection","Db","MongoClient","namespace","s","type","topology","db","serverConfig","TypeError","promiseLibrary","readPreference","cursor","createChangeStreamCursor","closed","on","eventName","listenerCount","change","processNewChange","removeAllListeners","resumeToken","hasNext","callback","cb","getCursor","err","next","error","push","processError","isClosed","close","forEach","event","undefined","pipe","destination","pipeDestinations","unpipe","indexOf","splice","stream","streamOptions","pause","resume","ChangeStreamCursor","operation","_resumeToken","startAtOperationTime","startAfter","resumeAfter","token","emit","resumeOptions","result","optionName","key","resumeKey","hasReceived","server","cacheResumeToken","bufferedCount","cursorState","postBatchResumeToken","_processBatch","batchName","response","length","_initializeCursor","documents","operationTime","_getMore","self","changeStreamStageOptions","fullDocument","applyKnownOptions","allChangesForCluster","$changeStream","cursorOptions","changeStreamCursor","cursorStream","pipeDestination","target","source","optionNames","name","SELECTION_TIMEOUT","waitForTopologyConnected","setTimeout","start","timeout","isConnected","changeStream","_id","noResumeTokenError","Error","resumeWithCursor","newCursor","processResumeQueue","unresumableError","request","pop","module","exports"],"sources":["C:/Users/Administrator/Desktop/webAPI work/web/dog-website/node_modules/koa-mongo/node_modules/mongodb/lib/change_stream.js"],"sourcesContent":["'use strict';\n\nconst Denque = require('denque');\nconst EventEmitter = require('events');\nconst isResumableError = require('./error').isResumableError;\nconst MongoError = require('./core').MongoError;\nconst Cursor = require('./cursor');\nconst relayEvents = require('./core/utils').relayEvents;\nconst maxWireVersion = require('./core/utils').maxWireVersion;\nconst maybePromise = require('./utils').maybePromise;\nconst now = require('./utils').now;\nconst calculateDurationInMs = require('./utils').calculateDurationInMs;\nconst AggregateOperation = require('./operations/aggregate');\n\nconst kResumeQueue = Symbol('resumeQueue');\n\nconst CHANGE_STREAM_OPTIONS = ['resumeAfter', 'startAfter', 'startAtOperationTime', 'fullDocument'];\nconst CURSOR_OPTIONS = ['batchSize', 'maxAwaitTimeMS', 'collation', 'readPreference'].concat(\n  CHANGE_STREAM_OPTIONS\n);\n\nconst CHANGE_DOMAIN_TYPES = {\n  COLLECTION: Symbol('Collection'),\n  DATABASE: Symbol('Database'),\n  CLUSTER: Symbol('Cluster')\n};\n\n/**\n * @typedef ResumeToken\n * @description Represents the logical starting point for a new or resuming {@link ChangeStream} on the server.\n * @see https://docs.mongodb.com/master/changeStreams/#change-stream-resume-token\n */\n\n/**\n * @typedef OperationTime\n * @description Represents a specific point in time on a server. Can be retrieved by using {@link Db#command}\n * @see https://docs.mongodb.com/manual/reference/method/db.runCommand/#response\n */\n\n/**\n * @typedef ChangeStreamOptions\n * @description Options that can be passed to a ChangeStream. Note that startAfter, resumeAfter, and startAtOperationTime are all mutually exclusive, and the server will error if more than one is specified.\n * @property {string} [fullDocument='default'] Allowed values: ‘default’, ‘updateLookup’. When set to ‘updateLookup’, the change stream will include both a delta describing the changes to the document, as well as a copy of the entire document that was changed from some time after the change occurred.\n * @property {number} [maxAwaitTimeMS] The maximum amount of time for the server to wait on new documents to satisfy a change stream query.\n * @property {ResumeToken} [resumeAfter] Allows you to start a changeStream after a specified event. See {@link https://docs.mongodb.com/master/changeStreams/#resumeafter-for-change-streams|ChangeStream documentation}.\n * @property {ResumeToken} [startAfter] Similar to resumeAfter, but will allow you to start after an invalidated event. See {@link https://docs.mongodb.com/master/changeStreams/#startafter-for-change-streams|ChangeStream documentation}.\n * @property {OperationTime} [startAtOperationTime] Will start the changeStream after the specified operationTime.\n * @property {number} [batchSize=1000] The number of documents to return per batch. See {@link https://docs.mongodb.com/manual/reference/command/aggregate|aggregation documentation}.\n * @property {object} [collation] Specify collation settings for operation. See {@link https://docs.mongodb.com/manual/reference/command/aggregate|aggregation documentation}.\n * @property {ReadPreference} [readPreference] The read preference. Defaults to the read preference of the database or collection. See {@link https://docs.mongodb.com/manual/reference/read-preference|read preference documentation}.\n */\n\n/**\n * Creates a new Change Stream instance. Normally created using {@link Collection#watch|Collection.watch()}.\n * @class ChangeStream\n * @since 3.0.0\n * @param {(MongoClient|Db|Collection)} parent The parent object that created this change stream\n * @param {Array} pipeline An array of {@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline/|aggregation pipeline stages} through which to pass change stream documents\n * @param {ChangeStreamOptions} [options] Optional settings\n * @fires ChangeStream#close\n * @fires ChangeStream#change\n * @fires ChangeStream#end\n * @fires ChangeStream#error\n * @fires ChangeStream#resumeTokenChanged\n * @return {ChangeStream} a ChangeStream instance.\n */\nclass ChangeStream extends EventEmitter {\n  constructor(parent, pipeline, options) {\n    super();\n    const Collection = require('./collection');\n    const Db = require('./db');\n    const MongoClient = require('./mongo_client');\n\n    this.pipeline = pipeline || [];\n    this.options = options || {};\n\n    this.parent = parent;\n    this.namespace = parent.s.namespace;\n    if (parent instanceof Collection) {\n      this.type = CHANGE_DOMAIN_TYPES.COLLECTION;\n      this.topology = parent.s.db.serverConfig;\n    } else if (parent instanceof Db) {\n      this.type = CHANGE_DOMAIN_TYPES.DATABASE;\n      this.topology = parent.serverConfig;\n    } else if (parent instanceof MongoClient) {\n      this.type = CHANGE_DOMAIN_TYPES.CLUSTER;\n      this.topology = parent.topology;\n    } else {\n      throw new TypeError(\n        'parent provided to ChangeStream constructor is not an instance of Collection, Db, or MongoClient'\n      );\n    }\n\n    this.promiseLibrary = parent.s.promiseLibrary;\n    if (!this.options.readPreference && parent.s.readPreference) {\n      this.options.readPreference = parent.s.readPreference;\n    }\n\n    this[kResumeQueue] = new Denque();\n\n    // Create contained Change Stream cursor\n    this.cursor = createChangeStreamCursor(this, options);\n\n    this.closed = false;\n\n    // Listen for any `change` listeners being added to ChangeStream\n    this.on('newListener', eventName => {\n      if (eventName === 'change' && this.cursor && this.listenerCount('change') === 0) {\n        this.cursor.on('data', change => processNewChange(this, change));\n      }\n    });\n\n    // Listen for all `change` listeners being removed from ChangeStream\n    this.on('removeListener', eventName => {\n      if (eventName === 'change' && this.listenerCount('change') === 0 && this.cursor) {\n        this.cursor.removeAllListeners('data');\n      }\n    });\n  }\n\n  /**\n   * @property {ResumeToken} resumeToken\n   * The cached resume token that will be used to resume\n   * after the most recently returned change.\n   */\n  get resumeToken() {\n    return this.cursor.resumeToken;\n  }\n\n  /**\n   * Check if there is any document still available in the Change Stream\n   * @function ChangeStream.prototype.hasNext\n   * @param {ChangeStream~resultCallback} [callback] The result callback.\n   * @throws {MongoError}\n   * @returns {Promise|void} returns Promise if no callback passed\n   */\n  hasNext(callback) {\n    return maybePromise(this.parent, callback, cb => {\n      getCursor(this, (err, cursor) => {\n        if (err) return cb(err); // failed to resume, raise an error\n        cursor.hasNext(cb);\n      });\n    });\n  }\n\n  /**\n   * Get the next available document from the Change Stream, returns null if no more documents are available.\n   * @function ChangeStream.prototype.next\n   * @param {ChangeStream~resultCallback} [callback] The result callback.\n   * @throws {MongoError}\n   * @returns {Promise|void} returns Promise if no callback passed\n   */\n  next(callback) {\n    return maybePromise(this.parent, callback, cb => {\n      getCursor(this, (err, cursor) => {\n        if (err) return cb(err); // failed to resume, raise an error\n        cursor.next((error, change) => {\n          if (error) {\n            this[kResumeQueue].push(() => this.next(cb));\n            processError(this, error, cb);\n            return;\n          }\n          processNewChange(this, change, cb);\n        });\n      });\n    });\n  }\n\n  /**\n   * Is the change stream closed\n   * @method ChangeStream.prototype.isClosed\n   * @return {boolean}\n   */\n  isClosed() {\n    return this.closed || (this.cursor && this.cursor.isClosed());\n  }\n\n  /**\n   * Close the Change Stream\n   * @method ChangeStream.prototype.close\n   * @param {ChangeStream~resultCallback} [callback] The result callback.\n   * @return {Promise} returns Promise if no callback passed\n   */\n  close(callback) {\n    return maybePromise(this.parent, callback, cb => {\n      if (this.closed) return cb();\n\n      // flag the change stream as explicitly closed\n      this.closed = true;\n\n      if (!this.cursor) return cb();\n\n      // Tidy up the existing cursor\n      const cursor = this.cursor;\n\n      return cursor.close(err => {\n        ['data', 'close', 'end', 'error'].forEach(event => cursor.removeAllListeners(event));\n        this.cursor = undefined;\n\n        return cb(err);\n      });\n    });\n  }\n\n  /**\n   * This method pulls all the data out of a readable stream, and writes it to the supplied destination, automatically managing the flow so that the destination is not overwhelmed by a fast readable stream.\n   * @method\n   * @param {Writable} destination The destination for writing data\n   * @param {object} [options] {@link https://nodejs.org/api/stream.html#stream_readable_pipe_destination_options|Pipe options}\n   * @return {null}\n   */\n  pipe(destination, options) {\n    if (!this.pipeDestinations) {\n      this.pipeDestinations = [];\n    }\n    this.pipeDestinations.push(destination);\n    return this.cursor.pipe(destination, options);\n  }\n\n  /**\n   * This method will remove the hooks set up for a previous pipe() call.\n   * @param {Writable} [destination] The destination for writing data\n   * @return {null}\n   */\n  unpipe(destination) {\n    if (this.pipeDestinations && this.pipeDestinations.indexOf(destination) > -1) {\n      this.pipeDestinations.splice(this.pipeDestinations.indexOf(destination), 1);\n    }\n    return this.cursor.unpipe(destination);\n  }\n\n  /**\n   * Return a modified Readable stream including a possible transform method.\n   * @method\n   * @param {object} [options] Optional settings.\n   * @param {function} [options.transform] A transformation method applied to each document emitted by the stream.\n   * @return {Cursor}\n   */\n  stream(options) {\n    this.streamOptions = options;\n    return this.cursor.stream(options);\n  }\n\n  /**\n   * This method will cause a stream in flowing mode to stop emitting data events. Any data that becomes available will remain in the internal buffer.\n   * @return {null}\n   */\n  pause() {\n    return this.cursor.pause();\n  }\n\n  /**\n   * This method will cause the readable stream to resume emitting data events.\n   * @return {null}\n   */\n  resume() {\n    return this.cursor.resume();\n  }\n}\n\nclass ChangeStreamCursor extends Cursor {\n  constructor(topology, operation, options) {\n    super(topology, operation, options);\n\n    options = options || {};\n    this._resumeToken = null;\n    this.startAtOperationTime = options.startAtOperationTime;\n\n    if (options.startAfter) {\n      this.resumeToken = options.startAfter;\n    } else if (options.resumeAfter) {\n      this.resumeToken = options.resumeAfter;\n    }\n  }\n\n  set resumeToken(token) {\n    this._resumeToken = token;\n    this.emit('resumeTokenChanged', token);\n  }\n\n  get resumeToken() {\n    return this._resumeToken;\n  }\n\n  get resumeOptions() {\n    const result = {};\n    for (const optionName of CURSOR_OPTIONS) {\n      if (this.options[optionName]) result[optionName] = this.options[optionName];\n    }\n\n    if (this.resumeToken || this.startAtOperationTime) {\n      ['resumeAfter', 'startAfter', 'startAtOperationTime'].forEach(key => delete result[key]);\n\n      if (this.resumeToken) {\n        const resumeKey =\n          this.options.startAfter && !this.hasReceived ? 'startAfter' : 'resumeAfter';\n        result[resumeKey] = this.resumeToken;\n      } else if (this.startAtOperationTime && maxWireVersion(this.server) >= 7) {\n        result.startAtOperationTime = this.startAtOperationTime;\n      }\n    }\n\n    return result;\n  }\n\n  cacheResumeToken(resumeToken) {\n    if (this.bufferedCount() === 0 && this.cursorState.postBatchResumeToken) {\n      this.resumeToken = this.cursorState.postBatchResumeToken;\n    } else {\n      this.resumeToken = resumeToken;\n    }\n    this.hasReceived = true;\n  }\n\n  _processBatch(batchName, response) {\n    const cursor = response.cursor;\n    if (cursor.postBatchResumeToken) {\n      this.cursorState.postBatchResumeToken = cursor.postBatchResumeToken;\n\n      if (cursor[batchName].length === 0) {\n        this.resumeToken = cursor.postBatchResumeToken;\n      }\n    }\n  }\n\n  _initializeCursor(callback) {\n    super._initializeCursor((err, result) => {\n      if (err || result == null) {\n        callback(err, result);\n        return;\n      }\n\n      const response = result.documents[0];\n\n      if (\n        this.startAtOperationTime == null &&\n        this.resumeAfter == null &&\n        this.startAfter == null &&\n        maxWireVersion(this.server) >= 7\n      ) {\n        this.startAtOperationTime = response.operationTime;\n      }\n\n      this._processBatch('firstBatch', response);\n\n      this.emit('init', result);\n      this.emit('response');\n      callback(err, result);\n    });\n  }\n\n  _getMore(callback) {\n    super._getMore((err, response) => {\n      if (err) {\n        callback(err);\n        return;\n      }\n\n      this._processBatch('nextBatch', response);\n\n      this.emit('more', response);\n      this.emit('response');\n      callback(err, response);\n    });\n  }\n}\n\n/**\n * @event ChangeStreamCursor#response\n * internal event DO NOT USE\n * @ignore\n */\n\n// Create a new change stream cursor based on self's configuration\nfunction createChangeStreamCursor(self, options) {\n  const changeStreamStageOptions = { fullDocument: options.fullDocument || 'default' };\n  applyKnownOptions(changeStreamStageOptions, options, CHANGE_STREAM_OPTIONS);\n  if (self.type === CHANGE_DOMAIN_TYPES.CLUSTER) {\n    changeStreamStageOptions.allChangesForCluster = true;\n  }\n\n  const pipeline = [{ $changeStream: changeStreamStageOptions }].concat(self.pipeline);\n  const cursorOptions = applyKnownOptions({}, options, CURSOR_OPTIONS);\n\n  const changeStreamCursor = new ChangeStreamCursor(\n    self.topology,\n    new AggregateOperation(self.parent, pipeline, options),\n    cursorOptions\n  );\n\n  relayEvents(changeStreamCursor, self, ['resumeTokenChanged', 'end', 'close']);\n\n  /**\n   * Fired for each new matching change in the specified namespace. Attaching a `change`\n   * event listener to a Change Stream will switch the stream into flowing mode. Data will\n   * then be passed as soon as it is available.\n   *\n   * @event ChangeStream#change\n   * @type {object}\n   */\n  if (self.listenerCount('change') > 0) {\n    changeStreamCursor.on('data', function(change) {\n      processNewChange(self, change);\n    });\n  }\n\n  /**\n   * Change stream close event\n   *\n   * @event ChangeStream#close\n   * @type {null}\n   */\n\n  /**\n   * Change stream end event\n   *\n   * @event ChangeStream#end\n   * @type {null}\n   */\n\n  /**\n   * Emitted each time the change stream stores a new resume token.\n   *\n   * @event ChangeStream#resumeTokenChanged\n   * @type {ResumeToken}\n   */\n\n  /**\n   * Fired when the stream encounters an error.\n   *\n   * @event ChangeStream#error\n   * @type {Error}\n   */\n  changeStreamCursor.on('error', function(error) {\n    processError(self, error);\n  });\n\n  if (self.pipeDestinations) {\n    const cursorStream = changeStreamCursor.stream(self.streamOptions);\n    for (let pipeDestination of self.pipeDestinations) {\n      cursorStream.pipe(pipeDestination);\n    }\n  }\n\n  return changeStreamCursor;\n}\n\nfunction applyKnownOptions(target, source, optionNames) {\n  optionNames.forEach(name => {\n    if (source[name]) {\n      target[name] = source[name];\n    }\n  });\n\n  return target;\n}\n\n// This method performs a basic server selection loop, satisfying the requirements of\n// ChangeStream resumability until the new SDAM layer can be used.\nconst SELECTION_TIMEOUT = 30000;\nfunction waitForTopologyConnected(topology, options, callback) {\n  setTimeout(() => {\n    if (options && options.start == null) {\n      options.start = now();\n    }\n\n    const start = options.start || now();\n    const timeout = options.timeout || SELECTION_TIMEOUT;\n    const readPreference = options.readPreference;\n    if (topology.isConnected({ readPreference })) {\n      return callback();\n    }\n\n    if (calculateDurationInMs(start) > timeout) {\n      return callback(new MongoError('Timed out waiting for connection'));\n    }\n\n    waitForTopologyConnected(topology, options, callback);\n  }, 500); // this is an arbitrary wait time to allow SDAM to transition\n}\n\nfunction processNewChange(changeStream, change, callback) {\n  const cursor = changeStream.cursor;\n\n  // a null change means the cursor has been notified, implicitly closing the change stream\n  if (change == null) {\n    changeStream.closed = true;\n  }\n\n  if (changeStream.closed) {\n    if (callback) callback(new MongoError('ChangeStream is closed'));\n    return;\n  }\n\n  if (change && !change._id) {\n    const noResumeTokenError = new Error(\n      'A change stream document has been received that lacks a resume token (_id).'\n    );\n\n    if (!callback) return changeStream.emit('error', noResumeTokenError);\n    return callback(noResumeTokenError);\n  }\n\n  // cache the resume token\n  cursor.cacheResumeToken(change._id);\n\n  // wipe the startAtOperationTime if there was one so that there won't be a conflict\n  // between resumeToken and startAtOperationTime if we need to reconnect the cursor\n  changeStream.options.startAtOperationTime = undefined;\n\n  // Return the change\n  if (!callback) return changeStream.emit('change', change);\n  return callback(undefined, change);\n}\n\nfunction processError(changeStream, error, callback) {\n  const topology = changeStream.topology;\n  const cursor = changeStream.cursor;\n\n  // If the change stream has been closed explictly, do not process error.\n  if (changeStream.closed) {\n    if (callback) callback(new MongoError('ChangeStream is closed'));\n    return;\n  }\n\n  // if the resume succeeds, continue with the new cursor\n  function resumeWithCursor(newCursor) {\n    changeStream.cursor = newCursor;\n    processResumeQueue(changeStream);\n  }\n\n  // otherwise, raise an error and close the change stream\n  function unresumableError(err) {\n    if (!callback) {\n      changeStream.emit('error', err);\n      changeStream.emit('close');\n    }\n    processResumeQueue(changeStream, err);\n    changeStream.closed = true;\n  }\n\n  if (cursor && isResumableError(error, maxWireVersion(cursor.server))) {\n    changeStream.cursor = undefined;\n\n    // stop listening to all events from old cursor\n    ['data', 'close', 'end', 'error'].forEach(event => cursor.removeAllListeners(event));\n\n    // close internal cursor, ignore errors\n    cursor.close();\n\n    waitForTopologyConnected(topology, { readPreference: cursor.options.readPreference }, err => {\n      // if the topology can't reconnect, close the stream\n      if (err) return unresumableError(err);\n\n      // create a new cursor, preserving the old cursor's options\n      const newCursor = createChangeStreamCursor(changeStream, cursor.resumeOptions);\n\n      // attempt to continue in emitter mode\n      if (!callback) return resumeWithCursor(newCursor);\n\n      // attempt to continue in iterator mode\n      newCursor.hasNext(err => {\n        // if there's an error immediately after resuming, close the stream\n        if (err) return unresumableError(err);\n        resumeWithCursor(newCursor);\n      });\n    });\n    return;\n  }\n\n  if (!callback) return changeStream.emit('error', error);\n  return callback(error);\n}\n\n/**\n * Safely provides a cursor across resume attempts\n *\n * @param {ChangeStream} changeStream the parent ChangeStream\n * @param {function} callback gets the cursor or error\n * @param {ChangeStreamCursor} [oldCursor] when resuming from an error, carry over options from previous cursor\n */\nfunction getCursor(changeStream, callback) {\n  if (changeStream.isClosed()) {\n    callback(new MongoError('ChangeStream is closed.'));\n    return;\n  }\n\n  // if a cursor exists and it is open, return it\n  if (changeStream.cursor) {\n    callback(undefined, changeStream.cursor);\n    return;\n  }\n\n  // no cursor, queue callback until topology reconnects\n  changeStream[kResumeQueue].push(callback);\n}\n\n/**\n * Drain the resume queue when a new has become available\n *\n * @param {ChangeStream} changeStream the parent ChangeStream\n * @param {ChangeStreamCursor?} changeStream.cursor the new cursor\n * @param {Error} [err] error getting a new cursor\n */\nfunction processResumeQueue(changeStream, err) {\n  while (changeStream[kResumeQueue].length) {\n    const request = changeStream[kResumeQueue].pop();\n    if (changeStream.isClosed() && !err) {\n      request(new MongoError('Change Stream is not open.'));\n      return;\n    }\n    request(err, changeStream.cursor);\n  }\n}\n\n/**\n * The callback format for results\n * @callback ChangeStream~resultCallback\n * @param {MongoError} error An error instance representing the error during the execution.\n * @param {(object|null)} result The result object if the command was executed successfully.\n */\n\nmodule.exports = ChangeStream;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}