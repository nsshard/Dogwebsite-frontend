{"ast":null,"code":"const {\n  pathToRegexp,\n  compile,\n  parse\n} = require('path-to-regexp');\n\nconst {\n  parse: parseUrl,\n  format: formatUrl\n} = require('url');\n\nmodule.exports = Layer;\n/**\n * Initialize a new routing Layer with given `method`, `path`, and `middleware`.\n *\n * @param {String|RegExp} path Path string or regular expression.\n * @param {Array} methods Array of HTTP verbs.\n * @param {Array} middleware Layer callback/middleware or series of.\n * @param {Object=} opts\n * @param {String=} opts.name route name\n * @param {String=} opts.sensitive case sensitive (default: false)\n * @param {String=} opts.strict require the trailing slash (default: false)\n * @returns {Layer}\n * @private\n */\n\nfunction Layer(path, methods, middleware, opts) {\n  this.opts = opts || {};\n  this.name = this.opts.name || null;\n  this.methods = [];\n  this.paramNames = [];\n  this.stack = Array.isArray(middleware) ? middleware : [middleware];\n\n  for (let i = 0; i < methods.length; i++) {\n    const l = this.methods.push(methods[i].toUpperCase());\n    if (this.methods[l - 1] === 'GET') this.methods.unshift('HEAD');\n  } // ensure middleware is a function\n\n\n  for (let i = 0; i < this.stack.length; i++) {\n    const fn = this.stack[i];\n    const type = typeof fn;\n    if (type !== 'function') throw new Error(`${methods.toString()} \\`${this.opts.name || path}\\`: \\`middleware\\` must be a function, not \\`${type}\\``);\n  }\n\n  this.path = path;\n  this.regexp = pathToRegexp(path, this.paramNames, this.opts);\n}\n\n;\n/**\n * Returns whether request `path` matches route.\n *\n * @param {String} path\n * @returns {Boolean}\n * @private\n */\n\nLayer.prototype.match = function (path) {\n  return this.regexp.test(path);\n};\n/**\n * Returns map of URL parameters for given `path` and `paramNames`.\n *\n * @param {String} path\n * @param {Array.<String>} captures\n * @param {Object=} existingParams\n * @returns {Object}\n * @private\n */\n\n\nLayer.prototype.params = function (path, captures, existingParams) {\n  const params = existingParams || {};\n\n  for (let len = captures.length, i = 0; i < len; i++) {\n    if (this.paramNames[i]) {\n      const c = captures[i];\n      if (c && c.length !== 0) params[this.paramNames[i].name] = c ? safeDecodeURIComponent(c) : c;\n    }\n  }\n\n  return params;\n};\n/**\n * Returns array of regexp url path captures.\n *\n * @param {String} path\n * @returns {Array.<String>}\n * @private\n */\n\n\nLayer.prototype.captures = function (path) {\n  return this.opts.ignoreCaptures ? [] : path.match(this.regexp).slice(1);\n};\n/**\n * Generate URL for route using given `params`.\n *\n * @example\n *\n * ```javascript\n * const route = new Layer('/users/:id', ['GET'], fn);\n *\n * route.url({ id: 123 }); // => \"/users/123\"\n * ```\n *\n * @param {Object} params url parameters\n * @returns {String}\n * @private\n */\n\n\nLayer.prototype.url = function (params, options) {\n  let args = params;\n  const url = this.path.replace(/\\(\\.\\*\\)/g, '');\n\n  if (typeof params != 'object') {\n    args = Array.prototype.slice.call(arguments);\n\n    if (typeof args[args.length - 1] == 'object') {\n      options = args[args.length - 1];\n      args = args.slice(0, args.length - 1);\n    }\n  }\n\n  const toPath = compile(url, options);\n  let replaced;\n  const tokens = parse(url);\n  let replace = {};\n\n  if (args instanceof Array) {\n    for (let len = tokens.length, i = 0, j = 0; i < len; i++) {\n      if (tokens[i].name) replace[tokens[i].name] = args[j++];\n    }\n  } else if (tokens.some(token => token.name)) {\n    replace = params;\n  } else if (!options) {\n    options = params;\n  }\n\n  replaced = toPath(replace);\n\n  if (options && options.query) {\n    replaced = parseUrl(replaced);\n\n    if (typeof options.query === 'string') {\n      replaced.search = options.query;\n    } else {\n      replaced.search = undefined;\n      replaced.query = options.query;\n    }\n\n    return formatUrl(replaced);\n  }\n\n  return replaced;\n};\n/**\n * Run validations on route named parameters.\n *\n * @example\n *\n * ```javascript\n * router\n *   .param('user', function (id, ctx, next) {\n *     ctx.user = users[id];\n *     if (!user) return ctx.status = 404;\n *     next();\n *   })\n *   .get('/users/:user', function (ctx, next) {\n *     ctx.body = ctx.user;\n *   });\n * ```\n *\n * @param {String} param\n * @param {Function} middleware\n * @returns {Layer}\n * @private\n */\n\n\nLayer.prototype.param = function (param, fn) {\n  const stack = this.stack;\n  const params = this.paramNames;\n\n  const middleware = function (ctx, next) {\n    return fn.call(this, ctx.params[param], ctx, next);\n  };\n\n  middleware.param = param;\n  const names = params.map(function (p) {\n    return p.name;\n  });\n  const x = names.indexOf(param);\n\n  if (x > -1) {\n    // iterate through the stack, to figure out where to place the handler fn\n    stack.some(function (fn, i) {\n      // param handlers are always first, so when we find an fn w/o a param property, stop here\n      // if the param handler at this part of the stack comes after the one we are adding, stop here\n      if (!fn.param || names.indexOf(fn.param) > x) {\n        // inject this param handler right before the current item\n        stack.splice(i, 0, middleware);\n        return true; // then break the loop\n      }\n    });\n  }\n\n  return this;\n};\n/**\n * Prefix route path.\n *\n * @param {String} prefix\n * @returns {Layer}\n * @private\n */\n\n\nLayer.prototype.setPrefix = function (prefix) {\n  if (this.path) {\n    this.path = this.path !== '/' || this.opts.strict === true ? `${prefix}${this.path}` : prefix;\n    this.paramNames = [];\n    this.regexp = pathToRegexp(this.path, this.paramNames, this.opts);\n  }\n\n  return this;\n};\n/**\n * Safe decodeURIComponent, won't throw any error.\n * If `decodeURIComponent` error happen, just return the original value.\n *\n * @param {String} text\n * @returns {String} URL decode original string.\n * @private\n */\n\n\nfunction safeDecodeURIComponent(text) {\n  try {\n    return decodeURIComponent(text);\n  } catch (e) {\n    return text;\n  }\n}","map":{"version":3,"names":["pathToRegexp","compile","parse","require","parseUrl","format","formatUrl","module","exports","Layer","path","methods","middleware","opts","name","paramNames","stack","Array","isArray","i","length","l","push","toUpperCase","unshift","fn","type","Error","toString","regexp","prototype","match","test","params","captures","existingParams","len","c","safeDecodeURIComponent","ignoreCaptures","slice","url","options","args","replace","call","arguments","toPath","replaced","tokens","j","some","token","query","search","undefined","param","ctx","next","names","map","p","x","indexOf","splice","setPrefix","prefix","strict","text","decodeURIComponent","e"],"sources":["C:/Users/Administrator/Desktop/webAPI work/web/dog-website/node_modules/koa-router/lib/layer.js"],"sourcesContent":["const { pathToRegexp, compile, parse } = require('path-to-regexp');\nconst { parse: parseUrl, format: formatUrl } = require('url');\n\nmodule.exports = Layer;\n\n/**\n * Initialize a new routing Layer with given `method`, `path`, and `middleware`.\n *\n * @param {String|RegExp} path Path string or regular expression.\n * @param {Array} methods Array of HTTP verbs.\n * @param {Array} middleware Layer callback/middleware or series of.\n * @param {Object=} opts\n * @param {String=} opts.name route name\n * @param {String=} opts.sensitive case sensitive (default: false)\n * @param {String=} opts.strict require the trailing slash (default: false)\n * @returns {Layer}\n * @private\n */\n\nfunction Layer(path, methods, middleware, opts) {\n  this.opts = opts || {};\n  this.name = this.opts.name || null;\n  this.methods = [];\n  this.paramNames = [];\n  this.stack = Array.isArray(middleware) ? middleware : [middleware];\n\n  for (let i = 0; i < methods.length; i++) {\n    const l = this.methods.push(methods[i].toUpperCase());\n    if (this.methods[l - 1] === 'GET') this.methods.unshift('HEAD');\n  }\n\n  // ensure middleware is a function\n  for (let i = 0; i < this.stack.length; i++) {\n    const fn = this.stack[i];\n    const type = (typeof fn);\n    if (type !== 'function')\n      throw new Error(\n        `${methods.toString()} \\`${this.opts.name || path}\\`: \\`middleware\\` must be a function, not \\`${type}\\``\n      );\n  }\n\n  this.path = path;\n  this.regexp = pathToRegexp(path, this.paramNames, this.opts);\n};\n\n/**\n * Returns whether request `path` matches route.\n *\n * @param {String} path\n * @returns {Boolean}\n * @private\n */\n\nLayer.prototype.match = function (path) {\n  return this.regexp.test(path);\n};\n\n/**\n * Returns map of URL parameters for given `path` and `paramNames`.\n *\n * @param {String} path\n * @param {Array.<String>} captures\n * @param {Object=} existingParams\n * @returns {Object}\n * @private\n */\n\nLayer.prototype.params = function (path, captures, existingParams) {\n  const params = existingParams || {};\n\n  for (let len = captures.length, i = 0; i < len; i++) {\n    if (this.paramNames[i]) {\n      const c = captures[i];\n      if (c && c.length !== 0) params[this.paramNames[i].name] = c ? safeDecodeURIComponent(c) : c;\n    }\n  }\n\n  return params;\n};\n\n/**\n * Returns array of regexp url path captures.\n *\n * @param {String} path\n * @returns {Array.<String>}\n * @private\n */\n\nLayer.prototype.captures = function (path) {\n  return this.opts.ignoreCaptures ? [] : path.match(this.regexp).slice(1);\n};\n\n/**\n * Generate URL for route using given `params`.\n *\n * @example\n *\n * ```javascript\n * const route = new Layer('/users/:id', ['GET'], fn);\n *\n * route.url({ id: 123 }); // => \"/users/123\"\n * ```\n *\n * @param {Object} params url parameters\n * @returns {String}\n * @private\n */\n\nLayer.prototype.url = function (params, options) {\n  let args = params;\n  const url = this.path.replace(/\\(\\.\\*\\)/g, '');\n\n  if (typeof params != 'object') {\n    args = Array.prototype.slice.call(arguments);\n    if (typeof args[args.length - 1] == 'object') {\n      options = args[args.length - 1];\n      args = args.slice(0, args.length - 1);\n    }\n  }\n\n  const toPath = compile(url, options);\n  let replaced;\n\n  const tokens = parse(url);\n  let replace = {};\n\n  if (args instanceof Array) {\n    for (let len = tokens.length, i = 0, j = 0; i < len; i++) {\n      if (tokens[i].name) replace[tokens[i].name] = args[j++];\n    }\n  } else if (tokens.some(token => token.name)) {\n    replace = params;\n  } else if (!options) {\n    options = params;\n  }\n\n  replaced = toPath(replace);\n\n  if (options && options.query) {\n    replaced = parseUrl(replaced);\n    if (typeof options.query === 'string') {\n      replaced.search = options.query;\n    } else {\n      replaced.search = undefined;\n      replaced.query = options.query;\n    }\n    return formatUrl(replaced);\n  }\n\n  return replaced;\n};\n\n/**\n * Run validations on route named parameters.\n *\n * @example\n *\n * ```javascript\n * router\n *   .param('user', function (id, ctx, next) {\n *     ctx.user = users[id];\n *     if (!user) return ctx.status = 404;\n *     next();\n *   })\n *   .get('/users/:user', function (ctx, next) {\n *     ctx.body = ctx.user;\n *   });\n * ```\n *\n * @param {String} param\n * @param {Function} middleware\n * @returns {Layer}\n * @private\n */\n\nLayer.prototype.param = function (param, fn) {\n  const stack = this.stack;\n  const params = this.paramNames;\n  const middleware = function (ctx, next) {\n    return fn.call(this, ctx.params[param], ctx, next);\n  };\n  middleware.param = param;\n\n  const names = params.map(function (p) {\n    return p.name;\n  });\n\n  const x = names.indexOf(param);\n  if (x > -1) {\n    // iterate through the stack, to figure out where to place the handler fn\n    stack.some(function (fn, i) {\n      // param handlers are always first, so when we find an fn w/o a param property, stop here\n      // if the param handler at this part of the stack comes after the one we are adding, stop here\n      if (!fn.param || names.indexOf(fn.param) > x) {\n        // inject this param handler right before the current item\n        stack.splice(i, 0, middleware);\n        return true; // then break the loop\n      }\n    });\n  }\n\n  return this;\n};\n\n/**\n * Prefix route path.\n *\n * @param {String} prefix\n * @returns {Layer}\n * @private\n */\n\nLayer.prototype.setPrefix = function (prefix) {\n  if (this.path) {\n    this.path = (this.path !== '/' || this.opts.strict === true) ? `${prefix}${this.path}` : prefix\n    this.paramNames = [];\n    this.regexp = pathToRegexp(this.path, this.paramNames, this.opts);\n  }\n\n  return this;\n};\n\n/**\n * Safe decodeURIComponent, won't throw any error.\n * If `decodeURIComponent` error happen, just return the original value.\n *\n * @param {String} text\n * @returns {String} URL decode original string.\n * @private\n */\n\nfunction safeDecodeURIComponent(text) {\n  try {\n    return decodeURIComponent(text);\n  } catch (e) {\n    return text;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}