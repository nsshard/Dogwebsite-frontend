{"ast":null,"code":"'use strict';\n\nconst ServerType = require('./common').ServerType;\n\nconst EventEmitter = require('events');\n\nconst connect = require('../connection/connect');\n\nconst Connection = require('../../cmap/connection').Connection;\n\nconst common = require('./common');\n\nconst makeStateMachine = require('../utils').makeStateMachine;\n\nconst MongoNetworkError = require('../error').MongoNetworkError;\n\nconst BSON = require('../connection/utils').retrieveBSON();\n\nconst makeInterruptableAsyncInterval = require('../../utils').makeInterruptableAsyncInterval;\n\nconst calculateDurationInMs = require('../../utils').calculateDurationInMs;\n\nconst now = require('../../utils').now;\n\nconst sdamEvents = require('./events');\n\nconst ServerHeartbeatStartedEvent = sdamEvents.ServerHeartbeatStartedEvent;\nconst ServerHeartbeatSucceededEvent = sdamEvents.ServerHeartbeatSucceededEvent;\nconst ServerHeartbeatFailedEvent = sdamEvents.ServerHeartbeatFailedEvent;\nconst kServer = Symbol('server');\nconst kMonitorId = Symbol('monitorId');\nconst kConnection = Symbol('connection');\nconst kCancellationToken = Symbol('cancellationToken');\nconst kRTTPinger = Symbol('rttPinger');\nconst kRoundTripTime = Symbol('roundTripTime');\nconst STATE_CLOSED = common.STATE_CLOSED;\nconst STATE_CLOSING = common.STATE_CLOSING;\nconst STATE_IDLE = 'idle';\nconst STATE_MONITORING = 'monitoring';\nconst stateTransition = makeStateMachine({\n  [STATE_CLOSING]: [STATE_CLOSING, STATE_IDLE, STATE_CLOSED],\n  [STATE_CLOSED]: [STATE_CLOSED, STATE_MONITORING],\n  [STATE_IDLE]: [STATE_IDLE, STATE_MONITORING, STATE_CLOSING],\n  [STATE_MONITORING]: [STATE_MONITORING, STATE_IDLE, STATE_CLOSING]\n});\nconst INVALID_REQUEST_CHECK_STATES = new Set([STATE_CLOSING, STATE_CLOSED, STATE_MONITORING]);\n\nfunction isInCloseState(monitor) {\n  return monitor.s.state === STATE_CLOSED || monitor.s.state === STATE_CLOSING;\n}\n\nclass Monitor extends EventEmitter {\n  constructor(server, options) {\n    super(options);\n    this[kServer] = server;\n    this[kConnection] = undefined;\n    this[kCancellationToken] = new EventEmitter();\n    this[kCancellationToken].setMaxListeners(Infinity);\n    this[kMonitorId] = null;\n    this.s = {\n      state: STATE_CLOSED\n    };\n    this.address = server.description.address;\n    this.options = Object.freeze({\n      connectTimeoutMS: typeof options.connectionTimeout === 'number' ? options.connectionTimeout : typeof options.connectTimeoutMS === 'number' ? options.connectTimeoutMS : 10000,\n      heartbeatFrequencyMS: typeof options.heartbeatFrequencyMS === 'number' ? options.heartbeatFrequencyMS : 10000,\n      minHeartbeatFrequencyMS: typeof options.minHeartbeatFrequencyMS === 'number' ? options.minHeartbeatFrequencyMS : 500\n    }); // TODO: refactor this to pull it directly from the pool, requires new ConnectionPool integration\n\n    const connectOptions = Object.assign({\n      id: '<monitor>',\n      host: server.description.host,\n      port: server.description.port,\n      bson: server.s.bson,\n      connectionType: Connection\n    }, server.s.options, this.options, // force BSON serialization options\n    {\n      raw: false,\n      promoteLongs: true,\n      promoteValues: true,\n      promoteBuffers: true\n    }); // ensure no authentication is used for monitoring\n\n    delete connectOptions.credentials;\n    this.connectOptions = Object.freeze(connectOptions);\n  }\n\n  connect() {\n    if (this.s.state !== STATE_CLOSED) {\n      return;\n    } // start\n\n\n    const heartbeatFrequencyMS = this.options.heartbeatFrequencyMS;\n    const minHeartbeatFrequencyMS = this.options.minHeartbeatFrequencyMS;\n    this[kMonitorId] = makeInterruptableAsyncInterval(monitorServer(this), {\n      interval: heartbeatFrequencyMS,\n      minInterval: minHeartbeatFrequencyMS,\n      immediate: true\n    });\n  }\n\n  requestCheck() {\n    if (INVALID_REQUEST_CHECK_STATES.has(this.s.state)) {\n      return;\n    }\n\n    this[kMonitorId].wake();\n  }\n\n  reset() {\n    if (isInCloseState(this)) {\n      return;\n    }\n\n    stateTransition(this, STATE_CLOSING);\n    resetMonitorState(this); // restart monitor\n\n    stateTransition(this, STATE_IDLE); // restart monitoring\n\n    const heartbeatFrequencyMS = this.options.heartbeatFrequencyMS;\n    const minHeartbeatFrequencyMS = this.options.minHeartbeatFrequencyMS;\n    this[kMonitorId] = makeInterruptableAsyncInterval(monitorServer(this), {\n      interval: heartbeatFrequencyMS,\n      minInterval: minHeartbeatFrequencyMS\n    });\n  }\n\n  close() {\n    if (isInCloseState(this)) {\n      return;\n    }\n\n    stateTransition(this, STATE_CLOSING);\n    resetMonitorState(this); // close monitor\n\n    this.emit('close');\n    stateTransition(this, STATE_CLOSED);\n  }\n\n}\n\nfunction resetMonitorState(monitor) {\n  stateTransition(monitor, STATE_CLOSING);\n\n  if (monitor[kMonitorId]) {\n    monitor[kMonitorId].stop();\n    monitor[kMonitorId] = null;\n  }\n\n  if (monitor[kRTTPinger]) {\n    monitor[kRTTPinger].close();\n    monitor[kRTTPinger] = undefined;\n  }\n\n  monitor[kCancellationToken].emit('cancel');\n\n  if (monitor[kMonitorId]) {\n    clearTimeout(monitor[kMonitorId]);\n    monitor[kMonitorId] = undefined;\n  }\n\n  if (monitor[kConnection]) {\n    monitor[kConnection].destroy({\n      force: true\n    });\n  }\n}\n\nfunction checkServer(monitor, callback) {\n  let start = now();\n  monitor.emit('serverHeartbeatStarted', new ServerHeartbeatStartedEvent(monitor.address));\n\n  function failureHandler(err) {\n    if (monitor[kConnection]) {\n      monitor[kConnection].destroy({\n        force: true\n      });\n      monitor[kConnection] = undefined;\n    }\n\n    monitor.emit('serverHeartbeatFailed', new ServerHeartbeatFailedEvent(calculateDurationInMs(start), err, monitor.address));\n    monitor.emit('resetServer', err);\n    monitor.emit('resetConnectionPool');\n    callback(err);\n  }\n\n  if (monitor[kConnection] != null && !monitor[kConnection].closed) {\n    const connectTimeoutMS = monitor.options.connectTimeoutMS;\n    const maxAwaitTimeMS = monitor.options.heartbeatFrequencyMS;\n    const topologyVersion = monitor[kServer].description.topologyVersion;\n    const isAwaitable = topologyVersion != null;\n    const cmd = isAwaitable ? {\n      ismaster: true,\n      maxAwaitTimeMS,\n      topologyVersion: makeTopologyVersion(topologyVersion)\n    } : {\n      ismaster: true\n    };\n    const options = isAwaitable ? {\n      socketTimeout: connectTimeoutMS + maxAwaitTimeMS,\n      exhaustAllowed: true\n    } : {\n      socketTimeout: connectTimeoutMS\n    };\n\n    if (isAwaitable && monitor[kRTTPinger] == null) {\n      monitor[kRTTPinger] = new RTTPinger(monitor[kCancellationToken], monitor.connectOptions);\n    }\n\n    monitor[kConnection].command('admin.$cmd', cmd, options, (err, result) => {\n      if (err) {\n        failureHandler(err);\n        return;\n      }\n\n      const isMaster = result.result;\n      const duration = isAwaitable ? monitor[kRTTPinger].roundTripTime : calculateDurationInMs(start);\n      monitor.emit('serverHeartbeatSucceeded', new ServerHeartbeatSucceededEvent(duration, isMaster, monitor.address)); // if we are using the streaming protocol then we immediately issue another `started`\n      // event, otherwise the \"check\" is complete and return to the main monitor loop\n\n      if (isAwaitable && isMaster.topologyVersion) {\n        monitor.emit('serverHeartbeatStarted', new ServerHeartbeatStartedEvent(monitor.address));\n        start = now();\n      } else {\n        if (monitor[kRTTPinger]) {\n          monitor[kRTTPinger].close();\n          monitor[kRTTPinger] = undefined;\n        }\n\n        callback(undefined, isMaster);\n      }\n    });\n    return;\n  } // connecting does an implicit `ismaster`\n\n\n  connect(monitor.connectOptions, monitor[kCancellationToken], (err, conn) => {\n    if (conn && isInCloseState(monitor)) {\n      conn.destroy({\n        force: true\n      });\n      return;\n    }\n\n    if (err) {\n      monitor[kConnection] = undefined; // we already reset the connection pool on network errors in all cases\n\n      if (!(err instanceof MongoNetworkError)) {\n        monitor.emit('resetConnectionPool');\n      }\n\n      failureHandler(err);\n      return;\n    }\n\n    monitor[kConnection] = conn;\n    monitor.emit('serverHeartbeatSucceeded', new ServerHeartbeatSucceededEvent(calculateDurationInMs(start), conn.ismaster, monitor.address));\n    callback(undefined, conn.ismaster);\n  });\n}\n\nfunction monitorServer(monitor) {\n  return callback => {\n    stateTransition(monitor, STATE_MONITORING);\n\n    function done() {\n      if (!isInCloseState(monitor)) {\n        stateTransition(monitor, STATE_IDLE);\n      }\n\n      callback();\n    } // TODO: the next line is a legacy event, remove in v4\n\n\n    process.nextTick(() => monitor.emit('monitoring', monitor[kServer]));\n    checkServer(monitor, (err, isMaster) => {\n      if (err) {\n        // otherwise an error occured on initial discovery, also bail\n        if (monitor[kServer].description.type === ServerType.Unknown) {\n          monitor.emit('resetServer', err);\n          return done();\n        }\n      } // if the check indicates streaming is supported, immediately reschedule monitoring\n\n\n      if (isMaster && isMaster.topologyVersion) {\n        setTimeout(() => {\n          if (!isInCloseState(monitor)) {\n            monitor[kMonitorId].wake();\n          }\n        });\n      }\n\n      done();\n    });\n  };\n}\n\nfunction makeTopologyVersion(tv) {\n  return {\n    processId: tv.processId,\n    counter: BSON.Long.fromNumber(tv.counter)\n  };\n}\n\nclass RTTPinger {\n  constructor(cancellationToken, options) {\n    this[kConnection] = null;\n    this[kCancellationToken] = cancellationToken;\n    this[kRoundTripTime] = 0;\n    this.closed = false;\n    const heartbeatFrequencyMS = options.heartbeatFrequencyMS;\n    this[kMonitorId] = setTimeout(() => measureRoundTripTime(this, options), heartbeatFrequencyMS);\n  }\n\n  get roundTripTime() {\n    return this[kRoundTripTime];\n  }\n\n  close() {\n    this.closed = true;\n    clearTimeout(this[kMonitorId]);\n    this[kMonitorId] = undefined;\n\n    if (this[kConnection]) {\n      this[kConnection].destroy({\n        force: true\n      });\n    }\n  }\n\n}\n\nfunction measureRoundTripTime(rttPinger, options) {\n  const start = now();\n  const cancellationToken = rttPinger[kCancellationToken];\n  const heartbeatFrequencyMS = options.heartbeatFrequencyMS;\n\n  if (rttPinger.closed) {\n    return;\n  }\n\n  function measureAndReschedule(conn) {\n    if (rttPinger.closed) {\n      conn.destroy({\n        force: true\n      });\n      return;\n    }\n\n    if (rttPinger[kConnection] == null) {\n      rttPinger[kConnection] = conn;\n    }\n\n    rttPinger[kRoundTripTime] = calculateDurationInMs(start);\n    rttPinger[kMonitorId] = setTimeout(() => measureRoundTripTime(rttPinger, options), heartbeatFrequencyMS);\n  }\n\n  if (rttPinger[kConnection] == null) {\n    connect(options, cancellationToken, (err, conn) => {\n      if (err) {\n        rttPinger[kConnection] = undefined;\n        rttPinger[kRoundTripTime] = 0;\n        return;\n      }\n\n      measureAndReschedule(conn);\n    });\n    return;\n  }\n\n  rttPinger[kConnection].command('admin.$cmd', {\n    ismaster: 1\n  }, err => {\n    if (err) {\n      rttPinger[kConnection] = undefined;\n      rttPinger[kRoundTripTime] = 0;\n      return;\n    }\n\n    measureAndReschedule();\n  });\n}\n\nmodule.exports = {\n  Monitor\n};","map":{"version":3,"names":["ServerType","require","EventEmitter","connect","Connection","common","makeStateMachine","MongoNetworkError","BSON","retrieveBSON","makeInterruptableAsyncInterval","calculateDurationInMs","now","sdamEvents","ServerHeartbeatStartedEvent","ServerHeartbeatSucceededEvent","ServerHeartbeatFailedEvent","kServer","Symbol","kMonitorId","kConnection","kCancellationToken","kRTTPinger","kRoundTripTime","STATE_CLOSED","STATE_CLOSING","STATE_IDLE","STATE_MONITORING","stateTransition","INVALID_REQUEST_CHECK_STATES","Set","isInCloseState","monitor","s","state","Monitor","constructor","server","options","undefined","setMaxListeners","Infinity","address","description","Object","freeze","connectTimeoutMS","connectionTimeout","heartbeatFrequencyMS","minHeartbeatFrequencyMS","connectOptions","assign","id","host","port","bson","connectionType","raw","promoteLongs","promoteValues","promoteBuffers","credentials","monitorServer","interval","minInterval","immediate","requestCheck","has","wake","reset","resetMonitorState","close","emit","stop","clearTimeout","destroy","force","checkServer","callback","start","failureHandler","err","closed","maxAwaitTimeMS","topologyVersion","isAwaitable","cmd","ismaster","makeTopologyVersion","socketTimeout","exhaustAllowed","RTTPinger","command","result","isMaster","duration","roundTripTime","conn","done","process","nextTick","type","Unknown","setTimeout","tv","processId","counter","Long","fromNumber","cancellationToken","measureRoundTripTime","rttPinger","measureAndReschedule","module","exports"],"sources":["C:/Users/Administrator/Desktop/webAPI work/web/dog-website/node_modules/koa-mongo/node_modules/mongodb/lib/core/sdam/monitor.js"],"sourcesContent":["'use strict';\n\nconst ServerType = require('./common').ServerType;\nconst EventEmitter = require('events');\nconst connect = require('../connection/connect');\nconst Connection = require('../../cmap/connection').Connection;\nconst common = require('./common');\nconst makeStateMachine = require('../utils').makeStateMachine;\nconst MongoNetworkError = require('../error').MongoNetworkError;\nconst BSON = require('../connection/utils').retrieveBSON();\nconst makeInterruptableAsyncInterval = require('../../utils').makeInterruptableAsyncInterval;\nconst calculateDurationInMs = require('../../utils').calculateDurationInMs;\nconst now = require('../../utils').now;\n\nconst sdamEvents = require('./events');\nconst ServerHeartbeatStartedEvent = sdamEvents.ServerHeartbeatStartedEvent;\nconst ServerHeartbeatSucceededEvent = sdamEvents.ServerHeartbeatSucceededEvent;\nconst ServerHeartbeatFailedEvent = sdamEvents.ServerHeartbeatFailedEvent;\n\nconst kServer = Symbol('server');\nconst kMonitorId = Symbol('monitorId');\nconst kConnection = Symbol('connection');\nconst kCancellationToken = Symbol('cancellationToken');\nconst kRTTPinger = Symbol('rttPinger');\nconst kRoundTripTime = Symbol('roundTripTime');\n\nconst STATE_CLOSED = common.STATE_CLOSED;\nconst STATE_CLOSING = common.STATE_CLOSING;\nconst STATE_IDLE = 'idle';\nconst STATE_MONITORING = 'monitoring';\nconst stateTransition = makeStateMachine({\n  [STATE_CLOSING]: [STATE_CLOSING, STATE_IDLE, STATE_CLOSED],\n  [STATE_CLOSED]: [STATE_CLOSED, STATE_MONITORING],\n  [STATE_IDLE]: [STATE_IDLE, STATE_MONITORING, STATE_CLOSING],\n  [STATE_MONITORING]: [STATE_MONITORING, STATE_IDLE, STATE_CLOSING]\n});\n\nconst INVALID_REQUEST_CHECK_STATES = new Set([STATE_CLOSING, STATE_CLOSED, STATE_MONITORING]);\n\nfunction isInCloseState(monitor) {\n  return monitor.s.state === STATE_CLOSED || monitor.s.state === STATE_CLOSING;\n}\n\nclass Monitor extends EventEmitter {\n  constructor(server, options) {\n    super(options);\n\n    this[kServer] = server;\n    this[kConnection] = undefined;\n    this[kCancellationToken] = new EventEmitter();\n    this[kCancellationToken].setMaxListeners(Infinity);\n    this[kMonitorId] = null;\n    this.s = {\n      state: STATE_CLOSED\n    };\n\n    this.address = server.description.address;\n    this.options = Object.freeze({\n      connectTimeoutMS:\n        typeof options.connectionTimeout === 'number'\n          ? options.connectionTimeout\n          : typeof options.connectTimeoutMS === 'number'\n          ? options.connectTimeoutMS\n          : 10000,\n      heartbeatFrequencyMS:\n        typeof options.heartbeatFrequencyMS === 'number' ? options.heartbeatFrequencyMS : 10000,\n      minHeartbeatFrequencyMS:\n        typeof options.minHeartbeatFrequencyMS === 'number' ? options.minHeartbeatFrequencyMS : 500\n    });\n\n    // TODO: refactor this to pull it directly from the pool, requires new ConnectionPool integration\n    const connectOptions = Object.assign(\n      {\n        id: '<monitor>',\n        host: server.description.host,\n        port: server.description.port,\n        bson: server.s.bson,\n        connectionType: Connection\n      },\n      server.s.options,\n      this.options,\n\n      // force BSON serialization options\n      {\n        raw: false,\n        promoteLongs: true,\n        promoteValues: true,\n        promoteBuffers: true\n      }\n    );\n\n    // ensure no authentication is used for monitoring\n    delete connectOptions.credentials;\n    this.connectOptions = Object.freeze(connectOptions);\n  }\n\n  connect() {\n    if (this.s.state !== STATE_CLOSED) {\n      return;\n    }\n\n    // start\n    const heartbeatFrequencyMS = this.options.heartbeatFrequencyMS;\n    const minHeartbeatFrequencyMS = this.options.minHeartbeatFrequencyMS;\n    this[kMonitorId] = makeInterruptableAsyncInterval(monitorServer(this), {\n      interval: heartbeatFrequencyMS,\n      minInterval: minHeartbeatFrequencyMS,\n      immediate: true\n    });\n  }\n\n  requestCheck() {\n    if (INVALID_REQUEST_CHECK_STATES.has(this.s.state)) {\n      return;\n    }\n\n    this[kMonitorId].wake();\n  }\n\n  reset() {\n    if (isInCloseState(this)) {\n      return;\n    }\n\n    stateTransition(this, STATE_CLOSING);\n    resetMonitorState(this);\n\n    // restart monitor\n    stateTransition(this, STATE_IDLE);\n\n    // restart monitoring\n    const heartbeatFrequencyMS = this.options.heartbeatFrequencyMS;\n    const minHeartbeatFrequencyMS = this.options.minHeartbeatFrequencyMS;\n    this[kMonitorId] = makeInterruptableAsyncInterval(monitorServer(this), {\n      interval: heartbeatFrequencyMS,\n      minInterval: minHeartbeatFrequencyMS\n    });\n  }\n\n  close() {\n    if (isInCloseState(this)) {\n      return;\n    }\n\n    stateTransition(this, STATE_CLOSING);\n    resetMonitorState(this);\n\n    // close monitor\n    this.emit('close');\n    stateTransition(this, STATE_CLOSED);\n  }\n}\n\nfunction resetMonitorState(monitor) {\n  stateTransition(monitor, STATE_CLOSING);\n  if (monitor[kMonitorId]) {\n    monitor[kMonitorId].stop();\n    monitor[kMonitorId] = null;\n  }\n\n  if (monitor[kRTTPinger]) {\n    monitor[kRTTPinger].close();\n    monitor[kRTTPinger] = undefined;\n  }\n\n  monitor[kCancellationToken].emit('cancel');\n  if (monitor[kMonitorId]) {\n    clearTimeout(monitor[kMonitorId]);\n    monitor[kMonitorId] = undefined;\n  }\n\n  if (monitor[kConnection]) {\n    monitor[kConnection].destroy({ force: true });\n  }\n}\n\nfunction checkServer(monitor, callback) {\n  let start = now();\n  monitor.emit('serverHeartbeatStarted', new ServerHeartbeatStartedEvent(monitor.address));\n\n  function failureHandler(err) {\n    if (monitor[kConnection]) {\n      monitor[kConnection].destroy({ force: true });\n      monitor[kConnection] = undefined;\n    }\n\n    monitor.emit(\n      'serverHeartbeatFailed',\n      new ServerHeartbeatFailedEvent(calculateDurationInMs(start), err, monitor.address)\n    );\n\n    monitor.emit('resetServer', err);\n    monitor.emit('resetConnectionPool');\n    callback(err);\n  }\n\n  if (monitor[kConnection] != null && !monitor[kConnection].closed) {\n    const connectTimeoutMS = monitor.options.connectTimeoutMS;\n    const maxAwaitTimeMS = monitor.options.heartbeatFrequencyMS;\n    const topologyVersion = monitor[kServer].description.topologyVersion;\n    const isAwaitable = topologyVersion != null;\n\n    const cmd = isAwaitable\n      ? { ismaster: true, maxAwaitTimeMS, topologyVersion: makeTopologyVersion(topologyVersion) }\n      : { ismaster: true };\n\n    const options = isAwaitable\n      ? { socketTimeout: connectTimeoutMS + maxAwaitTimeMS, exhaustAllowed: true }\n      : { socketTimeout: connectTimeoutMS };\n\n    if (isAwaitable && monitor[kRTTPinger] == null) {\n      monitor[kRTTPinger] = new RTTPinger(monitor[kCancellationToken], monitor.connectOptions);\n    }\n\n    monitor[kConnection].command('admin.$cmd', cmd, options, (err, result) => {\n      if (err) {\n        failureHandler(err);\n        return;\n      }\n\n      const isMaster = result.result;\n      const duration = isAwaitable\n        ? monitor[kRTTPinger].roundTripTime\n        : calculateDurationInMs(start);\n\n      monitor.emit(\n        'serverHeartbeatSucceeded',\n        new ServerHeartbeatSucceededEvent(duration, isMaster, monitor.address)\n      );\n\n      // if we are using the streaming protocol then we immediately issue another `started`\n      // event, otherwise the \"check\" is complete and return to the main monitor loop\n      if (isAwaitable && isMaster.topologyVersion) {\n        monitor.emit('serverHeartbeatStarted', new ServerHeartbeatStartedEvent(monitor.address));\n        start = now();\n      } else {\n        if (monitor[kRTTPinger]) {\n          monitor[kRTTPinger].close();\n          monitor[kRTTPinger] = undefined;\n        }\n\n        callback(undefined, isMaster);\n      }\n    });\n\n    return;\n  }\n\n  // connecting does an implicit `ismaster`\n  connect(monitor.connectOptions, monitor[kCancellationToken], (err, conn) => {\n    if (conn && isInCloseState(monitor)) {\n      conn.destroy({ force: true });\n      return;\n    }\n\n    if (err) {\n      monitor[kConnection] = undefined;\n\n      // we already reset the connection pool on network errors in all cases\n      if (!(err instanceof MongoNetworkError)) {\n        monitor.emit('resetConnectionPool');\n      }\n\n      failureHandler(err);\n      return;\n    }\n\n    monitor[kConnection] = conn;\n    monitor.emit(\n      'serverHeartbeatSucceeded',\n      new ServerHeartbeatSucceededEvent(\n        calculateDurationInMs(start),\n        conn.ismaster,\n        monitor.address\n      )\n    );\n\n    callback(undefined, conn.ismaster);\n  });\n}\n\nfunction monitorServer(monitor) {\n  return callback => {\n    stateTransition(monitor, STATE_MONITORING);\n    function done() {\n      if (!isInCloseState(monitor)) {\n        stateTransition(monitor, STATE_IDLE);\n      }\n\n      callback();\n    }\n\n    // TODO: the next line is a legacy event, remove in v4\n    process.nextTick(() => monitor.emit('monitoring', monitor[kServer]));\n\n    checkServer(monitor, (err, isMaster) => {\n      if (err) {\n        // otherwise an error occured on initial discovery, also bail\n        if (monitor[kServer].description.type === ServerType.Unknown) {\n          monitor.emit('resetServer', err);\n          return done();\n        }\n      }\n\n      // if the check indicates streaming is supported, immediately reschedule monitoring\n      if (isMaster && isMaster.topologyVersion) {\n        setTimeout(() => {\n          if (!isInCloseState(monitor)) {\n            monitor[kMonitorId].wake();\n          }\n        });\n      }\n\n      done();\n    });\n  };\n}\n\nfunction makeTopologyVersion(tv) {\n  return {\n    processId: tv.processId,\n    counter: BSON.Long.fromNumber(tv.counter)\n  };\n}\n\nclass RTTPinger {\n  constructor(cancellationToken, options) {\n    this[kConnection] = null;\n    this[kCancellationToken] = cancellationToken;\n    this[kRoundTripTime] = 0;\n    this.closed = false;\n\n    const heartbeatFrequencyMS = options.heartbeatFrequencyMS;\n    this[kMonitorId] = setTimeout(() => measureRoundTripTime(this, options), heartbeatFrequencyMS);\n  }\n\n  get roundTripTime() {\n    return this[kRoundTripTime];\n  }\n\n  close() {\n    this.closed = true;\n\n    clearTimeout(this[kMonitorId]);\n    this[kMonitorId] = undefined;\n\n    if (this[kConnection]) {\n      this[kConnection].destroy({ force: true });\n    }\n  }\n}\n\nfunction measureRoundTripTime(rttPinger, options) {\n  const start = now();\n  const cancellationToken = rttPinger[kCancellationToken];\n  const heartbeatFrequencyMS = options.heartbeatFrequencyMS;\n  if (rttPinger.closed) {\n    return;\n  }\n\n  function measureAndReschedule(conn) {\n    if (rttPinger.closed) {\n      conn.destroy({ force: true });\n      return;\n    }\n\n    if (rttPinger[kConnection] == null) {\n      rttPinger[kConnection] = conn;\n    }\n\n    rttPinger[kRoundTripTime] = calculateDurationInMs(start);\n    rttPinger[kMonitorId] = setTimeout(\n      () => measureRoundTripTime(rttPinger, options),\n      heartbeatFrequencyMS\n    );\n  }\n\n  if (rttPinger[kConnection] == null) {\n    connect(options, cancellationToken, (err, conn) => {\n      if (err) {\n        rttPinger[kConnection] = undefined;\n        rttPinger[kRoundTripTime] = 0;\n        return;\n      }\n\n      measureAndReschedule(conn);\n    });\n\n    return;\n  }\n\n  rttPinger[kConnection].command('admin.$cmd', { ismaster: 1 }, err => {\n    if (err) {\n      rttPinger[kConnection] = undefined;\n      rttPinger[kRoundTripTime] = 0;\n      return;\n    }\n\n    measureAndReschedule();\n  });\n}\n\nmodule.exports = {\n  Monitor\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}