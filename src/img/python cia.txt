import base64
import hashlib
from Crypto import Random
from Crypto.Cipher import AES
import tkinter as tk
from tkinter import*

encryptedTS = encryptTS(self.inputtxt.get)
l2.text = (encryptedTS)

BLOCK_SIZE = 16
pad = lambda s: s + (BLOCK_SIZE - len(s) % BLOCK_SIZE) * chr(BLOCK_SIZE - len(s) % BLOCK_SIZE)
unpad = lambda s: s[:-ord(s[len(s) - 1:])]

def encryptCS(raw, inputtxt):
    private_key = "W#RV@R#$CV@$$C$V@%#$%V5yy65=izb6y5pztvt3[4t[4tgv43t2rtv32rv=rv2-23v3av3c2fvg5tZW#RQRWEX$12342"
    raw = pad(raw)
    iv = Random.new().read(AES.block_size)
    cipher = AES.new(private_key, AES.MODE_CBC, iv)
    return base64.b64encode(iv + cipher.encrypt(raw))



def encryptTS(raw, inputtxt):
    private_key = "[CIA]V$2rVR@#V##R#V--+WVE++++||}|{|[STAFF]rV%#@@*R@JJVEFVEVE__+#@+$V#@$JDMCMMVMV.,.,[KEY]"
    raw = pad(raw)
    iv = Random.new().read(AES.block_size)
    cipher = AES.new(private_key, AES.MODE_CBC, iv)
    return base64.b64encode(iv + cipher.encrypt(raw))

def encryptSA(raw, inputtxt):
    private_key = "[CIA]V#&^@~~#[SA]^$#&@${:?nq345[ENCRYPTION]%#+[KEY]n6b#%T@#RWCTEWDWCV#%^@%"
    raw = pad(raw)
    iv = Random.new().read(AES.block_size)
    cipher = AES.new(private_key, AES.MODE_CBC, iv)
    return base64.b64encode(iv + cipher.encrypt(raw))

def encryptIS(raw, inputtxt):
    private_key = "[CIA]VR[IS]@#%!VQDQ[ENCRYPTION]52432rJVER[KEY]#$!vWV@#!SDWVVE@!"
    raw = pad(raw)
    iv = Random.new().read(AES.block_size)
    cipher = AES.new(private_key, AES.MODE_CBC, iv)
    return base64.b64encode(iv + cipher.encrypt(raw))

def encryptGEN(raw, inputtxt):
    private_key = "[CIA]%#@4[GENERAL]V#$VQ[ENCRYPTION]%#+[KEY]"
    raw = pad(raw)
    iv = Random.new().read(AES.block_size)
    cipher = AES.new(private_key, AES.MODE_CBC, iv)
    return base64.b64encode(iv + cipher.encrypt(raw))

def encryptTRAINING(raw, inputtxt):
    private_key = "6;#;+@[TRAINING_KEY]•π÷¢"
    raw = pad(raw)
    iv = Random.new().read(AES.block_size)
    cipher = AES.new(private_key, AES.MODE_CBC, iv)
    return base64.b64encode(iv + cipher.encrypt(raw))




root = Tk()
root.title("CIA Cryptography Program")
root.geometry("1000x800")
var = tk.StringVar()
var.trace("w", callback)

label = tk.Label(root, text="CIA Cryptography program by NS_Shard", padx=10, pady=10)
label.pack()

label2 = tk.Label(root, text="TOP SECRET EDITION", padx=10, pady=10)
label2.pack()

l = Label(text = "Type in text you want to encrypt/decrypt!")
inputtxt = Text(root, height = 8,
                width = 85,
                bg = "white")

Display = Button(root, height = 2,
                 width = 45,
                 text ="Top secret encryption/decryption",
                 command = encryptTS)

Display2 = Button(root, height = 2,
                 width = 45,
                 text ="Classified secret encryption/decryption",
                 command = lambda:Take_input())

Display3 = Button(root, height = 2,
                 width = 45,
                 text ="Secret encryption/decryption",
                 command = lambda:Take_input())

Display4 = Button(root, height = 2,
                 width = 45,
                 text ="Confidential encryption/decryption",
                 command = lambda:Take_input())

Display5 = Button(root, height = 2,
                 width = 45,
                 text ="Private encryption/decryption",
                 command = lambda:Take_input())

Display6 = Button(root, height = 2,
                 width = 45,
                 text ="Training encryption/decryption",
                 command = lambda:Take_input())

l2 = Label(text = "Encrypted message below")
inputtxt2 = Text(root, height = 6,
                width = 85,
                bg = "white")

l3 = Label(text = "Decrypted message below")
inputtxt3 = Text(root, height = 6,
                width = 85,
                bg = "white")

l.pack()
inputtxt.pack()
Display.pack()
Display2.pack()
Display3.pack()
Display4.pack()
Display5.pack()
Display6.pack()
Output1.pack()
l2.pack()
inputtxt2.pack()
l3.pack()
inputtxt3.pack()


